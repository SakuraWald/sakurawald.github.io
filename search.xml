<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeSnippet - A Simple Judger for Java</title>
    <url>/2022/04/05/codesnippet-a-simple-judger-for-java/</url>
    <content><![CDATA[<h1 id="A-Simple-Judger-for-Java"><a href="#A-Simple-Judger-for-Java" class="headerlink" title="A Simple Judger for Java"></a>A Simple Judger for Java</h1><p>一个简单判题机，基于Java语言，于Windows或Linux平台，为了本地测试。</p>
<h2 id="Function-List"><a href="#Function-List" class="headerlink" title="Function List"></a>Function List</h2><ul>
<li><p>易于使用的接口设计</p>
</li>
<li><p>规格化的信息格式</p>
</li>
<li><p>链式配置函数</p>
</li>
<li><p>输入/输出文件模糊扫描</p>
</li>
<li><p>支持ForEach的迭代器模式</p>
</li>
<li><p>自动案例计时</p>
</li>
<li><p>自动重定向IO</p>
</li>
<li><p>自动异常捕获</p>
</li>
<li><p>设置单案例运行时间限制</p>
</li>
<li><p>全局判题结果统计</p>
</li>
<li><p>可选的手动计时器控制</p>
</li>
<li><p>可选的忽略输入和输出</p>
</li>
<li><p>可选的输入输出行数限制</p>
</li>
<li><p>可自定义的错误流文件</p>
</li>
<li><p>输出Judger调试信息</p>
</li>
<li><p>跳过特定案例</p>
</li>
<li><p>忽略/不忽略特定案例</p>
</li>
<li><p>延迟初始化</p>
</li>
<li><p>优雅退出</p>
</li>
<li><p>内建输出函数</p>
</li>
<li><p>安全运行块</p>
</li>
</ul>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><pre><code class="lang-java">package util;

import java.awt.*;
import java.io.*;
import java.net.URI;
import java.nio.file.Files;
import java.util.List;
import java.util.Queue;
import java.util.*;
import java.util.stream.Stream;

/**
 * @author Teeth
 * @date 3/5/2022 07:16
 * A simple judger to read in the input and output files and compare them.
 */
@SuppressWarnings(&#123;&quot;UnusedReturnValue&quot;, &quot;SpellCheckingInspection&quot;&#125;)
public class Judger implements Iterable&lt;Scanner&gt;, Iterator&lt;Scanner&gt; &#123;


    /* Pair Define */
    @SuppressWarnings(&quot;unused&quot;)
    public static class Pair&lt;K, V&gt; &#123;
        public K key;
        public V value;

        public Pair(K key, V value) &#123;
            this.key = key;
            this.value = value;
        &#125;

        public K getKey() &#123;
            return key;
        &#125;

        public V getValue() &#123;
            return value;
        &#125;

        public void setKey(K key) &#123;
            this.key = key;
        &#125;

        public void setValue(V value) &#123;
            this.value = value;
        &#125;
    &#125;

    /* Special Flags */
    private static final String ignoreCaseFileNamePrefix = &quot;_&quot;;
    private static final int defaultEndTimestamp = 0xdead;

    /* Redirect System.out */
    private PrintStream tempOutPrintStream;
    private File tempOutFile;
    private Pair&lt;File, File&gt; currentCase;

    /* Case Queue */
    private boolean judgerInitialized = false;
    private final File inDirectory;
    private final File outDirectory;
    private final Queue&lt;Pair&lt;File, File&gt;&gt; caseQueue = new LinkedList&lt;&gt;();

    /* Judger Flags */
    private final ArrayList&lt;String&gt; joinCaseFileKeywords = new ArrayList&lt;&gt;();
    private final ArrayList&lt;String&gt; ignoreExceptCaseFileKeywords = new ArrayList&lt;&gt;();
    private final ArrayList&lt;String&gt; ignoreCaseFileKeywords = new ArrayList&lt;&gt;();
    private boolean skipCurrentCaseFlag = false;
    private long timeLimitMS = Long.MAX_VALUE;
    private boolean hideInputAndOutputFlag = false;
    private boolean prettyFormat = false;
    private int maxExpectInputLines = 0xbadc0de;
    private int maxExpectOutputLines = 0xbadc0de;
    private int maxYourOutputLines = 0xbadc0de;
    private boolean debugPrintFunctions = true;

    /* Statistics */
    private StringBuilder resultStatistics = new StringBuilder();
    private long startTimestamp;
    private long endTimestamp;

    /* Use this constructor if you don&#39;t know how to fill the paths */
    public Judger(File inDirectory, File outDirectory) &#123;
        this.inDirectory = inDirectory;
        this.outDirectory = outDirectory;
    &#125;

    /* It&#39;s recommended to use this constructor. */
    public Judger(String casePath) &#123;
        this(&quot;.&quot;, casePath);
    &#125;

    public Judger(String basePath, String casePath) &#123;
        this(basePath, casePath, &quot;TEST&quot;, &quot;ANSWER&quot;);
    &#125;

    public Judger(String basePath, String casePath, String inDirectoryName, String outDirectoryName) &#123;
        this.inDirectory = new File(basePath + File.separator + casePath + File.separator + inDirectoryName);
        this.outDirectory = new File(basePath + File.separator + casePath + File.separator + outDirectoryName);
    &#125;

    private String getInPath() &#123;
        return this.inDirectory.getAbsolutePath();
    &#125;

    private String getOutPath() &#123;
        return this.outDirectory.getAbsolutePath();
    &#125;

    private void initJudger() &#123;
        /* Init the exception handler */
        registerJudgerUncaughtExceptionHandler();

        /* Init file queue */
        initFileQueue();
    &#125;

    private void initFileQueue() &#123;
        try &#123;
            for (File file : new File(this.getInPath()).listFiles()) &#123;
                String entryName = file.getName();

                /* Ignore Cases */
                // Ignore Case File-Name-Prefix
                if (entryName.startsWith(ignoreCaseFileNamePrefix) &amp;&amp; this.joinCaseFileKeywords.stream().noneMatch(entryName::contains)) &#123;
                    continue;
                &#125;

                // Ignore Case File-Name-Keywords
                if (this.ignoreExceptCaseFileKeywords.size() &gt; 0) &#123;
                    if (this.ignoreExceptCaseFileKeywords.stream().noneMatch(entryName::contains) &amp;&amp; this.joinCaseFileKeywords.stream().noneMatch(entryName::contains)) &#123;
                        continue;
                    &#125;
                &#125;

                if (this.ignoreCaseFileKeywords.stream().anyMatch(entryName::contains) &amp;&amp; this.joinCaseFileKeywords.stream().noneMatch(entryName::contains))
                    continue;

                entryName = entryName.substring(0, entryName.lastIndexOf(&quot;.&quot;));

                File inEntity = new File(this.getInPath() + File.separator + entryName + &quot;.in&quot;);
                File outEntity = new File(this.getOutPath() + File.separator + entryName + &quot;.out&quot;);
                Pair&lt;File, File&gt; pair = new Pair&lt;&gt;(inEntity, outEntity);
                this.caseQueue.add(pair);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            this.displayDebugInfo();
        &#125;
    &#125;

    private Scanner redirectInput(Pair&lt;File, File&gt; pair) &#123;
        try &#123;
            return new Scanner(pair.getKey());
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    private void redirectOutput() &#123;
        try &#123;
            this.tempOutFile = File.createTempFile(&quot;temp&quot;, &quot;.out&quot;);
            this.tempOutPrintStream = new PrintStream(new FileOutputStream(this.tempOutFile));
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

        System.setOut(this.tempOutPrintStream);
    &#125;

    public Judger redirectError(String file) &#123;
        return this.redirectError(new File(file));
    &#125;

    public Judger redirectError(File file) &#123;
        try &#123;
            System.setErr(new PrintStream(new FileOutputStream(file)));
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        return this;
    &#125;

    /* This method assumes that the in-case and out-case have the same parent directory,
     *  and will write error file to the parent direcotry.
     *  */
    public Judger redirectError() &#123;
        /* Get main() java file name */
        StackTraceElement[] stackTrace = new Exception().getStackTrace();
        String runningJavaFileName = stackTrace[stackTrace.length - 1].getFileName();

        /* Redirect */
        String errorFileName = runningJavaFileName + &quot;.error&quot;;
        this.redirectError(new File(this.inDirectory.getParent() + File.separator + errorFileName));
        return this;
    &#125;

    private void displayExpectationIO(Pair&lt;File, File&gt; pair) &#123;
        System.err.println(&quot;Current Case: &quot; + pair.getKey().getName() + &quot; &amp; &quot; + pair.getValue().getName());

        /* Display Expectation IO */
        if (this.hideInputAndOutputFlag) return;
        try &#123;
            List&lt;String&gt; expectInput = Files.readAllLines(pair.getKey().toPath());
            List&lt;String&gt; expectOutput = Files.readAllLines(pair.getValue().toPath());

            // Limit Expect Input/Output
            if (this.maxExpectInputLines &lt; expectInput.size()) &#123;
                int omit = expectInput.size() - this.maxExpectInputLines;
                expectInput = expectInput.subList(0, this.maxExpectInputLines);
                this.addLimitedMessage(expectInput, omit);
            &#125;
            if (this.maxYourOutputLines &lt; expectOutput.size()) &#123;
                int omit = expectOutput.size() - this.maxExpectOutputLines;
                expectOutput = expectOutput.subList(0, this.maxExpectOutputLines);
                this.addLimitedMessage(expectOutput, omit);
            &#125;

            System.err.println(&quot;Expected  Input: &quot; + expectInput);
            System.err.println(&quot;Expected Output: &quot; + expectOutput);
            // Flush to make sure the message is displayed
            System.err.flush();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private void displaySeparator() &#123;
        System.err.println(&quot;-----------------------------------------------------&quot;);
    &#125;

    private void displayStatistics() &#123;
        this.displaySeparator();
        System.err.println(&quot;Result Statistics: &quot; + this.resultStatistics);
    &#125;

    private long displayTimeCost() &#123;
        // If the timer didn&#39;t be stopped manually, stop it.
        if (this.endTimestamp == defaultEndTimestamp) &#123;
            this.manuallyStopTimer();
        &#125;

        // Calc the time cost.
        long timeCost = this.endTimestamp - this.startTimestamp;
        System.err.printf(&quot;Time Cost: %f ms (%d ns)%n&quot;, timeCost / 1E6, timeCost);
        return timeCost;
    &#125;

    @Override
    public Iterator&lt;Scanner&gt; iterator() &#123;
        return this;
    &#125;

    @Override
    public boolean hasNext() &#123;

        /* Delay the initialization of judger */
        if (!this.judgerInitialized) &#123;
            this.initJudger();
            this.judgerInitialized = true;
            // Special case: if no case files are valid (the case directory is empty or the case is filtered).
            if (this.caseQueue.isEmpty()) &#123;
                System.err.println(&quot;No case files are valid.&quot;);
                System.err.println(&quot;1. The case directory is empty.&quot;);
                System.err.println(&quot;2. The case is filtered.&quot;);
                return false;
            &#125;
        &#125;

        /* All the cases processed ? */
        if (this.caseQueue.isEmpty()) &#123;
            // Judge the last case.
            this.judgeCase();

            // Output the statistics.
            this.displayStatistics();
            return false;
        &#125;
        return true;
    &#125;

    @Override
    public Scanner next() &#123;
        /* No more cases ? */
        if (this.caseQueue.isEmpty()) throw new IllegalStateException(&quot;No more cases.&quot;);

        /* Judge previous case ? */
        if (this.currentCase != null) &#123;
            // Judge the previous case.
            this.judgeCase();
        &#125;

        /* Get a new case */
        Pair&lt;File, File&gt; aCase = this.currentCase = this.caseQueue.poll();
        this.displaySeparator();
        this.displayExpectationIO(aCase);
        this.redirectOutput();
        Scanner scanner = this.redirectInput(aCase);

        /* Start the timer */
        this.manuallyStartTimer();
        return scanner;
    &#125;

    public Pair&lt;File, File&gt; getCurrentCase() &#123;
        return this.currentCase;
    &#125;

    public String getCurrentCaseName() &#123;
        return this.currentCase.getKey().getName();
    &#125;

    /**
     * Call this function if you want to reset the timer.
     */
    public void manuallyStartTimer() &#123;
        this.startTimestamp = System.nanoTime();
        this.endTimestamp = defaultEndTimestamp;
    &#125;

    public void manuallyStopTimer() &#123;
        this.endTimestamp = System.nanoTime();
    &#125;

    public Judger displayDebugInfo() &#123;
        this.displaySeparator();
        System.err.println(&quot;● Java Program Run Path = &quot; + new File(&quot;.&quot;).getAbsolutePath());
        try &#123;
            System.err.println(&quot;☆ InPath = &quot; + this.getInPath());
            System.err.println(&quot;☆ InPath (Absolute) = &quot; + new File(this.getInPath()).getAbsolutePath());
            System.err.println(&quot;★ InPath (Canonical) = &quot; + new File(this.getInPath()).getCanonicalPath());
            System.err.println(&quot;☆ OutPath = &quot; + this.getOutPath());
            System.err.println(&quot;☆ OutPath (Absolute) = &quot; + new File(this.getOutPath()).getAbsolutePath());
            System.err.println(&quot;★ OutPath (Canonical) = &quot; + new File(this.getOutPath()).getCanonicalPath());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        this.displaySeparator();
        return this;
    &#125;


    public Judger hideInputAndOutput() &#123;
        this.hideInputAndOutputFlag = true;
        return this;
    &#125;

    public Judger setTimeLimitMS(long timeLimitMS) &#123;
        this.timeLimitMS = timeLimitMS;
        return this;
    &#125;

    public Judger setMaxExpectedInputLines(int limit) &#123;
        this.maxExpectInputLines = limit;
        return this;
    &#125;

    public Judger setMaxExpectedOutputLines(int limit) &#123;
        this.maxExpectOutputLines = limit;
        return this;
    &#125;

    public Judger setMaxYourOutputLines(int limit) &#123;
        this.maxYourOutputLines = limit;
        return this;
    &#125;

    public Judger enablePrettyFormat() &#123;
        this.prettyFormat = true;
        return this;
    &#125;

    public Judger disablePrettyFormat() &#123;
        this.prettyFormat = false;
        return this;
    &#125;

    public Judger enableDebugPrintFunctions() &#123;
        this.debugPrintFunctions = true;
        return this;
    &#125;

    public Judger disableDebugPrintFunctions() &#123;
        this.debugPrintFunctions = false;
        return this;
    &#125;

    private void addLimitedMessage(List&lt;String&gt; list, int omit) &#123;
        list.add(String.format(&quot;Omit the remaining %d line(s)...&quot;, omit));
    &#125;

    private String prettyFormat(List&lt;String&gt; list) &#123;
        StringBuilder sb = new StringBuilder(&quot;\n&quot;);
        sb.append(&quot;[SOF]&quot;);
        for (int i = 0; i &lt; list.size(); i++) &#123;
            sb.append(list.get(i));
            if (i == list.size() - 1) &#123;
                sb.append(&quot;[EOF]&quot;);
            &#125; else sb.append(&quot;\n&quot;);
        &#125;
        // Special case: empty list
        if (list.isEmpty()) sb.append(&quot;[EOF]&quot;);
        return sb.toString();
    &#125;

    private String formatList(List&lt;String&gt; list) &#123;
        if (this.prettyFormat) &#123;
            return this.prettyFormat(list);
        &#125; else return list.toString();
    &#125;

    /* Judger will set a skip flag, but you should manually skip your algorithm steps. */
    public Judger skipCurrentCase() &#123;
        this.skipCurrentCaseFlag = true;
        return this;
    &#125;

    public Judger ignoreExceptCase(String keywords) &#123;
        this.ignoreExceptCaseFileKeywords.add(keywords);
        return this;
    &#125;

    public Judger ignoreCase(String keywords) &#123;
        this.ignoreCaseFileKeywords.add(keywords);
        return this;
    &#125;

    /* Join a case and guarantee the case will be added into cases queue */
    public Judger joinCase(String keywords) &#123;
        this.joinCaseFileKeywords.add(keywords);
        return this;
    &#125;

    @SuppressWarnings(&quot;UnusedAssignment&quot;)
    private void judgeCase() &#123;

        /* Read from the temp out file */
        List&lt;String&gt; tempOutFileContent = null;
        try &#123;
            tempOutFileContent = Files.readAllLines(this.tempOutFile.toPath());
            if (!this.hideInputAndOutputFlag) &#123;

                if (this.maxYourOutputLines &lt; tempOutFileContent.size()) &#123;
                    int omit = tempOutFileContent.size() - this.maxYourOutputLines;
                    tempOutFileContent = tempOutFileContent.subList(0, this.maxYourOutputLines);
                    this.addLimitedMessage(tempOutFileContent, omit);
                &#125;

                System.err.println(&quot;Your     Output: &quot; + formatList(tempOutFileContent));
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

        /* End the timer. */
        // it&#39;s better to stop the timer earlier, but it&#39;s not necessary.
        long timeCost = 0;
        if (!this.skipCurrentCaseFlag) &#123;
            timeCost = this.displayTimeCost();
        &#125;

        /* Judge Result Type */
        List&lt;String&gt; expectedOutFileContent;
        try &#123;
            /* Handle Judger Flags */
            if (this.skipCurrentCaseFlag) &#123;
                this.skipCurrentCaseFlag = false;
                this.resultStatistics.append(&quot;→ &quot;);
                System.err.println(&quot;Skipped.&quot;);
                return;
            &#125;

            /* Compare the texts */
            expectedOutFileContent = Files.readAllLines(this.currentCase.getValue().toPath());
            boolean accepted = true;
            String message = &quot;Accepted&quot;;
            String symbol = &quot;√&quot;;

            // Your Output == Expect Output ?
            if (!Boolean.logicalAnd(accepted, tempOutFileContent.toString().equals(expectedOutFileContent.toString()))) &#123;
                accepted = false;
                message = &quot;Wrong Answer.&quot;;
                symbol = &quot;×&quot;;
            &#125;
            // Time Limit Exceed ?
            else if (!Boolean.logicalAnd(accepted, (timeCost / 1E6) &lt;= this.timeLimitMS)) &#123;
                accepted = false;
                message = &quot;Time Limit Exceed.&quot;;
                symbol = &quot;▲&quot;;
            &#125;

            this.resultStatistics.append(symbol).append(&quot; &quot;);
            System.err.println(message);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
            this.resultStatistics.append(&quot;? &quot;);
            System.err.println(&quot;Unexpected Error !&quot;);
        &#125;
    &#125;

    public void gracefullyExit(boolean closeStreams, boolean exit) &#123;
        System.err.println(&quot;===== Begin gracefully exit =====&quot;);

        /* Judge case before exit */
        this.judgeCase();

        /* Flush and close the System.in stream. */
        // Nobody cares the input stream.

        /* Flush and close the System.out stream. */
        System.out.flush();
        if (closeStreams) &#123;
            System.out.close();
        &#125;

        /* Flush and close the System.err stream. */
        System.err.println(&quot;===== End gracefully Exit. =====&quot;);
        System.err.flush();
        if (closeStreams) &#123;
            System.err.close();
        &#125;

        /* Exit the JVM */
        if (exit) &#123;
            System.exit(0);
        &#125;
    &#125;

    private void setThreadUncaughtExceptionHandler(Thread thread) &#123;
        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;
            /* Handle the exception. */
            this.displayThrowable(t, e);

            /* Gracefully exit. */
            gracefullyExit(true, true);
        &#125;);
    &#125;

    private void displayThrowable(Thread t, Throwable e) &#123;
        System.err.println(&quot;===== Exception Occurred. =====&quot;);
        System.err.println(&quot;Current Thread: &quot; + t);
        e.printStackTrace();
        System.err.println(&quot;\n&quot;);
    &#125;

    private void registerJudgerUncaughtExceptionHandler() &#123;
        this.setThreadUncaughtExceptionHandler(Thread.currentThread());
    &#125;

    public Judger println(Object object) &#123;
        if (this.debugPrintFunctions) &#123;
            System.out.println(object);
        &#125;
        return this;
    &#125;

    public Judger print(Object object) &#123;
        if (this.debugPrintFunctions) &#123;
            System.out.print(object);
        &#125;
        return this;
    &#125;

    public Judger printf(String format, Object... args) &#123;
        if (this.debugPrintFunctions) &#123;
            System.out.printf(format, args);
        &#125;
        return this;
    &#125;

    public Judger safeRun(Runnable runnable) &#123;
        try &#123;
            runnable.run();
        &#125; catch (Exception e) &#123;
            /* Display Throwable */
            this.displayThrowable(Thread.currentThread(), e);

            /* Handle Throwable */
            // Store judger context
            StringBuilder $resultStatistics = this.resultStatistics;
            this.resultStatistics = new StringBuilder();
            // Gracefully exit (but don&#39;t exit the JVM)
            this.gracefullyExit(false, false);
            // Load judger context
            this.resultStatistics = $resultStatistics;
        &#125;
        return this;
    &#125;

    public abstract static class MermaidBuilder &#123;

        public final Style style = new Style(this);
        public final Counter counter = new Counter();
        private ArrayList&lt;String&gt; mermaidStatements;

        public MermaidBuilder() &#123;
            this.reset();
        &#125;

        public abstract void preStatement();

        public abstract void postStatement();

        public void uniqueStatement() &#123;
            HashSet&lt;String&gt; visited = new HashSet&lt;&gt;();
            ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();
            for (String statement : this.mermaidStatements) &#123;
                if (!visited.contains(statement)) &#123;
                    visited.add(statement);
                    result.add(statement);
                &#125;
            &#125;
            this.mermaidStatements = result;
        &#125;

        public void reset() &#123;
            this.mermaidStatements = new ArrayList&lt;&gt;();
            this.preStatement();
        &#125;

        public String build() &#123;
            /* PostStatement */
            this.postStatement();

            /* Build Mermaid String */
            StringBuilder mermaidStringBuilder = new StringBuilder();
            for (String mermaidStatement : this.mermaidStatements) &#123;
                mermaidStringBuilder.append(mermaidStatement).append(&quot;\n&quot;);
            &#125;
            return mermaidStringBuilder.toString();
        &#125;

        protected abstract Stream&lt;String&gt; parseNode(Object... args);

        public void addStatement(String statement) &#123;
            this.mermaidStatements.add(statement);
        &#125;

        public void addNode(Object... args) &#123;
            Optional.ofNullable(this.parseNode(args)).ifPresent(o -&gt; o.forEach(statement -&gt; &#123;
                if (statement != null) &#123;
                    this.addStatement(statement);
                &#125;
            &#125;));
        &#125;

        public void print() &#123;
            System.out.println();
            System.out.println(&quot;===== Begin Mermaid Statements =====&quot;);
            System.out.println(this.build());
            System.out.println(&quot;===== End Mermaid Statements =====&quot;);
        &#125;

        public void image() &#123;
            String base64 = new String(Base64.getEncoder().encode(this.build().getBytes()));
            String URL = &quot;https://mermaid.ink/img/&quot; + base64;
            try &#123;
                Desktop.getDesktop().browse(new URI(URL));
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        public String ofID(Object... args) &#123;
            StringBuilder id = new StringBuilder();
            for (int i = 0; i &lt; args.length; i++) &#123;
                id.append(args[i]);
                if (i != args.length - 1) &#123;
                    id.append(&quot;#&quot;);
                &#125;
            &#125;
            return id.toString();
        &#125;

        public String uuid() &#123;
            return UUID.randomUUID().toString().substring(0, 8);
        &#125;

        public static class Style &#123;
            private final MermaidBuilder builder;

            public Style(MermaidBuilder builder) &#123;
                this.builder = builder;
            &#125;

            public void stress(String nodeID, String color) &#123;
                builder.addStatement(String.format(&quot;style %s fill: %s,stroke: #333,stroke-width: 4px&quot;, nodeID, color));
            &#125;

            public void css(String nodeID, String css) &#123;
                builder.addStatement(String.format(&quot;style %s %s&quot;, nodeID, css));
            &#125;
        &#125;

        public static class Counter &#123;
            private int counter;

            public Counter() &#123;
                this.reset();
            &#125;

            public void reset() &#123;
                this.counter = 0;
            &#125;

            public int increment(int delta) &#123;
                return this.counter += delta;
            &#125;

            public int increment() &#123;
                return this.increment(+1);
            &#125;

            public int get() &#123;
                return counter;
            &#125;

            public void set(int value) &#123;
                this.counter = value;
            &#125;
        &#125;

    &#125;

    public static class MarkdownBuilder &#123;

        public static String buildMatrix(Object origin, Object[] rows, Object[] cols, Object[][] data) &#123;

            /* Default value */
            if (origin == null) &#123;
                origin = &quot;&quot;;
            &#125;

            if (rows == null) &#123;
                rows = new String[data.length];
                for (int i = 0; i &lt; data.length; i++) &#123;
                    rows[i] = String.valueOf(i);
                &#125;
            &#125;

            if (cols == null) &#123;
                cols = new String[data[0].length];
                for (int i = 0; i &lt; data[0].length; i++) &#123;
                    cols[i] = String.valueOf(i);
                &#125;
            &#125;

            /* Construct */
            StringBuilder result = new StringBuilder();
            result.append(&quot;\\begin&#123;bmatrix&#125;\n&quot;);
            for (int i = 0; i &lt; data.length; i++) &#123;
                // first row
                if (i == 0) &#123;
                    for (int j = 0; j &lt; cols.length; j++) &#123;
                        // origin cell
                        if (j == 0) &#123;
                            result.append(origin);
                            continue;
                        &#125;
                        result.append(&quot;&amp;&quot;).append(cols[j]);
                    &#125;
                    result.append(&quot;\\\\\n&quot;);
                    continue;
                &#125;
                // first column
                for (int j = 0; j &lt; data[i].length; j++) &#123;
                    if (j == 0) &#123;
                        result.append(rows[i]);
                        continue;
                    &#125;
                    result.append(&quot;&amp;&quot;).append(data[i][j]);
                &#125;
                result.append(&quot;\\\\&quot;).append(&quot;\n&quot;);
            &#125;

            result.append(&quot;\\end&#123;bmatrix&#125;\n&quot;);
            return result.toString();
        &#125;

        public static String buildTable(Object origin, Object[] rows, Object[] cols, Object[][] data) &#123;

            /* Default value */
            if (origin == null) &#123;
                origin = &quot;&quot;;
            &#125;

            if (rows == null) &#123;
                rows = new String[data.length];
                for (int i = 0; i &lt; data.length; i++) &#123;
                    rows[i] = String.valueOf(i);
                &#125;
            &#125;

            if (cols == null) &#123;
                cols = new String[data[0].length];
                for (int i = 0; i &lt; data[0].length; i++) &#123;
                    cols[i] = String.valueOf(i);
                &#125;
            &#125;

            /* Construct */
            StringBuilder result = new StringBuilder().append(&quot;\n&quot;);
            for (int i = 0; i &lt; data.length; i++) &#123;
                // first row
                if (i == 0) &#123;
                    for (int j = 0; j &lt; cols.length; j++) &#123;
                        // origin cell
                        if (j == 0) &#123;
                            result.append(&quot;&quot;).append(origin).append(&quot;&quot;);
                            continue;
                        &#125;
                        result.append(cols[j]).append(&quot;&quot;);
                    &#125;
                    result.append(&quot;\n&quot;);

                    // second row -&gt; table properties
                    for (int j = 0; j &lt; cols.length; j++) &#123;
                        result.append(&quot; :-: &quot;);
                    &#125;
                    result.append(&quot;&quot;).append(&quot;\n&quot;);
                &#125;

                for (int j = 0; j &lt; data[i].length; j++) &#123;
                    // first column
                    if (j == 0) &#123;
                        result.append(&quot;&quot;).append(rows[i]).append(&quot;&quot;);
                    &#125;
                    result.append(data[i][j]).append(&quot;&quot;);
                &#125;
                result.append(&quot;\n&quot;);
            &#125;
            return result.append(&quot;\n&quot;).toString();
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h4 id="Simple-Demo"><a href="#Simple-Demo" class="headerlink" title="Simple Demo"></a>Simple Demo</h4><pre><code class="lang-java">    public static Judger judger = new Judger(&quot;/Cases/Two&#39;s Sum&quot;);
    public static void main(String[] args) &#123;
        for (Scanner scanner : judger) &#123;
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int sum = a + b;
            System.out.println(sum);
        &#125;
    &#125;
</code></pre>
<h4 id="Advanced-Demo"><a href="#Advanced-Demo" class="headerlink" title="Advanced Demo"></a>Advanced Demo</h4><pre><code class="lang-java">    public static Judger judger = new Judger(&quot;/Cases/Two&#39;s Sum&quot;)
        .redirectError()
        .enablePrettyFormat()
        .ignoreExceptCase(&quot;CASES&quot;)
        .ignoreCase(&quot;CASE5&quot;)
        .joinCase(&quot;CASE3&quot;)
        .setMaxExpectedInputLines(1)
        .setTimeLimitMS(1000);

    public static void main(String[] args) &#123;
        for (Scanner scanner : judger) &#123;
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int sum = a + b;
            System.out.println(sum);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>解释：让 <code>Judger</code> 从 <code>&quot;/Cases/Lab5/COIN CHANGING&quot;</code> 路径下 <code>扫描</code> 所有的 <code>案例文件</code>，然后 <code>重定向错误</code>到合适的路径，并且期望启用 <code>自由格式输出</code>，还需要设置 <code>期望输出的最大显示限制</code>，此外，每个案例的 <code>运行时间</code>限定为 1000ms。</p>
<p>所有 <code>被扫描到且有效的案例文件</code> 将被创建为 <code>Scanner实例序列</code>，通过 <code>foreach语法糖</code>即可获得所有的 <code>案例实例</code></p>
</blockquote>
]]></content>
      <tags>
        <tag>oj</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler Test</title>
    <url>/2023/01/15/compiler-test/</url>
    <content><![CDATA[
$$
\boxed{@}

% Color % 
\newcommand\c[2]{\textcolor{#1}{#2}} 
\newcommand\r[1]{\textcolor{red}{#1}} 
\newcommand\g[1]{\textcolor{green}{#1}} 
\newcommand\b[1]{\textcolor{blue}{#1}} 
\newcommand\red[1]{\textcolor{red}{#1}} 
\newcommand\blue[1]{\textcolor{blue}{#1}} 
\newcommand\green[1]{\textcolor{green}{#1}} 
\newcommand\black[1]{\textcolor{black}{#1}} 
\newcommand\white[1]{\textcolor{white}{#1}} 
\newcommand\cyan[1]{\textcolor{cyan}{#1}} 
\newcommand\magenta[1]{\textcolor{magenta}{#1}} 
\newcommand\yellow[1]{\textcolor{yellow}{#1}} 
\newcommand\orange[1]{\textcolor{orange}{#1}} 
\newcommand\lime[1]{\textcolor{lime}{#1}} 
\newcommand\pink[1]{\textcolor{pink}{#1}} 
\newcommand\darkgray[1]{\textcolor{darkgray}{#1}} 
\newcommand\gray[1]{\textcolor{gray}{#1}} 
\newcommand\lightgray[1]{\textcolor{lightgray}{#1}} 
\newcommand\brown[1]{\textcolor{brown}{#1}} 
\newcommand\olive[1]{\textcolor{olive}{#1}} 
\newcommand\purple[1]{\textcolor{purple}{#1}} 
\newcommand\teal[1]{\textcolor{teal}{#1}} 
\newcommand\violet[1]{\textcolor{violet}{#1}} 
\newcommand\hotpink[1]{\textcolor{hotpink}{#1}} 
\newcommand\blueviolet[1]{\textcolor{blueviolet}{#1}} 
\newcommand\navyblue[1]{\textcolor{navyblue}{#1}} 
\newcommand\peach[1]{\textcolor{Peach}{#1}} 
\newcommand\orangeRed[1]{\textcolor{OrangeRed}{#1}} 
\newcommand\salmon[1]{\textcolor{Salmon}{#1}} 
\newcommand\skyblue[1]{\textcolor{SkyBlue}{#1}} 
\newcommand\springreen[1]{\textcolor{SpringGreen}{#1}} 
\newcommand\aqua[1]{\textcolor{aqua}{#1}} 
\newcommand\navy[1]{\textcolor{navy}{#1}} 
\newcommand\silver[1]{\textcolor{silver}{#1}} 
\newcommand\fuchsia[1]{\textcolor{fuchsia}{#1}} 
\newcommand\maroon[1]{\textcolor{maroon}{#1}} 
\definecolor{luo}{RGB}{102,204,255}
\definecolor{miku}{RGB}{57,197,187} 
\newcommand\luo[1]{\textcolor{luo}{#1}} 
\newcommand\miku[1]{\textcolor{miku}{#1}}

% Typography % 
\newcommand\a[1]{\begin{aligned}#1\end{aligned}} 
\newcommand\t[1]{\text{#1}} 
\newcommand\lb[1]{\left{\begin{aligned} #1 \end{aligned}\right.} 
\newcommand\rb[1]{\left.\begin{aligned} #1 \end{aligned}\right}} 
\newcommand\env[2]{\begin{#1}#2\end{#1}}

% Misc % 
\newcommand\s[1]{{#1}} 
\newcommand\qed{\quad\square} 
\newcommand\define{\dot{=}} 
\newcommand\then{\implies} 
\newcommand\rounddown[1]{\lfloor{#1}\rfloor} 
\newcommand\roundup[1]{\lceil{#1}\rceil} 
\newcommand\graph[4]{#1 = (#2, #3) \quad |#2| = #4} 
\newcommand\G{G = (V, E) \quad |V| = n} 
\newcommand\so{\therefore} 
\newcommand\comment[1]{\quad\text{(#1)}} 
\newcommand\note[1]{\quad\text{(#1)}} 
\newcommand\bt[1]{\boxed{\text{#1}}} 
\newcommand\max[1]{\textbf{ max } {#1} } 
\newcommand\min[1]{\textbf{ min } {#1} } 
\newcommand\IF{\textbf{ IF }} 
\newcommand\if{\textbf{ if }} 
\newcommand\IS{\textbf{ IS }} 
\newcommand\is{\textbf{ is }} 
\newcommand\but{\textbf{ but }} 
\newcommand\however{\textbf{ however }} 
\newcommand\AND{\textbf{ AND }} 
\newcommand\OR{\textbf{ OR }} 
\newcommand\NOT{\textbf{ NOT }} 
\newcommand\THEN{\textbf{ THEN }} 
\newcommand\IN{\textbf{ IN }} 
\newcommand\NOTIN{\textbf{ NOT-IN }} 
\newcommand\assume{\textbf{ Assuming that: }} 
\newcommand\contradictory{\textbf{ Thus lead to contradiction }} 
\newcommand\proof{\textbf{Proof: }} 
\newcommand\st{\text{ such that }} 
\newcommand\hold{\text{ holds }} 
\newcommand\lhs{\text{ LHS }} 
\newcommand\rhs{\text{ RHS }} 
\newcommand\wlg{\text{ Without loss of generality }} 
\newcommand\nb{\text{ nota bene }} 
\newcommand\analogously{\text{ analogously }} 
\newcommand\viceversa{\textbf{ viceversa }} 
\newcommand\let{\textbf{ let }} 
\newcommand\as{\textbf{ as }} 
\newcommand\for{\textbf{ As for }} 
\newcommand\select{\textbf{ SELECT }} 
\newcommand\m[1]{\mathit{#1}} 
\newcommand+[1]{\mathcal{#1}} 
\newcommand\warnning[1]{\colorbox{Blue}{\textcolor{Yellow}{#1}}} 
\newcommand\error[1]{\colorbox{Black}{\textcolor{White}{#1}}}
$$

<hr>
<p>这是中文<code>and</code>英文</p>
<p>这是中文 <code>and</code> 英文</p>
<p>这是 <code>code fence</code></p>
<blockquote>
<p><strong>Warning</strong></p>
<p>This is a warning</p>
</blockquote>
<pre><code class="lang-java">Hello World
</code></pre>
<pre><code class="lang-mermaid">graph TD;
      A--&gt;B;
      A--&gt;C;
      B--&gt;D;
      C--&gt;D;
</code></pre>
<blockquote>
<pre><code class="lang-mermaid">graph TD;
     A--&gt;B;
     A--&gt;C;
     B--&gt;D;
     C--&gt;D;
</code></pre>
<pre><code class="lang-java">This is the first line.
This is the second line.
This is the thrid line.
</code></pre>
<pre><code class="lang-mermaid">classDiagram
class JspContext &#123;
+getAttribute(String name)
+getAttribute(String name, int scope)
+getAttributeNames()
+findAttribuite(String name)
&#125;

JspContext &lt;-- PageContext
class PageContext&#123;
+APPLICATION_SCOPE
+PAGE_SCOPE
+REQUEST_SCOPE
+SESSION_SCOPE
+getRequest()
+getServletConfig()
+getServletContext()
+getSession()
&#125;
</code></pre>
<p>原理：$\lceil x/y \rceil = \lfloor(x\textcolor{blue}{+y-1})/y \rfloor$</p>
<p>证明</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boxed{\text{采用Biasing修复算术右移默认的向下舍入误差}} \\
&x \dot{=} qy + r,\quad 0 \le r \lt y \\
&\implies (x+y-1)/y = q + (r+y-1)/y \\
&\implies \lfloor (\textcolor{red}{x}+y-1)/y \rfloor = q + \lfloor (\textcolor{red}{r}+y-1)/y\rfloor \\
&= q + epsilon(r) =
\begin{cases}
0,& r = 0 \\
1 ,& r \gt 0
\end{cases}
\end{aligned}</script></blockquote>
<p>$\lceil x/y \rceil = \lfloor(x\textcolor{blue}{+y-1})/y \rfloor$</p>
<script type="math/tex; mode=display">
\begin{aligned}
first \\
second
\end{aligned}</script><p>Hi, here are some katex/mathjax examples.</p>
<p>linebreak</p>
<script type="math/tex; mode=display">
\a{
& \boxed{\t{This is a abox}} \\
& \r{\t{This is red}} \\
& \b{\t{This is blue}}
}</script><p><img src="https://camo.githubusercontent.com/53d0e59a884a0744867fe672d691af14c3d7ff00dc1db8d2354c0d897307607c/687474703a2f2f7777772e706f6c6f6e656c2e636f6d2f736e61636b6261722f6c6f676f5f6c617267652e706e67" alt="SnackBar"></p>
]]></content>
      <tags>
        <tag>test</tag>
        <tag>web</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP - Servlet &amp; JSP Short-Hand</title>
    <url>/2022/06/13/jsp-servlet-jsp-short-hand/</url>
    <content><![CDATA[<h1 id="Servlets-amp-JSP-Short-hand"><a href="#Servlets-amp-JSP-Short-hand" class="headerlink" title="Servlets &amp; JSP Short-hand"></a>Servlets &amp; JSP Short-hand</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Register-a-servlet"><a href="#Register-a-servlet" class="headerlink" title="Register a servlet"></a>Register a servlet</h3><pre><code class="lang-xml">&lt;web-app ...&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;This Is Your Custom Servet Name&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sakurawald.MyServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;   

    &lt;servlet-mapping&gt;
        &lt;serlvet-name&gt;This Is Your Custom Servet Name&lt;/serlvet-name&gt;
        &lt;url-pattern&gt;/some_url_you_want_to_map&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;    
&lt;/web-app&gt;
</code></pre>
<h3 id="Life-cycle"><a href="#Life-cycle" class="headerlink" title="Life-cycle"></a>Life-cycle</h3><p><code>Servlet生命周期</code></p>
<ul>
<li>servlet类加载</li>
<li>servlet实例化</li>
<li>servlet#init</li>
<li>servlet#service</li>
<li>servlet#destroy</li>
</ul>
<h3 id="A-simple-servlet-demo"><a href="#A-simple-servlet-demo" class="headerlink" title="A simple servlet demo"></a>A simple servlet demo</h3><pre><code class="lang-java">import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Ch2Servlet extends HttpServlet &#123;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        PrintWriter out = response.getWriter();
        out.println(&quot;&lt;a&gt;hello world&lt;/a&gt;&quot;);
    &#125;

&#125;
</code></pre>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote>
<p>Servlet只运行自己的业务代码，然后调用一个特定的JSP处理响应HTML，这就能把 <code>业务逻辑</code> 与 <code>表示</code> 相分离。</p>
<p>而采用MVC，不仅要求 <code>业务逻辑</code> 与 <code>表示</code> 相分离，实际上，<code>业务逻辑</code> 根本不知道有 <code>表示</code> 的 存在。</p>
</blockquote>
<p>MVC的组成部分：</p>
<ul>
<li>Model (模型)：包含具体的 <code>业务逻辑</code> 和 <code>状态</code>。</li>
<li>View (视图)：负责进行 <code>表示</code>。</li>
<li>Controller (控制器)：从 <code>请求</code> 获得 <code>用户输入</code>，并明确这些输入对 <code>模型</code> 有什么影响。</li>
</ul>
<p>Misc</p>
<ul>
<li>容器为 <code>Web应用</code> 提供了 <code>通信支持</code>，<code>生命周期管理</code>， <code>多线程支持</code>， <code>声明方式安全</code>， 以及 <code>JSP支持</code></li>
<li>容器根据 <code>URL</code> 查找 <code>正确的Servlet</code>，并把 <code>请求</code> 传递给该Servlet</li>
</ul>
<hr>
<pre><code class="lang-java">// src/com/example/web/BeerServlet.java
package com.example.web;

import com.example.model.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

public class BeerServlet extends HttpServlet &#123;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;

        String c = request.getParameter(&quot;color&quot;);
        BeerExpert be = new BeerExpert();
        List result = be.getBrands(c);

        reqeust.setAttribute(&quot;styles&quot;, result);
        RequestDispatcher view = request.getRequestDispatcher(&quot;result.jsp&quot;);
        view.forward(request, response);
    &#125;

&#125;
</code></pre>
<pre><code class="lang-jsp">// result.jsp
&lt;%@ page import=&quot;java.util.*&quot; %&gt;

&lt;html&gt;
    &lt;body&gt;
        &lt;h1 align=&quot;center&quot;&gt;
            Beer Recommendations JSP
        &lt;/h1&gt;
        &lt;p&gt;

            &lt;%

                List styles = (List) request.getAttribute(&quot;styles&quot;);
                Iterator it = styles.iterator();
                while(it.hasNext()) &#123;
                    out.print(&quot;&lt;br&gt;try:&quot; + it.next);
                &#125;

            %&gt;

        &lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Servlet-Request-amp-Response"><a href="#Servlet-Request-amp-Response" class="headerlink" title="Servlet: Request &amp; Response"></a>Servlet: Request &amp; Response</h3><blockquote>
<p><code>Servet的每个实例...</code> 这种说法是错误的，<code>任何Servlet类</code> 都不会有多个 <code>实例</code>。（除非使用 <code>SingleThreadModel</code>）</p>
<p>否则 <code>容器</code> 运行 <code>多个线程</code> 来处理 <code>对1个Servlet</code> 的 <code>多个请求</code> （准确地说：<code>每个请求</code> 使用 <code>1个线程</code> 来请求 <code>指定的Servlet</code>）</p>
<p>对于 <code>每个Servlet</code>，请在 <code>init()</code> 中进行 <code>初始化操作</code> 而不是 <code>构造器函数</code> 当中。</p>
<p><code>构造器函数</code> 使得 <code>Servlet</code> 具备 <code>Servlet特性 (Servletness)</code>，并获得 <code>作为Servlet所应具有的特权</code>：如 <code>通过ServletContext引用从容器中获取信息</code> 。</p>
<p>所以，请不要在 <code>构造器函数</code> 中过早地进行 <code>初始化操作</code> （在 <code>构造器函数</code> 中我们无法 <code>获得关于Web应用的配置信息等</code>）</p>
<p><code>每个Servlet</code> 都有 <code>自己特有的1个 ServletConfig对象</code>，它可以用于访问 <code>整个App共享的1个ServletContext</code>。</p>
<blockquote>
<p>注意：<code>ServletContext</code> 更准确得叫法应该叫 <code>AppContext</code>，因为 <code>实际上</code>，<code>每个Web应用</code> <code>有且仅有</code> 1个 <code>ServletContext</code> ！！！</p>
<p>这 <code>并不是</code> 你所想的那样：<code>每个Servlet</code> 都有 <code>自己特有的1个 ServletContext</code></p>
<blockquote>
<p>但是：<code>每个Servlet</code> 确确实实有 <code>自己特有的1个 ServletConfig</code> ！！！！！</p>
</blockquote>
</blockquote>
<pre><code class="lang-mermaid">classDiagram

class ServletRequest&#123;
   +Object getAttribute(String)
   +String getParamterer(String)
   +Enumeration getParameterNames()

&#125;
class ServletResponse&#123;
+ServletOutputStream getOutputStream()
+PrintWriter getWriter()
&#125;
ServletRequest &lt;-- HttpServletRequest
class HttpServletRequest &#123;
+String getContextPath()
+Cookie[] getCookies()
+String getHeader(String)
+String getQueryString()
+HttpSession getSession()
+String getMethod()
&#125;

ServletResponse &lt;-- HttpServletResponse
class HttpServletResponse &#123;
+void addCookie(Cookie)
+void addHeader(String name, String value)
&#125;
</code></pre>
<blockquote>
<p>之所以需要有 <code>GenericServlet</code> 以及 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> ，是因为 <code>可能会有人</code> 将 <code>Servlet技术模型</code> 用于 <code>其他协议</code> （大概不会有人）。</p>
</blockquote>
<p>Servlet可以处理的 <code>HTTP Methods</code> 包括：<code>GET</code> ，<code>PUT</code>，<code>HEAD</code>，<code>TRACE</code>，<code>OPTIONS</code>，<code>PUT</code>，<code>DELETE</code> 和 <code>CONNECT</code></p>
<p>我们使用 <code>doGet()</code> 来处理 <code>简单请求</code>，而使用 <code>doPost()</code> 来 <code>接收和处理表单数据</code></p>
<p>HTTP Method</p>
<p>Description</p>
<p>GET</p>
<p>要求得到所请求URL上的一个东西 （资源/文件）</p>
<p>POST</p>
<p>要求服务器接受 <code>附加到请求体的体信息</code>，并提供 <code>所请求URL上的一个东西</code>。这类似于 <code>附带了额外信息的GET</code></p>
<p>HEAD</p>
<p>只要求得到 <code>GET返回结果的首部部分</code>。这类似于 <code>响应中没有体的GET</code></p>
<p>TRACE</p>
<p>要求请求消息 <code>回送</code>，这样客户端能够 <code>看到</code> 另一端接收了什么，以便进行调试。</p>
<p>PUT</p>
<p>指出要把 <code>所包含的体</code> 放在 <code>请求的URL</code> 上</p>
<p>DELETE</p>
<p>指出删除 <code>所请求的URL</code> 上的东西 （资源/文件）</p>
<p>OPTIONS</p>
<p>要求得到 <code>一个HTTP Method列表</code>，表明 <code>所请求的URL</code> 可以处理 这些方法</p>
<p>CONNECT</p>
<p>要求连接以 <code>建立隧道</code></p>
<blockquote>
<p>关于 <code>幂等性</code>：<code>GET</code> 是 <code>幂等的</code>，但 <code>POST</code> 不是。</p>
</blockquote>
<p><code>表单 FORM</code> 的默认 <code>HTTP METHOD</code> 为 <code>GET</code> ！！！</p>
<p>除非你 <code>手动地</code> 指定为 <code>POST</code></p>
<pre><code class="lang-html">&lt;form method=&quot;POST&quot; action=&quot;SelectBeer.do&quot;&gt;
 &lt;p&gt;
     Select beer characteristics
 &lt;/p&gt;
 &lt;select name=&quot;color&quot; size=&quot;1&quot;&gt;
     &lt;option&gt;light&lt;/option&gt;
     &lt;optoin&gt;amber&lt;/optoin&gt;
     &lt;option&gt;brown&lt;/option&gt;
     &lt;option&gt;dark&lt;/option&gt;
 &lt;/select&gt;

 &lt;center&gt;
 &lt;input type=&quot;SUBMIT&quot;&gt;
 &lt;/center&gt;

&lt;/form&gt;
</code></pre>
<p>同样的，这些 <code>参数</code> 会相应地 <code>通过</code> <code>POST请求中的体信息</code> 和 <code>HttpServetRequest#getParameter(String)</code></p>
<pre><code class="lang-javascript">color=dark&amp;body=heavy
</code></pre>
<pre><code class="lang-java">public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;
 String colorParam = request.getParameter(&quot;color&quot;);
 String bodyParam = request.getParameter(&quot;body&quot;);
&#125;
</code></pre>
<blockquote>
<p>如果试图对 <code>只实现了doPost()的servlet</code> 发送 <code>GET请求</code>，则导致 <code>运行时错误</code>。</p>
<p>如果你想让 <code>某个Servlet</code> 同时支持 <code>GET</code> 和 <code>POST</code> ，则这样做：</p>
<pre><code class="lang-java">public void doPost(...) throws ...&#123;
 doGet(request, response);   
&#125;
</code></pre>
</blockquote>
<p><code>单个参数</code> 可以有 <code>多个值</code> （比如 <code>Multi-CheckBox</code>），我们需要使用 <code>getParameterValues()</code> 来获取 <code>表示多值的数组</code></p>
<pre><code class="lang-java">String[] sizes = request.getParameterValues(&quot;sizes&quot;);
String first_value = request.getParameterValues(&quot;sizes&quot;)[0];
String second_value = request.getParameterValues(&quot;sizes&quot;)[1];
</code></pre>
<p><code>HttpServletRequest#getInputStream</code> 用于用于对 <code>POST请求</code> 中包含的 <code>巨大请求体</code> 进行细致处理。</p>
<pre><code class="lang-java">String forwardsNum = Integer.parseInt(request.getHeader(&quot;Max-Forwards&quot;));
// equals to
String fowwardsNum = request.getIntHeader(&quot;Max-Forwards&quot;);
</code></pre>
<p><code>ServletRequest</code> 的 <code>getLocalPort()</code> 和 <code>getRemotePort()</code> 是相对于 <code>Servlet</code> 的</p>
<p>可以 <code>覆盖 init()</code> ，且 <code>必须覆盖</code> 1个 <code>服务方法 (doGet(), doPost() ...)</code></p>
<pre><code class="lang-mermaid">classDiagram
class Servlet &#123;
+service(ServletRequest, ServletResponse)
+init(ServletConfig)
+destroy()
+getServletConfig()
&#125;

Servlet &lt;-- GenericServlet
class GenericServlet &#123;
+init()
+getInitParameterNames()
+getInitParameter(String)
+getServletContext()
&#125;

GenericServlet &lt;-- HttpServlet
class HttpServlet&#123;
+service(HttpServletRequest, HttpServiceResponse)
+doGet(HttpServletRequest, HttpServiceResponse)
+doPost(HttpServletRequest, HttpServiceResponse)
&#125;
</code></pre>
<p><code>ServletContext#getResourceAsStream(&quot;/bookCode.jar&quot;)</code> 中，<code>斜线</code> 代表 <code>Web Application的根目录</code></p>
<p>对于 <code>ServletResponse接口</code> 的 <code>输出流</code>，可以选择 <code>字节流</code> 或者 <code>字符流</code></p>
<pre><code class="lang-java">// Byte-Stream
ServletOutputStream out = response.getOutputStream();
out.write(aByteArray);
// Character-Stream
PrintWriter out = response.getWriter();
our.println(aString)
</code></pre>
<blockquote>
<p>你应当猜到，<code>PrintWriter</code> 内部包装了 <code>ServletOutputStream</code>。</p>
<p><code>获取对象的方法名</code> = <code>去掉对象的第一个词</code></p>
</blockquote>
<p><code>重定向 (Redirect)</code> 中 <code>相对路径</code> 和 <code>绝对路径</code>：</p>
<pre><code class="lang-java">// 用户原来键入: http://www.wickedlysmart.com/myApp/cool/bar.do
response.sendRedirect(&quot;foo/stuff.html&quot;) // --&gt; http://www.wickedlysmart.com/myApp/cool/foo/stuff.html
response.sendRedirect(&quot;/foo/stuff.html&quot;) // --&gt; httpL//www.wickedlysmart.com/foo/stuff.html
</code></pre>
<blockquote>
<p>不能在 <code>写到响应之后 （即响应已提交，也就是响应已经发送给客户端，即数据已刷新到输出流）</code> 再调用 <code>sendRedirect()</code>，否则将获得 <code>IllegalStateException</code></p>
<p><code>重定向 (Redirect)</code> 让 <code>客户端</code> 来完成工作，而 <code>请求分派 (Forward)</code> 让 <code>服务端</code> 来完成工作。</p>
<p>对于 <code>本来已经存在的header</code> 而言，<code>reponse#addHeader</code> 和 <code>response#setHeader</code> 的表现 <code>完全一样</code></p>
</blockquote>
</blockquote>
<h3 id="Application-Attribute-amp-Listener"><a href="#Application-Attribute-amp-Listener" class="headerlink" title="Application: Attribute &amp; Listener"></a>Application: Attribute &amp; Listener</h3><blockquote>
<p><code>Servlet属性的作用域</code>：<code>Request</code>，<code>Session</code>，<code>Context</code></p>
<ul>
<li><code>Servlet的初始化参数</code></li>
</ul>
<p><code>每个Servlet</code> 可以有 <code>自己特有的初始化参数 (Initialization-Parameter)</code></p>
<pre><code class="lang-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;A Stupid Name&lt;/servlet-name&gt;
    &lt;servlet-class&gt;here.you.should.fill.in.full.class.name&lt;/servlet-class&gt;

    &lt;init-param&gt;
        &lt;param-name&gt;adminEmail&lt;/param-name&gt;
        &lt;param-value&gt;sakurawald@gmail.com&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>
<pre><code class="lang-java">// Inside one specific servlet
getServletConfig().getInitParameter(&quot;adminEmail&quot;);
</code></pre>
<ul>
<li><code>Context的初始化参数</code></li>
</ul>
<pre><code class="lang-xml">&lt;web-app ...&gt;
    ...

&lt;context-param&gt;
    &lt;param-name&gt;adminEmail&lt;/param-name&gt;
        &lt;param-value&gt;sakurawald@gmail.com&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">// Inside every servelet
getServletContext().getInitParameter(&quot;adminEmail&quot;);
</code></pre>
<p>不管是 <code>Servlet的初始化参数</code> （对应 <code>ServletConfig</code>） 和 <code>Context的初始化参数</code> （对应 <code>ServletContext</code>），都不提供对 <code>相应的初始化参数的 setInitParameter()</code>。</p>
<p>换句话说，<code>初始化参数</code> 是 <code>部署时常量</code>， 在运行时不可以 <code>重新设置</code>。</p>
<p>默认规定，如果没有 <code>明确地指明</code> 是 <code>servlet的初始化参数</code> 还是 <code>context的初始化参数</code>，则我们 <code>默认</code> <code>初始化参数</code> 是指 <code>servlet的初始化参数</code></p>
<p>可以用 <code>两种方法</code> 获得 <code>ServletContext</code></p>
<pre><code class="lang-java">this.getServletConfig().getServletContext().getInitParameter();
// or
this.getServletContext().getInitParameter();
</code></pre>
<ul>
<li><code>ServletContextListener</code></li>
</ul>
<pre><code class="lang-xml">&lt;web-app ...&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;com.example.MyServletContextListener&lt;/listener-class&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">public class MyServletContextListener implements ServletContextListener &#123;

    public void contextInitialized(ServletContextEvent event) &#123;

        ServletContext sc = event.getServletContext();

        String dogBreed = sc.getInitParameter(&quot;breed&quot;);
        Dog dog = new Dog(dogBreed);
        sc.setAttribute(&quot;dog&quot;, dog);   
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        // do some clean-up work.
    &#125;

&#125;
</code></pre>
<ul>
<li>Attribute versus Parameter</li>
</ul>
<p>Attribute</p>
<p>parameter</p>
<p>Type</p>
<p>Application/Context<br>Request<br>Session</p>
<p>Application/Context<br>Request<br>Servlet Initialization-Parameter</p>
<p>Getter</p>
<p>getAttribute(String name)</p>
<p>getInitParameter()</p>
<p>Setter</p>
<p>setAttribute(String name, Object value)</p>
<p>DD</p>
<p>Return Type</p>
<p>Object</p>
<p>String</p>
<p><code>对Context加锁</code> 而不是 <code>对Servlet加锁</code></p>
<pre><code class="lang-java">synchronized(getServetContext()) &#123;
 getServletContext().setAttribute(&quot;foo&quot;, 42);
 out.println(getServletContext().getAttribute(&quot;foo&quot;));
&#125;
</code></pre>
</blockquote>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p><code>request.getSession()</code> 会在 <code>之前没有存在会话</code> 时， <code>自动地</code> 创建 <code>新会话</code></p>
<pre><code class="lang-java">HttpSession session = request.getSession();
if (session.isNew()) &#123;
 ...
&#125;
</code></pre>
<blockquote>
<p>更准确地，可能 <code>getSession(false)</code> 才符合 <code>getter</code> 的 <code>语意</code>：在 <code>之前不存在会话</code> 时 应该返回 <code>null</code></p>
</blockquote>
<p>在 <code>request</code> 上调用 <code>getSession()</code> ，<code>容器</code> 会 <code>尝试使用cookie</code>，如果 <code>客户的浏览器没有启用cookie</code>，则说明 <code>客户不会加入会话</code>。</p>
<p>此时，<code>session#isNew</code> 总是返回 <code>true</code></p>
<p>对于 <code>客户禁用cookie</code> 的情况，<code>总是使用</code> <code>URL重写</code> 来 <code>追踪会话</code>。</p>
<p>可以通过 <code>response#encodeURL(String)</code> 在每个 <code>链接</code> 种添加 <code>会话ID (Session ID)</code></p>
<blockquote>
<p>如果需要在 <code>重定向</code> 的时候，仍然使用 <code>同一个会话</code> ，则调用：</p>
<pre><code class="lang-java">response.encodeRedirectURL(&quot;/BeerTest.do&quot;);
</code></pre>
<p><code>容器</code> <code>了解客户的cookie能否正常工作</code> 的 <code>唯一方式</code> 是：<code>检查客户发送的请求是否携带会话ID</code>。</p>
<p>一旦容器发现 <code>客户发送的请求</code> 没有 <code>携带会话ID</code>，则需要在 <code>返回的响应</code> 中 <code>同时尝试</code> <code>cookie</code> 和 <code>url重写</code> 这两种方法。</p>
</blockquote>
<p><code>JSESSIONID</code> 会出现在 <code>header的cookie中</code>，以及 <code>URL</code> 当中</p>
<pre><code class="lang-html">Cookie: JESSIONID=0AAB6C8DE415
// or
POST /select/selectBeerTaste.do;JESSIONID=0AAB6C8DE415
</code></pre>
<p><code>会话失效</code> 的原因： <code>会话超时</code>，<code>手动调用 session#invalidate()</code> 和 <code>应用结束 (崩溃或取消部署)</code></p>
<pre><code class="lang-xml">&lt;web-app&gt;

 &lt;session-config&gt;
     &lt;!-- 15minutes --&gt;
 &lt;session-timeout&gt;15&lt;/session-timeout&gt;
 &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">// 此处的时间单位 = 秒
session.setMaxInactiveInterval(15 * 60)
// session.setMaxInactiveInterval(0) = session.invalidate()
</code></pre>
<p>将 <code>cookie</code> 用于 <code>其他用途</code> （不仅仅是用于 <code>会话 (Session)</code>）</p>
<pre><code class="lang-java">Cookie cookie = new Cookie(&quot;username&quot;, name);
cookie.setMaxAge(15 * 60); // 如果设置 -1，则在 浏览器退出是，cookie自动删除
response.addCookie(cookie);
</code></pre>
<blockquote>
<p>有 <code>getHeader()</code> 和 <code>setHeader()</code>。但只有 <code>addCookie()</code> 和 <code>getCookies()</code>，没有 <code>getCookie()</code> 和 <code>setCookie()</code></p>
</blockquote>
</blockquote>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><blockquote>
<p>当说到 <code>表达式</code> 时，默认指 <code>脚本表达式 (Java语言表达式)</code>，而不是 <code>EL表达式</code></p>
</blockquote>
<p>Element Type</p>
<p>Example</p>
<p>Scriptlet</p>
<p>&lt;% Float one = new Float(42.5); %&gt;</p>
<p>Script Expression</p>
<p>&lt;%= pageContext.getAttribute(“foo”) %&gt;</p>
<p>EL Expression</p>
<p>email: ${applicationScope.mail}</p>
<p>Declaration</p>
<p>&lt;%! int y = 3; %&gt;</p>
<p>Instruction</p>
<p>&lt;%@ page import=”java.util.*“ %&gt;</p>
<p>Action</p>
<jsp: include page="foo.html" />

<hr>
<p>编写的 <code>JSP</code> 最终被 <code>编译</code> 为 <code>Servlet</code></p>
<pre><code class="lang-jsp">&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%
    out.println(foo.Counter.getCount()); // 使用 scriptlet + 全限定类名
     %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ page import=&quot;foo.*&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%
    out.println(Counter.getCount()); // 使用 scriptlet + page import
     %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>进一步完善，使用 <code>JSEL</code></p>
<pre><code class="lang-jsp">&lt;%@ page import=&quot;foo.*&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%= Counter.getCount() //使用 Expression
    %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>当使用 <code>表达式</code> 时，<code>语句末尾</code> 不能有 <code>分号</code> ！！！</p>
<p>因为 <code>&lt;%= Counter.getCount() &gt;</code> 等价于 <code>out.print(Counter.getCount())</code></p>
<p>在 <code>Scriptlet</code> 中 <code>定义变量</code></p>
<pre><code class="lang-jsp">&lt;% int count = 0; // 局部变量 %&gt; 
&lt;%! int count = 0; // 实例变量 %&gt;
</code></pre>
<p><code>JSP的隐式对象</code></p>
<p>API (Servlet)</p>
<p>隐式对象 (JSP)</p>
<p>JspWriter</p>
<p>out</p>
<p>HttpServletRequest</p>
<p>request</p>
<p>HttpServletResponse</p>
<p>response</p>
<p>HttpSession</p>
<p>session</p>
<p>ServletContext</p>
<p>application</p>
<p>ServletConfig</p>
<p>config</p>
<p>Throwable</p>
<p>exception</p>
<p>PageContext</p>
<p>pageContext</p>
<p>Object</p>
<p>page</p>
<blockquote>
<p><code>JspWriter</code> 不在 <code>PrintWriter</code> 的 <code>类层次体系</code> 中，但它类似于 <code>带了缓冲的PrintWriter</code></p>
</blockquote>
<p><code>JSP注释</code></p>
<pre><code class="lang-jsp">&lt;%-- your comment --%&gt;
</code></pre>
<p><code>属性的作用域</code> <code>映射关系</code></p>
<p>Scope</p>
<p>Servlet</p>
<p>JSP</p>
<p>Application</p>
<p>getServletContext().setAttribute(“foo”, barObj);</p>
<p>application.setAttribute(“foo”, barObj);</p>
<p>Request</p>
<p>request.setAttribute(“foo”, barObj);</p>
<p>request.setAttribute(“foo”, barObj);</p>
<p>Session</p>
<p>request.getSession.setAttribute(“foo”, barObj);</p>
<p>session.setAttribute(“foo”, barObj);</p>
<p>Page</p>
<p>\</p>
<p>pageContext.setAttribute(“foo”, barObj);</p>
<p>使用 <code>PAGE_CONTEXT</code> 得到 <code>属性</code></p>
<pre><code class="lang-mermaid">classDiagram
class JspContext &#123;
+getAttribute(String name)
+getAttribute(String name, int scope)
+getAttributeNames()
+findAttribuite(String name)
&#125;

JspContext &lt;-- PageContext
class PageContext&#123;
+APPLICATION_SCOPE
+PAGE_SCOPE
+REQUEST_SCOPE
+SESSION_SCOPE
+getRequest()
+getServletConfig()
+getServletContext()
+getSession()
&#125;
</code></pre>
<blockquote>
<p><code>getAttribute(String name)</code> = <code>getAttribute(String name, PAGE_SCOPE)</code></p>
<p><code>findAttribute(String name)</code> 的查找范围为：<code>PAGE_SCOPE</code> -&gt; <code>REQUEST_SCOPE</code> -&gt; <code>SESSION_SCOPE</code> -&gt; <code>APPLICATION_SCOPE</code></p>
</blockquote>
<p><code>表达式语言 (Expression Language)</code> 的形式为 <code>$&#123;something&#125;</code></p>
<pre><code class="lang-jsp">&lt;!-- Use Expression Language --&gt;
Please contact: $&#123;applicationScope.mail&#125;

&lt;!-- Use Java Language --&gt;
Please contact: &lt;%= application.getAttribute(&quot;mail&quot;) %&gt;
</code></pre>
<p>在 <code>使用EL</code>时，别忘了顺便 <code>封杀JSP中的</code> <code>脚本元素 (Script)</code></p>
<pre><code class="lang-xml">&lt;web-app&gt;
&lt;jsp-config&gt;
   &lt;jsp-property-group&gt;
       &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&gt;
       &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt;
   &lt;/jsp-property-group&gt;
&lt;/jsp-config&gt;
&lt;/web-app&gt;
</code></pre>
<p><code>动作元素</code> 分为 <code>标准动作</code> 和 <code>定制动作</code></p>
<pre><code class="lang-jsp">// 标准动作
&lt;jsp:include page=&quot;wickedFooter.jsp&quot; /&gt;
// 定制动作
&lt;c:set var=&quot;rate&quot; value=&quot;32&quot; /&gt;
</code></pre>
<blockquote>
<p>有些 <code>非标准动作</code> 仍然位于 <code>标准库</code>。</p>
</blockquote>
</blockquote>
<h3 id="Scriptless-JSP"><a href="#Scriptless-JSP" class="headerlink" title="Scriptless-JSP"></a>Scriptless-JSP</h3><pre><code class="lang-jsp">&lt;html&gt;
    &lt;body&gt;
        &lt;% foo.Person p = (foo.Person) request.getAttribute(&quot;person&quot;); %&gt;
        Person is: &lt;%= p.getName() %&gt;
    &lt;/body&gt;
&lt;/html&gt;
&lt;!-- equals to --&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;request&quot; /&gt;
        Person created by servlet: &lt;jsp:getProperty name=&quot;person&quot; property=&quot;name&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">// &lt;jsp:useBean&gt; 在 创建新Bean 时 执行体中的内容
&lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;page&quot; &gt;
&lt;jsp:setProperty name=&quot;person&quot;property=&quot;name&quot; value=&quot;Fred&quot; /&gt;
&lt;/jsp:useBean&gt;
</code></pre>
<blockquote>
<p>JavaBean只有 <code>无参构造器</code>，<code>&lt;jsp:useBean&gt;</code> 在 <code>对象</code> 不存在时，会 <code>自动地</code> 通过无参构造器创建新对象</p>
<ul>
<li><code>useBean</code> 的 <code>type</code> 和 <code>class</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- 建立多态的bean引用 --&gt;
&lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; class=&quot;foo.Employee&quot; scope=&quot;page&quot; &gt;&lt;/jsp:useBean&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- 只使用type，而没有class --&gt;
&lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt;
</code></pre>
<p>规则是这样的：<code>type</code> 表示 <code>引用类型</code>，<code>class</code> 表示 <code>对象类型 （实际类型）</code>。即 <code>type x = new class()</code></p>
<p><code>scope</code> 默认为 “page”。</p>
<ul>
<li>如果 <code>只有type</code>，则要求 <code>bean</code> 必须要 <code>已经存在</code></li>
<li><p>如果 <code>使用class</code> （不管是否有type），则 <code>class不能是抽象类</code>，且 <code>必须有无参构造函数</code></p>
</li>
<li><p>设置 <code>JavaBean</code> 的 <code>属性</code> 为 <code>相应的请求参数</code></p>
</li>
</ul>
<pre><code class="lang-jsp">&lt;!-- 使用 Java-Language Expression --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;&lt;%= request.getParameter(&quot;username&quot;)%&gt;&quot; /&gt;
&lt;!-- 直接使用 param属性 (甚至当 表单的请求参数名 与 JavaBean的性质名 相等时，可以直接省略 param) --&gt;
&lt;!-- 更进一步的，如果 所有的参数名与性质名 都相等，可以使用 param=&quot;*&quot; --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; param=&quot;userName&quot; /&gt;
</code></pre>
<ul>
<li>setProperty 的 <code>自动类型转化</code>：<code>String -&gt; Primitive</code></li>
</ul>
<pre><code class="lang-xml">&lt;!-- 下列这些会自动转化 --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;*&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; value=&quot;343&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; param=&quot;343&quot; /&gt;
&lt;!-- 如果使用脚本，则不会自动转化(此时保证类型正确是你的责任) --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; value=&quot;&lt;%= request.getParameter(&quot;empID&quot;) %&gt;&quot; /&gt;
</code></pre>
<ul>
<li>getProperty</li>
</ul>
<pre><code class="lang-jsp">&lt;html&gt;
    &lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;request&quot; /&gt;
    Dog&#39;s name is: &lt;%= ((foo.Person) request.getAttribute(&quot;person&quot;)).getDog().getName() %&gt;
&lt;!-- equals to--&gt;
    Dog&#39;s name is: $&#123;person.dog.name&#125;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>注意：<code>&lt;jsp:getProperty&gt;</code> 只能访问 <code>bean属性的性质</code>，它无法访问 <code>嵌套性质</code> （如 person.dog.name）</p>
</blockquote>
<ul>
<li><p><code>EL表达式的隐式对象</code>：映射对象 （<code>pageScope</code>，<code>requestScope</code>，<code>sessionScope</code>，<code>applicationScope</code>，<code>param</code> ，<code>paramValues</code>，<code>header</code>，<code>headerValues</code>，<code>cookie</code>，<code>initParam (上下文初始化参数，而不是Servlet初始化参数)</code>），非映射对象 （<code>pageContext</code>）。</p>
<blockquote>
<p>即 <code>pageContext隐式对象</code> 是 <code>JavaBean</code>，<code>其他隐式对象</code> 是 <code>Map</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><code>点号操作符</code> 与 <code>中括号操作符</code></li>
</ul>
<p>点号操作符</p>
<p>中括号操作符数组可被解析为数字的东西</p>
<pre><code class="lang-jsp">$&#123;musicMap.Ambient&#125; equals to $&#123;musicMap[&quot;Ambient&quot;]&#125;
$&#123;musicList[&quot;1&quot;]&#125; NOT equals to $&#123;musicList.1&#125; (后者是错误的,因为 点号操作符 严格要求 标识符的命名规范)
</code></pre>
<blockquote>
<p><code>EL保留字</code> 不能用于 <code>标识符</code>：<code>true</code>，<code>false</code>，<code>null</code>，<code>instanceof</code>，<code>empty</code></p>
</blockquote>
<p><code>requestScope</code> 不是 <code>请求对象 (Request)</code>。</p>
<p>应通过 <code>pageContext</code> 来获得 <code>request</code></p>
<pre><code class="lang-jsp">Method is: $&#123;pageContext.request.method&#125;
</code></pre>
<ul>
<li>使用 <code>作用域隐式对象</code> 来避免 <code>命名冲突</code></li>
</ul>
<pre><code class="lang-jsp">$&#123;foo.person.name&#125;
&lt;!-- and --&gt;
$&#123;requestScope[&quot;foo.person&quot;].name&#125;
</code></pre>
<p>通过 <code>明确地指定</code> <code>作用域</code>，以避免 <code>错误地将foo当作某个作用域中的属性</code></p>
<p>首先，我们知道如下事实：</p>
<ul>
<li><code>servlet的初始化参数</code> 使用 <code>&lt;init-param&gt;</code> 进行配置</li>
<li><code>context的初始化参数</code> 使用 <code>&lt;context-param&gt;</code> 进行配置</li>
</ul>
<p>但是，<code>EL的initParam隐式对象</code> 实际上对应的是 <code>上下文的参数</code> （即它使用 <code>&lt;contex-param&gt;</code> 来进行配置）</p>
<ul>
<li>TLD</li>
</ul>
<pre><code class="lang-java">package foo;
public class DiceRoller &#123;
    public static int rollDice() &#123;
        return (int) ((Math.random() * 6) + 1);
    &#125;
&#125;
</code></pre>
<pre><code class="lang-xml">&lt;taglib ...&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;uri&gt;DiceFunctions&lt;/uri&gt;
    &lt;function&gt;
    &lt;name&gt;rollIt&lt;/name&gt;
        &lt;function-class&gt;foo.DiceRoller&lt;/function-class&gt;
        &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt;
    &lt;/function&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;DiceFunctions&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        $&#123;mine:rollIt()&#125;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>EL表达式中，<code>除0得到INFINITY</code>，但 <code>模0将得到错误</code></p>
<p><code>EL表达式</code> 对 <code>null</code> 是 <code>友好处理的</code> ：<code>什么也不做</code> 胜过于 <code>抛出错误</code></p>
<p>对于 <code>unknown</code> 和 <code>null</code>，即使 <code>找不到表达式中指定名的属性/性质/键</code>，也仍然会 <code>显示页面</code>。</p>
<ul>
<li>在 <code>算数表达式</code> 中，<code>null</code> 被视为 <code>0</code></li>
<li><p>在 <code>逻辑表达式</code> 中，<code>null</code> 被视为 <code>false</code></p>
</li>
<li><p>两种 <code>页面包含机制</code></p>
</li>
</ul>
<p>&lt;%@ include file=”…”&gt; 指令</p>
<p><jsp:include page="..."> 标准动作</p>
<p>在 <code>转换</code> 时将 <code>全部的源代码</code> 进行 <code>简单的文本粘贴</code>（取得”Header.jsp”文件中的内容，并在转义之前 <code>放入</code> 到 <code>Contact.jsp</code> 中）：<br>out.write(“the content of Header.jsp”);</p>
<p>在 <code>运行时</code> 进行 <code>调用</code>：<br>org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, “Header.jsp”, out, false)</p>
<blockquote>
<p><code>被包含的页面</code> 不能 <code>修改响应状态码</code> 或 <code>设置首部</code>。如果尝试这么做，不会 <code>得到错误</code>，而仅仅是 <code>结果达不到预期的目标</code></p>
<p>在 <code>可重用组件</code> 中不应该编写 <code>HTMl</code> 或 <code>BODY</code> 标签，以避免 <code>标签嵌套</code></p>
</blockquote>
<p><code>&lt;jsp:forward&gt;</code> 的 响应缓存区 会在 <code>转发</code> 之前 <code>被清空</code>：故 <code>不要先刷新输出</code> 然后再 <code>转发</code></p>
<blockquote>
<p>如果在 <code>转发</code> 之前 <code>已经刷新了响应缓冲区 （提交了响应）</code>，则会将 <code>刷新输出的内容</code> 发送给 <code>客户</code>，并且不会再 <code>发生转发</code>。</p>
<p>原页面的 <code>剩余部分</code> 不会得到处理。</p>
</blockquote>
<p><code>&lt;jsp:param&gt;</code> 只能用于 <code>&lt;jsp:include&gt;</code> 和 <code>&lt;jsp:forward&gt;</code> 当中。</p>
</blockquote>
<h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p><code>JSTL</code> = <code>JSP Standard Tag Library</code></p>
<blockquote>
<ul>
<li><code>&lt;c:out&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- escapeXml默认为false --&gt;
&lt;c:out value=&quot;pageContext.currentTip&quot; escapeXml=&quot;true&quot; /&gt;
&lt;!-- 设置 输出的默认值 --&gt;
&lt;c:out value=&quot;$&#123;user&#125;&quot; default=&quot;guest&quot;&gt;
</code></pre>
<ul>
<li><code>&lt;c:forEach&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:forEach var=&quot;movie&quot; items=&quot;movieList&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;$&#123;movie&#125;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre>
<blockquote>
<p>可选属性 <code>varStatus</code> 可以获得 <code>循环计次</code>：1..n</p>
</blockquote>
<ul>
<li><code>&lt;c:if&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:if test=&quot;$&#123;userType==&#39;member&#39;&quot;&gt;
    &lt;jsp:include page=&quot;inputComments.jsp&quot; /&gt;
&lt;/c:if&gt;
</code></pre>
<blockquote>
<p>虽然有 <code>if标签</code>，但没有 <code>else标签</code>。如果需要制定 <code>默认的分支</code>，请使用 <code>choose标签</code></p>
</blockquote>
<ul>
<li><code>&lt;c: choose&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:choose&gt;
    &lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
&lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
&lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
    &lt;c:otherwise&gt;...&lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre>
<ul>
<li><code>&lt;c:set&gt;</code></li>
</ul>
<p>属性变量的的值</p>
<pre><code class="lang-jsp">&lt;!-- 无体版本 --&gt;
&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; value=&quot;Cowboy&quot; /&gt;

&lt;!-- 有体版本： 计算体的内容，并将结果作为 value的值（如果计算结果为null，则变量会被删除！） --&gt;
&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot;&gt;
    Sheriff, Bartender, Cowgirl
&lt;/c:set&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- 注意：此处target必须传入 对象的引用本身，而不能传递 对象的ID String--&gt;
&lt;c:set target=&quot;$&#123;PetMap&#125;&quot; property=&quot;dogName&quot; value=&quot;Clover&quot; /&gt;
</code></pre>
<blockquote>
<p>对于 <code>&lt;c:out&gt;</code> ，如果没有指定 <code>scope</code>，则默认 <code>只会搜索 pageScope</code></p>
</blockquote>
<ul>
<li><code>&lt;c:remove&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:set var=&quot;userStatus&quot; scope=&quot;request&quot; value=&quot;Brilliant&quot; /&gt;
before userStatus: $&#123;userStatus&#125; &lt;br&gt;
&lt;!-- scope是可选的，默认会指定为 所有的作用域 --&gt;
&lt;c:remove var=&quot;userStatus&quot; scope=&quot;request&quot; /&gt;
&lt;!-- 此处会打印出 空字符串 （因为EL是null友好的） --&gt;
after userStatus: $&#123;userStatus&#125; &lt;br&gt;
</code></pre>
<ul>
<li><code>&lt;c:import&gt;</code></li>
</ul>
<p>在 <code>请求</code> 时，将 <code>URL指定的内容</code> 粘贴到 <code>当前页面</code>。（类似于 <code>&lt;jsp:include&gt; 标准动作</code>，只不过 <code>&lt;c:import&gt;</code> 可以 <code>通过URL来引用app外部的资源</code> ）</p>
<blockquote>
<p>可以搭配 <code>&lt;c:param&gt;</code> 来使用。</p>
<pre><code class="lang-jsp">&lt;c:import url=&quot;Header.jsp&quot;&gt;
 &lt;c:param name=&quot;subTitle&quot; value=&quot;We take the sting out of SOAP.&quot; /&gt;
&lt;/c:import&gt;
</code></pre>
</blockquote>
<ul>
<li><code>&lt;c:url&gt;</code></li>
</ul>
<pre><code class="lang-java">out.println(&quot;&lt;a href=\&quot;&quot; + response.encodeURL(&quot;/BeerTest.do&quot;) + &quot;\&quot;&gt;Click Here&lt;/a&gt;&quot;);
</code></pre>
<pre><code class="lang-jsp">&lt;a href=&quot;&lt;c:url value=&#39;/inputComments.jsp&#39; /&gt;&quot;&gt;Click Here&lt;/a&gt;
</code></pre>
<blockquote>
<p>注意，<code>&lt;c:url&gt;</code> 仅仅进行 <code>URL重写</code>，但不包含 <code>URL编码</code>。</p>
<p>若需要 <code>URL编码</code>，则使用 <code>&lt;c:param&gt;</code> 来 <code>显式地指出所有的参数列表</code></p>
<pre><code class="lang-jsp">&lt;c:url value=&quot;/inputComments.jsp&quot; var=&quot;inputURL&quot;&gt;
 &lt;c:param name=&quot;firstName&quot; value=&quot;$&#123;first&#125;&quot; /&gt;
 &lt;c:param name=&quot;lastName&quot; value=&quot;$&#123;last&#125;&quot; /&gt;
&lt;/c:url&gt;
</code></pre>
</blockquote>
<ul>
<li>建立 <code>错误页面</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- errorPage.jsp --&gt;
&lt;%@ page isErrorPage=&quot;true&quot; %&gt;
&lt;html&gt;
You caused a $&#123;pageContext.exception&#125; on the server.
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- badPage.jsp --&gt;
&lt;%@ page errorPage=&quot;errorPage.jsp&quot; %&gt;
&lt;html&gt;
    About to be bad...
    &lt;% int x = 10 / 0; %&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>此外，也可以通过 <code>DD文件</code> 来指定 <code>错误页面</code> 的 <code>匹配规则</code></p>
<pre><code class="lang-xml">&lt;error-page&gt;
 &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt;
 &lt;location&gt;/aritimeticErrorPage.jsp&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
</blockquote>
<ul>
<li><code>&lt;c:catch&gt;</code></li>
</ul>
<p>该标签会 <code>同时</code> 作为 <code>try</code> 和 <code>catch</code>，实际上，它的语义和 <code>catch</code> 不同。（它表现得更快 <code>try</code> 块）</p>
<p>一旦 <code>异常</code> 发生，<code>控制流</code> 会 <code>直接跳转</code> 到 <code>&lt;c:catch&gt;标记体的末尾</code>。即：一旦 <code>&lt;c:catch&gt;</code> 中出现异常，则 <code>体中的剩余部分</code> 不会继续运行。</p>
<ul>
<li>自定义 <code>Tag Library</code></li>
</ul>
<pre><code class="lang-xml">&lt;!-- 标记库描述文件 (Tag Library Descriptor, TLD) --&gt;
&lt;!-- 
容器在4个位置中查找TLD：
1. WEB-INF目录
2. WEB-INF的一个子目录
3. WEB-INF/lib的jar文件中的META-INF目录
4. WEB-INF/lib的jar文件中的META-INF目录的一个子目录
--&gt;
&lt;xml ...&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;short-name&gt;RandomTags&lt;/short-name&gt;

    &lt;!-- 自定义EL函数 --&gt;
    &lt;function&gt;
        &lt;name&gt;rollIt&lt;/name&gt;
        &lt;function-class&gt;foo.DiceRoller&lt;/function-class&gt;
        &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt;
    &lt;/function&gt;

    &lt;!-- 自定义标签 --&gt;

    &lt;!-- uri只不过是一个名称，而不是一个必须存在的位置 --&gt;
    &lt;uri&gt;randomThings&lt;/uri&gt;
    &lt;tag&gt;
        &lt;description&gt;random advice&lt;/description&gt;
        &lt;name&gt;advice&lt;/name&gt;
        &lt;tag-class&gt;foo.AdvisorTagHandler&lt;/tag-class&gt;
        &lt;!-- 即使这里声明位empty，仍然可以通过 &lt;jsp:attribute&gt; 在标记的体中存放属性！ --&gt;
        &lt;!-- 对于声明为empty，仍然可以通过 开始标记 和 结束标记 之间没有内容 的方式来调用 --&gt;
        &lt;!-- body-content可以设置为：empty, scriptless, tagdependent, JSP --&gt;
&lt;body-content&gt;empty&lt;/body-content&gt;

        &lt;!-- 对于定制标记，并不在TLD中书写attribute，而是转移到 标记文件 中书写属性。--&gt;
        &lt;attribute&gt;
        &lt;name&gt;user&lt;/name&gt;
            &lt;!-- 必须? --&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;!-- 允许是运行时表达式量? 默认false --&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
    &lt;/tag&gt;

&lt;/xml&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;html&gt; 
    &lt;body&gt;
        &lt;!-- prefix只是一个方便引用的前缀，你可以任意取名。
但注意不要取保留的前缀名：jsp, jspx, java, javax, servlet, sun, sunw
--&gt;
        &lt;!-- 对于定制标记，使用tagdir而不是uri --&gt;
    &lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;randomThings&quot; %&gt;
        Advisor Page&lt;br&gt; &lt;mine:advice user=&quot;$&#123;userName&#125;&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-java">public class AdvisorTagHandler extends SimpleTagSupport &#123;

    private String user;

    public void doTag() throws JspException, IOException &#123;
        getJspContext().getOut().write(&quot;hello &quot; + user + &quot;: &quot; + getAdvice() );
    &#125;

    public void setUser(String user) &#123;
        this.user = user;
    &#125;

    String getAdvice() &#123;
        return &quot;do nothing&quot;;
    &#125;

&#125;
</code></pre>
<p><code>标记文件 (*.tag)</code> 最后仍然需要作为 <code>JSP的一部分</code>，它可以使用 <code>JSP隐式对象</code> 和 <code>EL隐式对象</code>。</p>
<p>但不能使用 <code>ServletContext</code>，取而代之的是使用 <code>JspContext</code>。</p>
</blockquote>
<h3 id="My-Custom-Tag"><a href="#My-Custom-Tag" class="headerlink" title="My Custom Tag"></a>My Custom Tag</h3><h4 id="Custom-Tag-File"><a href="#Custom-Tag-File" class="headerlink" title="Custom Tag File"></a>Custom Tag File</h4><pre><code class="lang-xml">&lt;!-- TLD --&gt;
&lt;taglib&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;uri&gt;myTagLibrary&lt;/uri&gt;
    &lt;tag-file&gt;
    &lt;name&gt;Header&lt;/name&gt;
        &lt;path&gt;/META-INF/tags/Header.tag&lt;/path&gt;
    &lt;/tag-file&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- Custom Tag File (定制标记文件) --&gt;
&lt;%@ attribute name=&quot;subTitle&quot; required=&quot;true&quot; rtexprvalue=&quot;true&quot; %&gt;
&lt;!-- body-content可取值为 scriptless(默认值), empty, tagdependent(直接当作纯文本处理)--&gt;
&lt;%@ tag body-content=&quot;tagdepent&quot; %&gt;
&lt;strong&gt;$&#123;subTitle&#125;&lt;/strong&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- Usage --&gt;
&lt;%@ taglib prefix=&quot;myTags&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
    &lt;myTags:Header subTitle=&quot;We take the String out of SOAP&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="Custom-Tag-Handler"><a href="#Custom-Tag-Handler" class="headerlink" title="Custom Tag Handler"></a>Custom Tag Handler</h4><pre><code class="lang-xml">&lt;!-- TLD --&gt;
&lt;taglib ..&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;uri&gt;simpleTags&lt;/uri&gt;

    &lt;tag&gt;
    &lt;description&gt;worst use of a custom tag&lt;/description&gt;
        &lt;name&gt;simple1&lt;/name&gt;
        &lt;tag-class&gt;foo.SimpleTagTest1&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-java">/* Tag Handler */
// 每个SimpleTagHandler不会重用，每个实例只会被调用1次
public class SimpleTagTest1 extends SimpleTagSupport &#123;
 public void doTag() throws JspException, IOException &#123;
     // 使用 getJspBody().invoke(null) 来处理标记的体 (如果有)，并将结果打印到响应
 // 使用 throw new SkipPageException() 来停止处理后续的页面。（对于嵌套的页面，该异常只会影响 直接抛出该异常的页面，外围页面均不受异常的影响）      // setJspBody() 只会在 实际调用标记 时 确确实实 存在体 才会被执行。（不管标记的声明是否要求 有体）

     ...
 &#125;   
&#125;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ taglib prefix=&quot;myTags&quot; uri=&quot;simpleTags&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
    &lt;myTags:simple1 /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>这里仅列出 <code>SimpleTagSupport</code>，不考虑 <code>TagSupport</code></p>
</blockquote>
<h3 id="Deploy-Application"><a href="#Deploy-Application" class="headerlink" title="Deploy Application"></a>Deploy Application</h3><blockquote>
<p>OUT-OF-DATE</p>
</blockquote>
<h3 id="Application-Security"><a href="#Application-Security" class="headerlink" title="Application Security"></a>Application Security</h3><p><code>Servlet安全</code> 可以划分为： <code>认证</code>，<code>授权</code>，<code>机密性</code>， <code>数据完整性</code></p>
<pre><code class="lang-jsp">&lt;web-app&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
            &lt;!-- 至少指定1个url-pattern --&gt;
        &lt;url-pattern&gt;/Beer/AddRecipe/*&lt;/url-pattern&gt;
            &lt;url-pattern&gt;/Beer/ReviewRecipe/*&lt;/url-pattern&gt;
            &lt;!-- 如果没有指定任何http方法，则所有的方法都是受约束的。（一旦指定任何http方法，则只有这部分方法受约束） --&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;

        &lt;auth-constraint&gt;
            &lt;!-- 通过role-name对用户进行许可 --&gt;
            &lt;!-- &lt;role-name&gt;*&lt;/role-name&gt; 表示所有用户都被许可--&gt;
            &lt;!-- 如果两个不同的非空&lt;auto-constraint&gt;元素应用于 同一个受限资源，则两个元素中的所有角色的并集 都可以访问该首先资源--&gt;
            &lt;role-name&gt;Admin&lt;/role-name&gt;
            &lt;role-name&gt;Member&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;
</code></pre>
<h3 id="Filter-amp-Wrapper"><a href="#Filter-amp-Wrapper" class="headerlink" title="Filter &amp; Wrapper"></a>Filter &amp; Wrapper</h3><p>只有1个 <code>过滤器接口：Filter</code>，当谈到 <code>请求过滤器</code> 和 <code>响应过滤器</code> 时，只是在说 <code>如何使用</code> 过滤器，对于容器来说，只有 <code>1种过滤器</code></p>
<pre><code class="lang-java">public class BeerRequestFilter implements Filter &#123;

    private FilterConfig fc;

    public void init(FilterConfig config) throws ServletException &#123;
this.fc=config;
    &#125;

    public void doFilter(ServletRequest req, ServletResponse, resp, FilterChain chain) throws ServletException, IOException &#123;
        // do something.
        chain.doFilter(req, resp);
    &#125;

    public void destroy() &#123;
        // do some clean-up
    &#125;

&#125;
</code></pre>
<pre><code class="lang-xml">&lt;filter&gt;
    &lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;filtet-class&gt;com.example.web.BeerRequestFilter&lt;/filtet-class&gt;
    &lt;init-param&gt;
    &lt;param-name&gt;LogFileName&lt;/param-name&gt;
        &lt;param-value&gt;UserLog.txt&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;!-- or --&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;servlet-name&gt;AdviceServlet&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;
</code></pre>
<h3 id="Pattern-amp-struts"><a href="#Pattern-amp-struts" class="headerlink" title="Pattern &amp; struts"></a>Pattern &amp; struts</h3><blockquote>
<p>OUT-OF-DATE</p>
</blockquote>
<p>实际上，这篇文章几乎都是错误。</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
</search>

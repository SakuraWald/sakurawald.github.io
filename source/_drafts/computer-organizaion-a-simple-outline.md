---
title: Computer Organizaion - A simple outline
tags: []
id: '58132'
categories:
  - - uncategorized
date: 2022-08-15 10:40:00
---

# Computer Organization Outline

## Short-Hand

*   固件功能类似软件，形态类似硬件。
*   软件与硬件具有逻辑功能的等价性。
*   计算机系统层级结构中，微程序属于硬件级
*   完整的计算机系统通常包括：硬件系统与软件系统
*   CPU地址线数量 与 内存容量 密切相关
*   冯诺依曼计算机的核心思想是 存储程序和程序控制
*   计算机中表示地址时使用 无符号数
*   当 -1 < x < 0 时，\[x\]补 = 2+x
*   字长8位的某二进制补码整数为 11011010 ，则该数的标准移码为 01011010
*   对于IEEE754格式的浮点数：阶码用 `移码` 表示，尾数用 `原码` 表示。
*   同一个数的补码和移码，其数值部分相同，而符号部分相反。
*   相同位数的补码和移码，具有相同的 数据表示范围
*   一般用移码表示浮点数的阶码，用补码表示定点数。
*   执行算数右移指令的过程：操作数的符号位不变，各位顺次右移1次，符号位拷贝到最高位。
*   原码除法：操作数取绝对值相除，符号位单独处理。
*   在定点二进制运算器中，减法运算一般通过：补码运算的二进制加法器 来实现
*   若浮点数用补码表示，则判断运算结果是否为规格化数的方法：数符与尾数小数点后第一位 是否相异
*   在小数除法中，为了避免溢出，要求被除数的绝对值 小于 除数的绝对值。
*   并行加法器中虽然不存在进位的串行传递，但高位的进位依然依赖于数据的低位。
*   运算器中通常有一个状态标记寄存器，为计算机提供判断条件，以实现程序转移。
*   在计算机中，对于正数，其三种机器数右移后符号位均不变，但若右移时最低数位丢1，则可能导致 影响运算精度
*   CPU可以直接访问主存
*   计算机字长为32位，主存容量为128MB，按字编址，其寻址范围为 0~32M-1
*   字位结构为256K × 4位的SRAM存储器芯片，其地址引脚和数据引脚之和为8+10+4=22 根
*   某 `存储容量` 为 `64K × 16的SRAM存储器芯片`，该芯片的地址线为16根，数据线为16根。
*   计算机系统中的存储器系统：Cache，主存储器，外存储器
*   动态存储器的刷新以行为单位进行。
*   若某计算机字长为32位，则下列地址属性属于按双字长边界对齐的是：存储器地址线的低3位全为0
*   功能部件MMu将虚拟地址转化为物理地址。
*   采用虚拟存储器的主要目的是：扩大 `主存储器` 的存储空间，且能进行自动管理和调度。
*   对于 `虚拟存储器`，程序执行过程中实现 `虚拟地址` 转化为 `物理地址` 的部件是：`操作系统` 和 `MMU`
*   相联存储器是按照 `内容` 进行寻址的存储器。
*   `Cache行` 大小 = `主存的内存块` 大小
*   `哈佛体系结构 （分离Cache）` ：将`Cache` 分为 `指令Cache` 和 `数据Cache`
*   `Cache` 采用 `直接映射方式`，无需使用 `Cache块替换算法`
*   `浮点数` 的 `尾数` 采用 `补码` 表示，则 `符号位` 与 `最高数值位` 不同即为 `规格化的浮点数`。
*   指令采用跳跃寻址方式的主要作用是：实现程序的有条件，无条件转移
*   `间接寻址` 有利于缩短指令 `地址码` 长度。
*   二地址指令的运算结果，通常存放在其中一个地址码字段所指向的地址。
*   冯诺依曼体系结构 `不包含Cache`。
*   冯诺依曼体系结构中的 `指令` 和 `数据` 均以 二进制形式 存储在 `存储器` 中，CPU通过该 `指令和数据的访问时间不同` 来 `区分`。
*   `指令寄存器 （存放取到的单条指令）` 的位数 取决于 `机器字长`
*   PC的位数 与 `主存地址寄存器 MAR` 的位数相同
*   在控制器的控制方式中，机器周期内的时钟周期个数可以不同，该种方式称为 `异步控制`
*   控制器的功能：操作控制，指令的顺序控制，异常控制。
*   若某 `互斥命令组` 由 `4个微命令` 组成，则 `微指令寄存器` 中相应的字段的位数 至少需要 3位（2位 + 额外的1位用于说明该互斥命令组是否有效）。
*   `一条机器指令` 的功能通过执行 `一个微程序` 来实现。
*   从信息流的传送效率来看，`单总线系统` 的工作效率是最低的。
*   `系统总线地址` 的功能是：`指定主存` 和 `IO设备接口电路的地址`
*   IEEE1394的高速特性适合于新型高速硬盘和多媒体数据传送，它的数据传输率最高可以达到 400Mb/s
*   在 `单总线结构计算机` 中访问 `主存与外围设备` 时，`异步控制` 常用于主要控制方式
*   当采用 `统一编址法` 对设备进行编址的情况下,不需要专门的IO指令
*   8086 CPU 对 IO接口的编址 采用:IO端口独立编址
*   中断向量地址 是 `中断服务例行程序入口地址` 的 `指示器`
*   `通道` 对 `CPU` 的请求形式是 `中断`
*   某计算机 `字长` 为32位,下列 `地址属性` 中属于按 `双字长边界对齐` 的是: 存储器地址线的 `低3位` 全部为 0
*   采用 `最优替换算法`, 则 `Cache的命中率` 可以达到 100%
*   `读操作` `不需要` 考虑 `Cache与主存的一致性问题`
*   假定主存 `按字节编址`,cache共有 `64行`,采用 `4路组相联映射方式`, `主存块` 的大小为 32字节,所有编号都从0开始.问 `主存` `第3000号单元` 所在的主存块对应的cache组号: (3000/32) \\mod (64/4) = 13
*   某计算机系统中,Cache容量为512KB, 主存容量为 256MB,则 `Cache-主存层次的等效容量` 为 256MB
*   `程序` 必须放在 `主存` 或 `CACHE` 才能够被 `CPU` 进行访问。
*   访问 256KB 的存储空间，需要的 `地址线` 最少为 8 + 10 = 18 根 （1KB = 2^{10} bit）
*   采用 `PC相对寻址` 的 `指令` 的 `当前地址` 在计算基础值时，需要额外加上 `当前指令的长度`，然后加上 `当前指令的地址码字段所给出的内容` 作为 `偏移量`。
*   设 A=123456H，计算机 `内存地址由低到高` ，则采用 `小端序` 的情况下，`最高地址` 存放的内容是：12

## Chapter 3: Compute Approaches and ALU

### The Conversion among Sign-Magnitude, Ones' Complement and Two's Complement

(number)\_2

\\c{hotpink}{Sign-Magnitude}

Ones' Complement

Two's Complement

\\g{0}

\\g{\\vec{x} = \[0.0\\cdots0\]}

\\g{\\vec{x} = \[0.0\\cdots0\]}

\\g{\\vec{x} = \[0.0\\cdots0\]}

\\r{-}0

\\vec{x} = \[\\r{1}.\\b{0\\cdots0}\]

\\vec{x} = \[1.\\b{1\\cdots 1}\]

\\vec{x} = \[0.0\\cdots0\]

\\g{0.10101}

\\g{\\a{&\\vec{x}= \[0.10101\]}}

\\g{\\a{&\\vec{x}= \[0.10101\]}}

\\g{\\a{&\\vec{x}= \[0.10101\]}}

\\r{-}0.10101

\\a{&\\vec{x}=\[\\r{1}.\\b{10101}\] }

\\a{&\\vec{x}=\[1.\\b{01010}\] }

\\a{&\\vec{x}=\[1.01011\] }

\\r-0.11111

\\a{&\\vec{x}=\[\\r1.\\b{11111\]} }

\\a{&\\vec{x}=\[0.\\b{00000}\] }

\\a{&\\vec{x}=\[0.00001\] }

\\r{-}0.11111

\\a{&\\vec{x}=\[\\r{1}.\\b{11111}\] }

\\a{&\\vec{x}=\[1.\\b{00000}\] }

\\a{&\\vec{x}=\[1.00001\] }

\\r{-}0.10000

\\a{&\\vec{x}=\[\\r{1}.\\b{10000}\] }

\\a{&\\vec{x}=\[1.\\b{01111}\] }

\\a{&\\vec{x}=\[1.10000\] }

\\g{0.10000}

\\g{\\a{&\\vec{x}=\[0.10000\] }}

\\g{\\a{&\\vec{x}=\[0.10000\] }}

\\g{\\a{&\\vec{x}=\[0.10000\] }}

### Fixed-Point Number: Addition & Subtraction

#### Two's Complement Addition

* * *

#### Two's Complement Subtraction

* * *

### Overflow Detection

#### Two's Complement

#### Modified Complement

* * *

### Basic Logic-Gate

![image-20220613140616912](https://s2.loli.net/2022/06/13/3bjEgqcaRrk4i7l.png)

### Float-Point Number: Addition Subtraction

#### Addition

基本步骤：

*   零操作数检查：若其中1个操作数为0，则只需要对符号位做处理。
    
*   对阶：移动 `阶码小的浮点数的尾数`，使得 `两个浮点数的阶码` 相同。
    
    *   求 `阶差`：\\Delta E = \[E\_X\]\_T + \[-E\_Y\]\_T
    *   `右移` `阶码小的浮点数的尾数` \\Delta E 位
*   计算尾数
    
*   `规格化` `结果浮点数`
    
    *   当 `尾数` 的结果为 `0.00` 或 `11.1` 时，`左移尾数 （每次阶码减一）` 直到 `尾数` 变为 `00.1` 或 `11.0`
    *   当 `尾数` 的结果为 `01.` 或 `10.` 时，`右移尾数 （每次阶码加一）` 直到 `尾数` 变为 `00.1` 或 `11.0`
*   舍入：在进行 `右规格化` 时，可能会丢失 `一些低位的数值`。
    
    *   `0舍1入策略`：如果 `向右移出` 的是 `1`，则在 `最低位 + 1`。
    *   `恒置0策略`：只要 `数字位1` 被 `移出` ，则将 `最低位 恒置1`
*   溢出处理：通过判断 `阶码是否溢出` 来判断 `浮点数是否溢出`
    
    *   `阶码上溢`：阶码的符号位为 `01`
    *   `阶码下溢`：阶码的符号位为 `10`

* * *

#### Subtraction

...

> 关于 `数值表示` 的相关链接：
> 
> [https://www.sakurawald.com/?p=33736](https://www.sakurawald.com/?p=33736)
> 
> [https://www.sakurawald.com/?p=33679](https://www.sakurawald.com/?p=33679)

## Chapter 4: Memory Hierarchy

### Memory Indicators

存储器的技术指标：

*   `存储容量`：`存储器` 所能存储的 `二进制的位数`
    
*   `速度`
    
    *   `存取时间 （存储器访问时间）`：从 `启动` `存取操作` 到 `完成` 该操作 `所经历的时间`
    *   `存储周期 （读写周期）`：对 `存储器` 进行 `连续两次存取` 所需的 `最短时间间隔`
    *   `存储器带宽 （数据传输率）`：`单位时间` 内 `存储器所能存取的信息位数`。存储器总线宽度存储周期存储器总线宽度 / 存储周期）

### SRAM & DRAM

种类

SRAM

DRAM

访问速度

快

慢

刷新电路

不需要

需要

使用场合

告诉缓存

系统微机内存

价格

高

低

### Memory Expansion

> *   双译码结构
> 
> 即将 `来自CPU的地址线` 分为 `行选择线` 和 `列选择线`，分别送到 `2个译码器` 中进行 `译码`，以便 `大大减少` `译码输出线` 的数量。
> 
> 如：以 `12位地址` 为例
> 
> *   `单译码结构`：`译码输出` 的 `状态线` 为 2^{12} = 4096 根
> *   `双译码结构`：`X译码输出` 和 `Y译码输出` 的 `状态线` 均为 2^6 = 64 根，总共需要128 根。
> 
> 总之，对于 `小容量的存储器`，可以采用 `单译码结构`。但对于 `大容量存储器` 则没有 `选择的余地`。

> `存储字长`：`主存` 的 `1个存储单元` 所包含的 `二进制位`
> 
> `数据字长 （计算机字长）`：`计算机` `1次所能处理的二进制位`
> 
> > 目前大部分的计算机的 `主存` 采用 `按字节编址`。
> > 
> > 常见的 `计算机字长` 为 `16位字长 （2字节）`，`32位字长 （4字节）`，`64位字长（8字节）`

> `大端序存储方式 (Big-Endian)`：`MSB (Most-Siginificant-Bit)` 作为 `字地址`
> 
> `小端序存储方式 (Little-Endian)`：`LSB` 作为 `字地址`
> 
> > 68000采用大端，Intel采用小端，ARM两者都支持。

> `存储器拓展`
> 
> *   `字拓展`：`容量` 不足时
>     
>     *   所需存储器芯片的数量主存容量存储体容量存储器芯片容量地址线数存储器地址线数所需存储器芯片的数量 = 主存容量 / 存储体容量(存储器芯片容量) = 2^{CPU地址线数- 存储器地址线数}
>         
>     *   片选产生方法
>         
>         *   线选法
>         *   全译码法
>         *   部分译码法
> *   `位拓展`：`数据位` 不足时
>     
>     *   所需存储器芯片的数量数据线位数存储体数据位所需存储器芯片的数量 = 数据线位数 / 存储体数据位
> *   `字位同时拓展`
>     
> 
> > `字拓展` 类似于 `伸缩因子 (Scale Factor)`，`位拓展` 类似于 `并行读写`
> 
> > e.g. 某计算机的主存地址空间中，从地址 0000\_{16} 到 3FFF\_{16} 为 ROM存储区域，从 4000\_{16} 到 5FFF\_{16} 为 保留地址区域，暂时不使用。从 6000\_{16} 到 FFFF\_{16} 为RAM地址区域。RAM的控制信号为 CS# 和 WE#，CP
> > 
> > 的地址线为 A\_{15} \\cdots A\_0，数据线为 D\_7 \\cdots D\_0
> > 
> > 控制信号有 R/W# 和 访存请求MREQ#
> > 
> > (1) 若ROM和RAM的 `存储器芯片` 均采用 `8K × 1 存储器芯片`，试画出存储器与CPU的连接图。
> > 
> > > 分析 `地址空间分布`
> > > 
> > > 0000H ~ 3FFFH (16K)：ROM
> > > 
> > > 4000H ~ 5FFFH (8K)：保留区
> > > 
> > > 6000H ~ FFFFH (40K)：RAM
> > > 
> > > 故 ROM需要的存储器芯片数量 = \\frac{16K \* 8}{8K \* 1} = 16 片
> > > 
> > > 故 RAM需要的存储器芯片数量 = \\frac{40K \* 8}{8K \* 1} = 40 片
> > > 
> > > RAM和ROM 均需要 `字位同时拓展`
> > > 
> > > `字拓展` 时 `译码输入线的数量` = 16 - \\log{8K} = 16 - 13 = 3 根
> > > 
> > > 故 `译码器的输出线` 有 2^3 = 8 根，每根线选中 64K / 8 = 8K 的 `存储单元`，即 `3-8译码`。总共选中 64K 个 `存储单元`
> > > 
> > > ![image-20220613165628307](https://s2.loli.net/2022/06/13/YhDUx75P41pdKTf.png)
> > 
> > (2) 如果 ROM 采用 `8K × 8 存储器芯片`，而 RAM 采用 `4K × 8 存储器芯片`，试画出存储器与CPU的连接图。
> > 
> > > `地址空间分布` 分析相同。但 ROM 和 RAM 所需的 `存储器芯片` 数量有所变化。
> > > 
> > > ROM需要的存储器芯片的数量 = \\frac{16K \* 8}{8K \* 8} = 2 片
> > > 
> > > RAM需要的存储器芯片的数量 = \\frac{40K \* 8}{4K \* 8} = 10 片
> > > 
> > > ROM和RAM均只需要进行 `字拓展`
> > > 
> > > > 对于 `译码输入` 的选择？
> > > > 
> > > > *   以 `大容量存储器芯片` （8K）为目标
> > > >     
> > > >     `字拓展` 时 `译码输入线的数量` = 16 - \\log{8K} = 16 - 13 = 3 根
> > > >     
> > > >     共产生 2^3 = 8 根 `译码输出线`，每根 `选择的内存空间范围` 为 64K / 8 = 8K
> > > >     
> > > >     ![image-20220613171936954](https://s2.loli.net/2022/06/13/g6izADBVkIeQLSC.png)
> > > >     
> > > > *   以 `小容量存储器芯片` （4K）为目标
> > > >     
> > > >     `字拓展` 时 `译码输入线的数量` = 16 - \\log{4K} = 16 - 12 = 4 根
> > > >     
> > > >     共产生 2^4=16 根 `译码输出线`，每根 `选择的内存空间范围` 为 64K / 16 = 4K
> > > >     
> > > >     为了 `留出8K的保留区`，必须留出 `2根片选信号`
> > > >     
> > > >     ![image-20220613171951554](https://s2.loli.net/2022/06/13/BCqf3z1opSR6LcT.png)
> > > >     
> > 
> > (3) 如果 ROM 采用 `16 × 8 存储器芯片`， RAM 采用 `8K × 8 存储器芯片`，试画出存储器与CPU的连接图。
> > 
> > > `地址空间分布` 同前。
> > > 
> > > ROM所需要的存储器芯片的数量 = \\frac{16K \* 8}{16K \* 8} = 1 片
> > > 
> > > RAM所需要的存储器芯片的数量 = \\frac{40K \* 8}{8K \* 8} = 5 片
> > > 
> > > 进行 `字拓展` 的 `片选译码` 可以选择两种方式
> > > 
> > > > *   以 `16K存储器芯片` 为目标，每个 `片选译码线` 选择 `16K的存储空间`
> > > >     
> > > >     ![image-20220613181522250](https://s2.loli.net/2022/06/13/nUBElbMJQR2fv7a.png)
> > > >     
> > > > *   以 `8K存储器芯片` 为目标，每个 `片选译码线` 选择 `8K的存储空间`
> > > >     
> > > >     ![image-20220613181533451](/home/teeth/.config/Typora/typora-user-images/image-20220613181533451.png)
> > > >     

### Cache

`信息交换的基本单位`：

*   `CPU` 与 `Cache` 之间 \\to `字 (Word)`
*   `Cache` 与 `主存` 之间 \\to `块 (Block)`
*   `主存` 与 `辅存` 之间 \\to `段 (Segment)` ，`页 (Page)`，段页

> 1个 `Cache块` 包含 `若干个字`

### Virtual Memory

`虚拟存储器` 的类别：

*   `段式虚拟存储器`：按 `程序的自然段` 作为 `主存和辅存之间` 的 `信息交换基本单位`。使用 `段表` 来登记 `段` 的 `调入情况`，`段表` 是 `主存` 的一部分。
    
    *   优点：保护用户程序的相对独立性
    *   缺点：管理复杂，容易造成主存的碎片
*   `页式虚拟存储器`：将 `程序` 分成 `固定长度的页`，作为 `主存和辅存之间` 的 `信息交换基本单位`。使用 `页表` 来登记 `页` 的 `调入情况`，`页表` 是 `主存` 的一部分。
    
    *   优点：管理方便，主存的空间浪费少
    *   缺点：破坏了程序的相对独立性
*   `段页式虚拟存储器`：先对 `程序` 分为 `程序段`，然后将 `程序段` 分为 `固定长度的页`，作为 `主存和辅存之间` 的 `信息交换基本单位`。但 `共享和保护` 按照 `程序段` 进行。同时使用 `段表` 和 `页表` 来登记 `段` 和 `页` 的 `调入情况`
    
    *   优点：管理方便，主存空间浪费少，保持程序自身的相对独立性。

### Magnetic Disk

#### Magnetic Disk Indicators

*   `存储密度`
    
    *   `道密度`：沿 `磁盘半径方向` 单位长度的 `磁道数`。道/英寸
    *   `位密度`：沿 `磁道方向` 单位长度的 `所记录的二进制位数`。位/英寸
    *   `面密度`：面密度道密度位密度面密度 = 道密度 \\times 位密度
*   `存储容量`：一个 `磁盘` 所能存储的 `字节总数`
    
*   `数据传输率`：`磁盘` 在 `单位时间` 内向主机 `传送的字节数 （考虑缓存）`
    
    > 磁盘速度公式转速磁道容量道密度位密度
    
*   `平均存取时间`：从 `发出读写操作`，到 `找到正确位置并开始读写` 所用的时间。
    
    > 平均存取时间平均寻道时间平均等待时间
    > 
    > 平均寻道时间：10~20ms
    > 
    > 平均等待时间：磁盘旋转一周所用的时间\\approx \\frac{1}{2} 磁盘旋转一周所用的时间
    > 
    > > 7200转 \\to 60/7200 /2 = 8 / 2 = 4ms
    > > 
    > > 大部分磁盘的等待时间在这个数值附近。
    

> eg. `磁盘组` 有6片 `磁盘`，每片有2个 `记录面`，最上和最下两个面不适用。
> 
> `存储区域` 内径22cm，外径33cm。`道密度` 为 40道/cm，内层位密度 为 400位/cm，转速 2400r/min 问：
> 
> (1) 共有多少柱面？
> 
> > 有效存储区域半径有效存储区域半径 R = (33 - 22) / 2 = 5.5cm
> > 
> > > 注意：`内径` 和 `外径` 都是 `直径`
> > 
> > 总道数道密度道道总道数 = R \\times 道密度 = 5.5cm \\times 40道/cm = 220道
> > 
> > 故共有 220个柱面。
> 
> (2) 盘组总存储容量是多少 ？
> 
> > 内磁道周长内磁道周长 = 2\\pi R = 2 \\times 3.14 \\times (22/2) = 69.08cm
> > 
> > 每道信息量内层位密度内磁道周长字节\\r{每道信息量 = 内层位密度 \\times 内磁道周长 = 3454字节}
> > 
> > 每面信息量每道信息量总道数字节\\r{每面信息量 = 每道信息量 \\times 总道数 = 759880字节}
> > 
> > > 计算 `某个面的信息量` 的过程，类似于 `求圆形的面积的积分过程`：位道面位 \\to 道 \\to 面
> > 
> > 盘组总容量每面信息量总可用面数每面信息量字节盘组总容量 = 每面信息量 \\times 总可用面数 = 每面信息量 \\times (2\\times 6 - 2) = 7598800字节
> 
> (3) 数据传输率为多少 ？
> 
> > 数据传输率磁盘转速每条磁道容量字节数据传输率 = 磁盘转速 \\times 每条磁道容量 = 2400/60 \\times 3454 = 13816 字节/s
> > 
> > > 在 `磁盘`自身进行 `高速旋转` 时， `读写头` 会 `停留在某条特定的磁道上` 进行 `读写数据`。所以 `数据传输率` 只需要计算 `1条磁道的信息容量` 即可。

### Network Memory

`网络存储器` 技术：

*   `存储区域网络 （SAN, Storage Area Network）`
*   `附网存储 （NAS, Network Attached Storage）`
*   `iSCSI （IP on SCSI）`

## Chapter 5: Instruction System

### Category

`指令系统`

*   定义：是 `机器指令` 的 `集合`
    
*   发展方向
    
    *   复杂指令系统计算机 （CISC）：指令数量多，单条指令功能简单的计算机。
    *   精简指令系统计算机 （RISC）：指令数量少，单条指令功能复杂的计算机。
*   设计要求
    
    *   完备性：指令足够使用
    *   有效性：程序可以高效运行，所需内存少，速度快
    *   规整性：对内存和寄存器透明，对多种数据类型透明，指令格式和数据格式一致
    *   兼容性：系列机中的软件可以向上兼容
    

### Format

指令操作码地址码

> `地址码字段`
> 
> *   `地址码` 不一定存放的是 `地址`，也可能是 `操作数本身` （立即数）
> *   根据 `1条指令中地址码字段的个数`，将指令分类位：`无操作数指令`，`单操作数指令`，`双操作数指令`，`三操作数指令`。

> `指令字长`：`单条指令` 中包含的 `二进制位数`
> 
> `机器字长`：`计算机` 所能够 `直接处理` 的 `二进制位数`。
> 
> *   `机器字长` 一般与 `主存的存储单元的位数` 一致
>     
> *   `单字长指令`：`指令字长` = `机器字长` 的指令
>     
>     > 类似地，还有 `半字长指令`，`多字长指令`
>     
> *   `等长指令字结构` 和 `变长指令字结构`
>     
>     *   等长指令字结构：`所有指令` 的长度相等
>     *   变长指令字结构

### Addressing Mode

`指令` 和 `操作数` 均存放在 `主存` 当中。

`寻址方式`

*   指令的寻址方式
    
    *   顺序寻址：`下一条指令的地址` = `当前指令的地址` + 1
    *   跳跃寻址：`下一条指令的地址` = `当前指令所给出的地址`
*   操作数的寻址方式
    
    > `有效地址 (Effective Address)`：`操作数` 在 `内存` 中的地址
    
    *   隐含寻址：在 `指令` 中 `隐含地给出`。
        
        > 不计算 EA
        > 
        > 指令中给出S = 指令中给出
        
    *   立即数寻址：`指令` 的 `地址码字段` 给出的是 `操作数本身` （而不是 `地址`）
        
        > 不计算 EA
        > 
        > S = D
        
    *   直接寻址：`指令` 的 `地址码字段` `直接` 给出 `操作数的有效地址`
        
        > EA = D
        > 
        > S = (D)
        
    *   间接寻址（相对于直接寻址）：`指令` 的 `地址码字段` 给出的是 `操作数的有效地址的地址`
        
        > `间接寻址` 相当于 `编程语言` 中的 `指针 (Pointer)`。
        > 
        > EA = (D)
        > 
        > \\t{S} = \\t{(EA)} = \\t{((D))}
        
    *   寄存器（直接）寻址：`操作数` 放在 `通用寄存器` 中 （而不是 `内存` 中），通过 `地址码字段` 给出 `寄存器号`
        
        > 不计算 EA
        > 
        > S = (R\_D)
        
    *   寄存器间接寻址：`操作数的地址` 放在 `通用寄存器` 中（而不是内存中），通过 `地址码字段` 给出 `寄存器号`
        
        > EA = (R\_D)
        > 
        > S = (EA) = ((R\_D))
        
    *   偏移寻址 \\hotpink{EA = (R) +D}
        
        *   PC相对寻址：地址码字段的内容EA = \\r{PC} + 地址码字段的内容
            
            > 注意 `题目中` PC 的值是 `当前指令的地址` 还是 `当前指令的下一条指令的地址`
            
            > EA = (PC) + D
            > 
            > S = (EA) = ((PC) + D)
            
        *   基址寻址：基址寄存器的内容地址码字段的内容EA = 基址寄存器的内容 + 地址码字段的内容
            
            > EA = (BX\_{\\r{immutable}}) + D\_{mutable}
            > 
            > S = (EA) = ((BX) + D)
            
        *   变址寻址：变址寄存器的内容地址码字段的内容EA = 变址寄存器的内容 +地址码字段的内容
            
            > EA = (X)\_{mutable} + D\_{\\r{immutable}}
            > 
            > S = (EA) = ((X) + D)
            
    *   复合寻址
        
        *   变址间址\\g{变址}\\b{间址}：EA = \\b(\\g{(R) + D}\\b)
        *   间址变址\\b{间址}\\g{变址}：EA = \\g{(R) + \\b{(D)}}
        *   相对间址\\orange{相对}\\b{间址}：EA = \\b{(\\orange{(PC) + D})}
    *   堆栈寻址
        
        *   串联堆栈：`CPU内` 的 `一组专用寄存器`。
            
            *   操作
                
                *   入栈：某个通用寄存器的数据 \\to 堆栈顶部
                *   出栈：堆栈顶部的数据 \\to 某个通用寄存器
        *   存储器堆栈：将 `主存的一部分连续区域` 作为 `堆栈`。（有用于指示 `栈顶` 的 `堆栈指示器` ）
            
        

根据 `寻址方式` 的 `是否需要计算EA` 来区分为 `是否需要访问内存`

> eg. 字长16位，主存\\r{64K}，指令单字长单地址，80条指令，寻址方式共4种。请设计指令格式？
> 
> > 指令格式 = 7位OP字段 + 2位寻址方式字段 + 剩余的7位作为地址码字段
> > 
> > > 寄存器位寄存器 \\to 16位
> > > 
> > > 相对寻址相对寻址 EA = (PC) + D \\to \\r{64K}
> > > 
> > > 变址寻址变址寻址EA = (R) + D \\to \\r{64K}
> > > 
> > > 直接寻址直接寻址EA = D \\to 128
> > > 
> > > 间接寻址间接寻址 EA = (D) \\to \\r{64K}

### Operation-Code Expansion

`操作码拓展` 可以在不增加 `指令长度` 的前提下，增加 `指令种类数量`。

`指令的操作码的编码格式`

*   不拓展 \\to 定长编码：`操作码字段` 的长度 `固定`。
*   定长拓展 \\to 哈弗曼编码：根据 `指令使用的频度` 来分配 `操作码字段的长度`。
*   不定长拓展 \\to 变长拓展格式：`操作码字段` 向 `地址码字段` 进行 `拓展`。

> 指令拓展的核心思想是：短码不能作为长码的 `前缀` ！
> 
> 留给短码使用的拓展标记的数量不考虑拓展时长码的总指令数当前已经使用掉的长码的指令数留给短码使用的拓展标记的数量 = 不考虑拓展时长码的总指令数 - 当前已经使用掉的长码的指令数

> eg. 某指令系统的指令字长为 16位，每个地址码为6位。
> 
> 若双地址指令有 \\r{15} 条，单地址指令有 \\b{34} 条，则剩下零地址指令有多少条？
> 
> > 指令格式 = 4位操作码字段 + 6位地址码字段 + 6位地址码字段
> > 
> > 双地址指令 ： 0000 ~ 1110 总共 \\r{15} 条指令 （不拓展时为 2^4=16 条）
> > 
> > 单地址指令：1111 (000000 ~ 111111) 总共 2^6=64 条指令 （已经用了34条）
> > 
> > 零地址指令：1111 (100010 ~ 111111) (000000 ~ 111111) 总共 64\\b{-34}=30 个拓展标记，每个拓展标记都有 2^6 = 64 条 零地址指令。
> > 
> > 故：零地址指令 最多有 30 \\times 2^6 = 15 \\times 2^7 种

## Chapter 6: Central Controller Unit

### Controller

控制器

*   功能
    
    *   指令控制：保证指令按照程序规定的顺序进行执行
    
    *   操作控制：`产生` 每条指令执行所需要的各种 `控制信号`，并送到 `相应部件` 产生相应的 `动作`
    
    *   时间控制：用于 `同步` 不同的操作
    
    *   异常和中断处理
*   基本组成
    
    *   程序计数器 PC
        
        *   保存 `下一条指令` 的地址
        *   完成顺序控制的功能
        *   内容在取址完成后即可改变！
        *   转移指令可以直接修改PC值
    *   指令寄存器 IR
        
        *   保存 `当前正在执行的指令`
        *   指令的操作码字段和寻址方式送译码
    *   指令译码器 ID
        
        *   对指令的 `操作码字段` 和 `寻址方式` 进行译码，指出指令的操作方式
        *   译码的结果：找出该指令相关的 `微程序的入口`
    *   操作控制器 OC
        
        *   产生指令执行过程中所需的 `控制信号`
        *   实现指令的操作控制功能
    *   时序产生器 TG
        
        *   对操作 `控制信号` 进行 `同步`
        *   实现 `控制器` 的 `时间控制功能`
*   实现方式
    
    *   微程序控制器
    *   硬布线控制器
    
    ### Instruction-Cycle
    
    `数据通路`：`数据` 在 `功能部件` 之间传送的 `路径`。
    
    `指令周期`：`取出` 一条指令，并 `执行` 一条指令所需要的时间。
    
    `CPU周期` （`机器周期`）：`CPU` 从 `内存` 中取出 1个 `机器字` 所需的最短时间。通常由若干个 `时钟周期` 组成。
    
    `时钟周期`（T周期）：`计算机` 的 `节拍周期`，是计算机中处理 `操作` 的 `最基本的时间单位`。
    
    ![image-20220614141138895](https://s2.loli.net/2022/06/14/59DMQHj2qPas1bZ.png)
    

### Time Generator

`多级时序体制`：

*   属于 `电位-脉冲制`，`电位` 对应 `CPU时间` ， `脉冲` 对应 `时钟周期`。 （数据在寄存器之间的传送）
    
*   采用 `硬布线逻辑 （门电路 + 触发器组成）` 的 `计算机多级时序体制` 是 `主状态周期-节拍电位-节拍脉冲 三级时序体制`
    
    *   `主状态周期`：反映 `某个状态周期的持续时间`，通常用 `触发器的状态持续时间` 表现。（1个主状态周期包含多个 节拍电位，对应1条指令的执行时间）
    *   `节拍电位`：表示一个 `CPU周期` 的时间。（包含多个节拍脉冲）
    *   `节拍脉冲`：`节拍电位` 内的 `控制脉冲`，对应了最基本的 `定时信号`。

### Micro-Program Controller

`微程序设计技术` 是使用 `软件` 来设计 `硬件` 的技术。

通过将 `每条指令` 所需的 `操作控制信号` 编码为 `微指令`，存放到 `控制存储器 （只读）` 中。而每条 `机器指令` 对应 `一段微程序`，当机器执行 `机器指令` 时，依次执行 `该机器指令所对应的微指令`。

`微操作`：`执行部件` 接受 `微命令` 后所进行的 `操作`

`微命令`：`控制部件` 通过 `控制线` 向 `执行部件` 发出的各种 `控制信号`。 （打开和关闭控制门）

> `微命令的编码` 就是 `微指令的编码中的控制字段`：`微指令的控制码字段的每一个位` 就是一个 `微命令`

`微指令`：在机器的一个 `CPU周期` 之内，一组实现一定功能的 `微命令的集合`。

> 微指令格式操作控制字段顺序控制字段 微指令格式 = 操作控制字段 + 顺序控制字段
> 
> ![image-20220614171645818](https://s2.loli.net/2022/06/14/wS3nGgrzeW5HDP2.png)
> 
> *   操作控制字段：管理和指挥全机工作的 `所有控制信号`。
> *   顺序控制字段：用于进行判别测试和给出 `下一条微指令的地址`
> 
> `微（指令）周期`：从 `控制存储器` `取出一条微指令`，并 `执行微指令` 所需要的时间。
> 
> *   在 `串行执行` 时，一般 `微指令周期` = `机器周期`，以便系统的同步控制
>     
>     > ![image-20220614171939492](https://s2.loli.net/2022/06/14/wCAkLVEu9Hs368e.png)
>     

![image-20220614172447065](https://s2.loli.net/2022/06/14/wruAWkomqdnzGiE.png)

`微程序控制器的组成部分`：

*   微指令寄存器 IR：存放从 `控制存储器` 中读出的 `微指令`
    
*   微地址寄存器 AR：存储访问 `控制存储器的微地址`
    
    > *   AR 类似于 PC
    > *   `微程序的入口地址` 由 OP 通过 `测试` 装入
    > *   `顺序执行时的后续微指令的地址` = AR +1
    > *   转移时，使用 `P字段的相关位` 测试 `外部条件`，并根据 `测试结果` 来决定是否修改 AR，以实现 `转移`
    > *   根据 `机器指令的OP字段` ，通过某种 `映射方式`，获得 `该机器指令相应的微程序的入口地址`
    

`一条机器指令` 对应 `一段微程序` （包含该 `机器指令` 在执行过程中的 `所有控制信号`）。

`微程序` 是 `微指令的集合`

### Hard-Wiring Controller

`硬布线控制器`

*   采用 `硬布线方式` 设计的控制器称为 `硬布线控制器`。
*   采用 `组合逻辑` 方式设计 `控制器`，并由 `组合逻辑` 来 `产生指令执行过程中所需的所有控制信号`。
*   Control = f(Instruction, Status, Time)

![image-20220614180810636](https://s2.loli.net/2022/06/14/HFv3D1awW9YcZrm.png)
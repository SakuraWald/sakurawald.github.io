---
title: Computer Composition - Representation and Computation – Integer
tags: []
id: '33736'
categories:
  - - uncategorized
date: 2022-04-02 20:11:49
---

# Representation and Computation - Integer

## Representation

### The Representation of Integer

#### Unsigned Integer

> 这是我们最常见的`整数表示法`，在`进制转换`中经常使用该等式作为`中介`
> 
> 由于是`无符号数`，我们并不需要考虑`负整数`的问题，该表示方式建立了一个`二进制位模式`和`十进制非负整数`之间的一个简单的双射：
> 
> 因而，我们说`无符号数编码`具有`唯一性`

#### Signed Integer

##### Tow's Complement Method

> 大部分的机器采用`补码编码`, 补码的含义为：对于非负整数x，我们使用2^{w} - x`来计算-x的w位表示`

> `补码编码`在`无符号数编码`的基础上，将`二进制位模式的最高位`作为`符号位`，权重为\-2^{w-1}
> 
> > 也可以把`补码编码`看成：将`无符号数编码`的`求和式最后一项 取相反数`从而得到。
> 
> 注意到，除了`最高位拥有一个非常大的负权重`之外，`二进制位模式中的其他位的权重均为 正权重`！
> 
> > 进而我们可以表示的最小负数最小负数 = UMin\_w \\dot{=} \[10\\cdots0\] = (1)\\times (-2^{w-1})，最大正数最大正数 = UMax\_w \\dot{=} \[01\\cdots111\] = \\sum\_{i=0}^{w-2}{(1)\\times2^i}
> > 
> > > 注意这个表示范围，因为2^{n} - \\sum\_{i=0}^{n-1}{2^i} = 1 \\implies TMin = TMax + 1
> > > 
> > > 准确地说，`补码编码`是将`整数`划分为`负数`和`非负数`。
> > 
> > 同理，`补码编码`也具有`唯一性`
> 
> > 此外，我们还发现UMax\_w = 2TMax\_w + 1
> > 
> > > 证明：思路是让`等式两边的值相等`。
> > > 
> > > Q.E.D

##### Ones' Complement

> `反码编码`与`补码编码`的区别在于，`反码编码最高位的权重`比`补码编码的最高位权重` `小1`

> 反码表示的含义为：使用`[111...1] - 1`来表示`-x`的反码表示

##### Sign-Magnitude

> `原码编码`与`补码编码`虽然都是`由最高位来决定符号`，但`原码编码的最高位`仅仅用于`表示正负`。
> 
> 而且，我们注意到后面的\\sum\_{i=0}^{w-1}{x\_i2^i}部分`相等`，但由于`对负数的表示方法不同`。
> 
> `原码编码的 正整数个数 = 负整数个数`，并且，`我们还发现表示0的位模式有两个： +0 和 -0`
> 
> > `多出来的一个0`是由`补码编码中的最小的负整数 的位模式`所得来的。
> > 
> > 2^w = \\sum\_{i=0}^{w-1}{x\_i2^i} + 1

### Coding Conversion

#### T2U

* * *

`补码编码`和`无符号数编码`的区别在于`位模式的最高位的权重`。

因此，需要分情况考虑`x的补码编码表示下的位模式的最高位`：

1.  最高位 = 0：即`x在补码编码下为非负整数，则可以直接转化为 无符号数编码的x`
    
    > 因为`无符号数编码的非负整数的范围 > 补码编码的非负整数的范围`，所以`当前的非负数必定可以被装下`
    
2.  最高位 = 1：即`x的补码编码下为负数`，则`在补码编码的表示下，最高位权重为`\-2^{w-1}，`在无符号数的编码表示下，最高位的权重为`2^{w-1}。
    
    因此，\\Delta weight = 2^{w-1} - (-2^{w-1} = 2 \* 2^{w-1} = 2^w)
    

综上，我们得出结论：B2U\_w(T2B\_w(x)) = \\textcolor{red}{T2U\_w(x) = x + x\_{w-1} \* 2^{w}}

> 该结论表明，当`有符号数`(即用`补码编码`)被映射到`无符号数`（即用`无符号正数编码`）时，`负数`会被转化为`大的正数`，而`非负数`保持不变。

#### U2T

* * *

`Unsigned Integer`和`Two's Complement`的区别就在于`位模式的最高位`，而`除了最高的其他w-1位所表示的权重是一样的`

因此，我们仍然需要从`位模式的最高位 的取值情况 来考虑`：

1.  x\_{w-1} = 0 \\implies u \\le TMax\_w：在这种情况下，`无符号数编码`和`补码编码`所表示的含义就是一样的了。
    
2.  x\_{w-1} = 1 \\implies u \\gt TMax\_w：对于`位模式的最高位为1`的情况。
    
    > 转换后位模式的最高位的权重转换前位模式的最高位的权重
    

我们可以得出结论：\\textcolor{red}{U2T\_w(u) = u -u\_{w-1} \\times 2^{w}}

> 与`有符号数`和`无符号数`转换相关的结论：
> 
> UMax\_w = 2TMax\_w+ 1

综上，Q.E.D

### Extend Bit Mode

当在`不同字长的证整数`之间进行`转换`，同时又想`保持数值不变`时。

显然，我们只可能`从较小的数据类型 -> 较大的数据类型`

#### Methods

##### Zero Extension

无符号数的零拓展

##### Sign Extension

在需要将`补码数字`转化为`一个更大的数据类型`且`保持数值不变`时，可使用`符号拓展`。

> 也就是说：我们可以将`较小的补码数字表示` `拓展到较大的补码数字表示`并且`保持数值不变`

补码数的符号拓展

* * *

由于x\_0,\\cdots,x\_{w-2},x\_{w-1}`的部分在补码编码下的拓展前后的前后的权重 相等`。

故接下来我们只需要证明，我们`为`\\vec{x}'`拓展的位的权重的累加 = 0`。

但为了证明的简单，我们使用`归纳法`：仅证明`符号拓展了1位的补码编码的数值 不会发生改变`，进而`得出对补码编码符号拓展任意多位，数值也不会改变`

分类讨论x\_{w-1}的取值

1.  x\_{w-1} = 0：显然成立
2.  x\_{w-1} \\ne 0：

Q.E.D

> 蓝色部分：先考虑从\\vec{x}和\\vec{x}'的x\_{w-1}，当`位数拓展1位后，拓展前后的第w-1位的含义就不同了`
> 
> 红色部分：这部分是多出来的，可以直接相加即可。`第w位的值`为 x\_{w-1}，权重为\-2^{w}

> 另一种观点是：2^w - 2^{w-1} = 2^{w-1}
> 
> 即`加上一个权为-2^w的位` = `将一个权为-2^{w-1}的位 转换为 权为2^{w-1}`
> 
> > PROOF
> > 
> > 1.  如果权重前的系数=0，则显然成立
> > 2.  如果权重前的系数≠0，则 ((2^{w-1}) - (-2^{w-1})) + (-2^w) = 0

### Truncate Integer

`截断`发生在`较大的数据类型 -> 较小的数据类型`

#### Methods

##### Truncate Unsigned Integer

截断无符号数

* * *

对于`无符号数编码` ：i \\in N, weight(x\_i) = 2^i

分别计算`等式左侧`和`等式右侧`

B2U\_w(\\vec{x}) = \\sum\_{i=0}^w x\_i 2^i

B2U\_k(\\vec{x}') = \\sum\_{i=0}^{k}{x\_i2^i}

> `所有被截去的位的重数都是`2^i, i \\ge k 因此`这些权在 取模操作 下都变为0`
> 
> 也就是说：`取模操作`\\mod 2^k可以使得weight(x\_i) = 0, i \\ge k

Q.E.D

##### Truncate Two's Complement Integer

截断补码数

* * *

> 0 \\le x \\mod 2^k \\le 2^k - 1 等效于`将最高有效位`x\_{k-1}`的权重 从`2^{k-1}`转换到`\-2^{k-1}
> 
> > 注：`在对最高位k进行`\\mod 2^k`操作之前，如果`x\_k = 1`则我们当然可以 加权`2^{k-1}，`但是，在进行 取模操作后，即使`x\_k = 1`，则在取模运算后，我们加权+0`
> > 
> > *   如果x\_k = 0，那么`权重转换的等效性 显然成立`。
> > *   如果x\_k = 1，则`在取模运算后，相当于 最高位是废的，本应当加权`2^{k-1}`实际却只加权`+0。这`等价于我们损失了`2^{k-1}`数量的权`（即实际加权为\-2^{k-1}）

Q.E.D

## Computation

### Unsigned Addition

无符号数加法

如果sum = x+y \\lt 2^w，则sum\_{w+1} = 0`该位被丢弃不会影响数值`

如果sum = x + y \\ge 2^w，则sum\_{w+1} = 1`该位被丢弃会影响数值`，`丢弃该位最高位`\=`数值减少`2^w

* * *

#### Overflow Detection

溢出检测

#### Unsigned for Non

无符号数求反

> 注：上面的`-号`并不是`减号`，而是表示`求逆元`

> 根据`模数加法（阿贝尔群 Abelian Group）`：对于\_w^ux \\implies \\exists -\_w^ux, -\_w^ux + \_w^ux = 0

* * *

1.  当x = 0时，`加法逆元`即为`0`
2.  当x > 0时，`考虑`2^w - x，有0 \\lt 2^w - x \\lt 2^w 且(x + \\textcolor{hotpink}{(2^w - x)}) \\mod 2^w = 2^w \\mod 2^w = 0。故2^w-x是\_w^u+下的`加法逆元`

### Tow's Complement Addition

补码加法

> 上述式子告诉我们，`补码加法`和`无符号加法`之间有`完全相同的位级表示`。
> 
> 所以，对于+\_w^t运算：可以先将参数转化为`无符号数`，执行`无符号加法`，然后再将结果转化为`补码`：

* * *

![image-20220402193536399](https://s2.loli.net/2022/04/02/x6RhgBImwsWEuLl.png)

#### Overflow Detection for Two's Complement Addition

补法加法的溢出检测

### Two's Complement for Non

补法求非

* * *

TMin\_w + TMin\_w = -2^{w-1} + (-2^{w-1}) = -2^w \\implies \\text{Negative Overflow}

\\therefore TMin\_w + \_w^tTMin\_w = -2^w \\textcolor{red}{\\underbrace{+ 2^w}\_{\\text{Negative Overflow}}}= 0

\\because\\forall x \\gt TMin\_w, -x + x = 0

Q.E.D

### Unsigned Multiplication

无符号数乘法

### Two's Multiplication

对于\-2^{w-1} \\le x,y \\le 2^{w-1} -1内的整数x和y可以被表示为`w位的补码数字`。

但（\-2^{w-1} \\cdot （2^{w-1} - 1) = -2^{w-1} \\cdot -2^{w-1} = -2^{2w-2} \\implies -2^{2w-2} \\le x \\cdot \_w^ty \\le -2^{2w-2}

对于C语言的有符号数乘法，是`通过将2w位的乘积 截断为 w位`来实现的。

补码乘法

* * *

`无符号数乘法`和`补法乘法`在`位级表示`具有`等价性`

> 补码乘法和无符号数乘法的等价性

### Multiply by a Constant

无符号数乘以的幂

与的幂相乘的无符号乘法逻辑左移

与的幂相乘的补码乘法逻辑左移

> 无论x是`无符号编码`还是`补码编码`，`移位运算`所产生的结果`与乘法运算`相同。

### Divided by a Constant

除以的幂相除的无符号除法逻辑右移

除以的幂相除的补码除法算术右移向下舍入

> 上式告诉我们，当`除法运算不需要舍入时`，它的效果和`算术右移`是一样的。
> 
> 但若`存在舍入`时将会`向下舍入`，导致`算术右移的结果`与`除法运算`有`偏差`
> 
> > 我们可以通过`在移位前进行偏置 (Biasing)`来修复这种偏差。

除以的幂的补码除法算术右移向上舍入

> 原理：\\lceil x/y \\rceil = \\lfloor(x\\textcolor{blue}{+y-1})/y \\rfloor
> 
> 证明
> 
> 采用修复算术右移默认的向下舍入误差
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sakurawald.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SakuraWald">
<meta property="og:url" content="https://sakurawald.github.io/page/4/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sakurawald.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>SakuraWald</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SakuraWald</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/03/combinatorics-the-generatation-of-arrangements-and-combinations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/combinatorics-the-generatation-of-arrangements-and-combinations/" class="post-title-link" itemprop="url">Combinatorics - The Generation of Arrangements and Combinations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 16:15:41" itemprop="dateCreated datePublished" datetime="2022-04-03T16:15:41+00:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Arrangement-and-Combination"><a href="#Arrangement-and-Combination" class="headerlink" title="Arrangement and Combination"></a>Arrangement and Combination</h1><h2 id="Generate-Arrangements"><a href="#Generate-Arrangements" class="headerlink" title="Generate Arrangements"></a>Generate Arrangements</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>生成\{1,2,\cdots,n\}的排列的方法。</p>
<h4 id="Solution-1-Johnson-and-Trotter’s-Method"><a href="#Solution-1-Johnson-and-Trotter’s-Method" class="headerlink" title="Solution 1: Johnson and Trotter’s Method"></a>Solution 1: Johnson and Trotter’s Method</h4><p>\{1,2,\cdots,n\}<code>的所有可能排列</code>可以从\{1,2,\cdots, n -1\}<code>的所有可能排列</code>中<code>插入元素n</code>而得到。</p>
<blockquote>
<p>该生成方法并不保证<code>字典序</code>，对于元素的插入顺序，可以<code>从左往右</code>或者<code>从右往左</code>，但最好<code>系统性地进行插入</code>以避免遗漏</p>
</blockquote>
<blockquote>
<p>该生成方法还存在一个问题，需要保存上一轮的所有输出结果，以便下一轮进行插入。</p>
</blockquote>
<blockquote>
<p>算法<code>总共需要执行n轮，第k轮获得k!个新排列方式</code></p>
</blockquote>
<h4 id="Solution-2-Even’s-Method"><a href="#Solution-2-Even’s-Method" class="headerlink" title="Solution 2: Even’s Method"></a>Solution 2: Even’s Method</h4><p><code>方向</code>：我们为<code>排列中的每一个数字</code>指定<code>箭头向左</code>或<code>箭头向右</code></p>
<p><code>可移动的数字</code>：<code>某个数字</code>是<code>可移动的</code>，如果<code>该数字 大于它的箭头所指方向的数字</code>。</p>
<p>此外，<code>位于第一个位置且指向左边的数字 和 位于最后一个位置且指向右边的数字</code>均为<code>不可移动的</code></p>
<ul>
<li><p>初始化：从\overleftarrow{1}\overleftarrow{2}\cdots\overleftarrow{n}开始</p>
</li>
<li><p>若<code>存在可移动数字</code></p>
<ol>
<li>求出<code>最大的可移动数字 m</code></li>
<li>交换<code>m</code>和<code>m箭头所指方向的数字</code></li>
<li>反转<code>所有大于m的数字 的方向</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>算法<code>总共需要执行(n-1)!轮，每轮生成n个新的排列方式</code></p>
</blockquote>
<blockquote>
<p><code>除了第一轮的第一次操作</code>，<code>每轮的第一次操作移动的都不是数字n，非第一轮的操作移动的都是数字n</code></p>
<p><code>每一轮的第一次操作所形成的排列</code>中<code>包含去除最大元素后的全排序</code>：123, 132, 312, 321, 231, 213</p>
</blockquote>
<blockquote>
<p>该<code>全排列生成算法</code>的好处是，我们不需要存储<code>中间产生的排列结果</code>。</p>
<p>可以从<code>插入法</code>的角度看，<code>数字的左右移动</code>类似于<code>将该数字插入到不同的位置</code></p>
<p><code>第一轮第一次操作 = 给每个数字插入了1次</code>，<code>移动某个数字 = 给大于等于该数字的所有数字 插入了1次</code></p>
<blockquote>
<p>对于<code>&#123;1,2&#125;的排列来说：移动数字3并不会影响排列数量，因为我们可以简单地 忽略掉数字3</code></p>
<p>但对于<code>&#123;1,2,3&#125;的排列来说：移动数字2会影响&#123;1, 2&#125;的排列数量，也会影响&#123;1, 2, 3&#125;的排列数量</code></p>
</blockquote>
<p>故：<code>数字3移动的次数 = 数字3被插入的次数 - 1 = 3! - 1 = 5</code>，<code>数字2移动的次数 = 2！- 1 = 1</code>，<code>数字1移动的次数 = 1! - 1 = 0</code></p>
</blockquote>
<h3 id="Inverse-Ordinal-Number"><a href="#Inverse-Ordinal-Number" class="headerlink" title="Inverse Ordinal Number"></a>Inverse Ordinal Number</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>若i_1i_2\cdots i_n是集合\{1,2,\cdots, n\}的排列，若k \lt l \and i_k \gt i_l，则我们称<code>数对</code>(i_k, i_l)是一个<code>逆序（Inversion）</code>.</p>
<blockquote>
<p>也就是说，<code>排列</code>中的<code>逆序</code>概念，对应着<code>不以自然数顺序出现的一对数</code></p>
</blockquote>
<blockquote>
<p>唯一没有逆序的排列是12\cdots n</p>
</blockquote>
<p><code>j的无序程度</code>使用a_j来表示 a_j \dot{&#x3D;} \{k: k \lt j \and i_k \gt i_j \}</p>
<p>由a_j组成<code>排列的逆序列</code> a_1, a_2, \cdots, a_n</p>
<blockquote>
<p><code>按排列中的逆序个数</code>的<code>奇偶性</code>，我们定义<code>奇排列</code>和<code>偶排列</code></p>
</blockquote>
<p><code>逆序数 (Numebr of Inversion)</code> 为<code>逆序列</code>的<code>求和</code>: \sum_{i&#x3D;1}^n a_i</p>
<h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><h5 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h5><h6 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h6><p>存在唯一的逆序列为的的排列</p>
<blockquote>
<p>也就是说：<code>排列</code>和<code>逆序列</code>之间是<code>双射</code>的</p>
</blockquote>
<h6 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h6><p>如果我们可以根据<code>逆序列</code>来<code>构建</code> <code>唯一的排列</code>，则该<code>满射</code>关系成立。</p>
<blockquote>
<p>注：下列构建方式所使用的<code>位置</code>均从0开始。</p>
</blockquote>
<hr>
<p>通过逆序列构建排列：从最大的数开始</p>
<ul>
<li><p>n</p>
<p>直接写出n</p>
<blockquote>
<p>b_n \equiv 0，我们无法得出n的更多信息。</p>
<p>但好在我们可以直接写出n，后续的其他数字可以相对于n的基础上进行<code>插入</code>即可。</p>
</blockquote>
</li>
<li><p>n - 1</p>
<p>插入到左侧插入到右侧</p>
</li>
<li><p>n - 2</p>
<p>插入到左侧插入到位置插入到右侧</p>
</li>
<li><p>…</p>
</li>
<li><p>n - k</p>
</li>
</ul>
<p>插入到位置位置表示插入到最左侧，位置表示插入到最右侧</p>
<p>Q.E.D</p>
<blockquote>
<p>该算法的通过<code>按元素的降序顺序插入元素</code>，<code>逐个确定相对位置</code>。</p>
<p>缺点是直到算法运行结束之前，我们无法知道<code>某个元素在排列中究竟处于哪一个位置</code>。</p>
<blockquote>
<p>这取决于我们对<code>元素的逆序程度</code>a_j的定义</p>
</blockquote>
</blockquote>
<hr>
<p>通过逆序列构建排列：从最小的数开始</p>
<ul>
<li>1</li>
</ul>
<p>将1插入到位置b_1</p>
<blockquote>
<p>请注意，这意味着，我们之后的操作，将<code>保证</code> <code>新插入的在位置</code>b_1<code>左侧的元素</code>必须<code>大于1</code></p>
</blockquote>
<ul>
<li>2</li>
</ul>
<p>将2插入到<code>从0开始的第</code>b_2<code>个空位置</code></p>
<blockquote>
<p>假如说，我们直接把<code>元素1</code>从我们的<code>逆序</code>概念中去除。</p>
<p>那么对于<code>元素2</code>，它就是<code>最小的数</code>，这时我们只需要把<code>元素2</code>插入到<code>位置</code>b_2即可</p>
<p>但由于<code>从位置0到位置</code>b_2之间，有可能<code>某些位置已经被元素1</code>所<code>占据</code>，我们很清楚<code>这个位置不会使逆序数+1</code></p>
<blockquote>
<p>因为我们是<code>按从小到大的顺序插入元素的</code>，而<code>1 &lt; 2</code>。</p>
</blockquote>
<p>所以，我们需要<code>跳过这个已经被占据的位置。</code></p>
<blockquote>
<p>换句话说，我们要找的是<code>空位置</code>并<code>保证每个空位置要为数字2贡献1个逆序</code>，<code>已经被占据的位置</code>根据我们的推论，<code>对数字2贡献的逆序必定为0</code></p>
</blockquote>
</blockquote>
<ul>
<li>…</li>
<li>n</li>
</ul>
<p>将n插入到<code>从0开始的第</code>b_n<code>个空位置</code></p>
<p>Q.E.D</p>
<blockquote>
<p>该算法有一个好处是：一旦<code>某个元素的位置</code>被<code>确定</code>，那么之后<code>它的绝对位置</code>就不会发生改变</p>
</blockquote>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p>通过<code>交换相邻的元素</code>来将<code>排列361245</code>转变成<code>排列123456</code>所需<code>操作次数</code>就是<code>该排列的逆序数</code>。</p>
<hr>
<p><code>该排列的逆序数 = 0 + 0 + 2 + 2 + 1 + 1 = 6</code></p>
<p>首先，<code>如果对于所有数字，都能与相邻元素满足自然顺序</code>，那么<code>这个排列必须没有逆序数</code>，即该<code>排列</code>为12\cdots n</p>
<p>因此，我们可以得知，<code>如果排列存在逆序数，则必定有</code> <code>某个元素与相邻元素形成逆序对</code></p>
<p>我们可以考虑将<code>该元素 和 与之相邻的与该元素构成逆序对的那个元素</code>视为一个<code>整体</code>，</p>
<p>之后，我们<code>在这个整体中，交换 这两个元素</code>，我们就可以使得<code>逆序数 -1</code>，</p>
<p>更重要地，<code>我们交换这个整体中的元素，并不会对其他元素的逆序数造成影响！</code></p>
<p>综上，我们得出结论：<code>对于存在逆序的排列，可以通过1次交换相邻元素 来使得 逆序数-1</code></p>
<p>Q.E.D</p>
<h2 id="Generate-Combinations"><a href="#Generate-Combinations" class="headerlink" title="Generate Combinations"></a>Generate Combinations</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>若<code>集合</code>S &#x3D; \{x_{n-1}, x_{n-2}, \cdots x_0\}，我们寻找一种<code>生成所有的</code>2^n<code>个组合(子集)的方法</code></p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><h4 id="Continuous-Binary-Method"><a href="#Continuous-Binary-Method" class="headerlink" title="Continuous Binary Method"></a>Continuous Binary Method</h4><p>我们可以把<code>每个子集</code>视为一个<code>n元组</code>。</p>
<p>该<code>n元组</code>表示的是<code>二进制位模式</code>，则<code>所有子集的n元组的二进制位模式</code>所对应的<code>整数范围</code>是[0, 2^n - 1]</p>
<p>故，只需<code>遍历这个整数范围，然后输出所对应的子集</code>即可。</p>
<blockquote>
<p>根据这种生成方法，知道<code>第0个子集</code>为<code>空集</code></p>
</blockquote>
<blockquote>
<p>该方法的好处是，可以很容易地生成<code>指定编号的子集</code>，因为<code>每个编码</code>等于<code>某个子集的二进制数的表示</code></p>
</blockquote>
<h4 id="Dictionary-Binary-Method"><a href="#Dictionary-Binary-Method" class="headerlink" title="Dictionary Binary Method"></a>Dictionary Binary Method</h4><ul>
<li><p>初始化：从a_{n-1}\cdots a_1a_0 &#x3D; 0\cdots00开始</p>
</li>
<li><p>持续：当a_{n-1}\cdots a_1a_0 \ne 1\cdots 1时</p>
<ol>
<li>求出<code>使得</code>a_j &#x3D; 0<code>的最小整数j</code></li>
<li>用代替用1代替a_j 且 用代替中的每一个用0代替a_{j-1},\cdots,a_0中的每一个</li>
</ol>
</li>
<li><p>终止：我们得到<code>按字典序排列的所有的子集</code></p>
</li>
</ul>
<blockquote>
<p>也就是说：</p>
<p>该算法<code>每一轮</code>中<code>仅考虑生成前k个元素的子集</code>，在<code>在每一轮的每一步</code>中<code>按字典序顺序加入一个新元素</code>，</p>
<p>直到<code>生成完前k个元素的所有子集</code>，然后<code>再考虑仅生成前k+1个元素的子集</code>，如此进行完成<code>生成前n个元素的所有子集</code></p>
<blockquote>
<p>根据这个生成特点，我们将这个<code>子集的生成序列</code>称为是<code>子集的压缩序</code>：<code>所有不包含4的子集</code>出现在<code>所有包含4的子集</code>的<code>前面</code></p>
</blockquote>
<p>因此，这个算法所得到的子集的生成顺序，是<code>字典序的</code>。</p>
<blockquote>
<p>可以将<code>二进制位0和1</code>视为<code>字母a和b</code></p>
</blockquote>
</blockquote>
<h4 id="Reflective-Gray-Code"><a href="#Reflective-Gray-Code" class="headerlink" title="Reflective Gray Code"></a>Reflective Gray Code</h4><blockquote>
<ul>
<li>Background</li>
</ul>
<p><code>基于字典序的生成方法</code>可能使得<code>连续生成的两个子集</code>存在较大<code>差异 (Difference)</code>，</p>
<p>而我们希望有一种<code>使得连续生成的子集之间的差异较小的方法</code></p>
<blockquote>
<p>差异指的是<code>相差的元素个数</code>，我们定义<code>差异小</code>为<code>每次增加1个元素</code>或<code>每次减少1个元素</code>。</p>
<p>但这两个操作每次<code>不能同时进行</code></p>
</blockquote>
<blockquote>
<p>请注意这其中隐含的模型，由于<code>我们每次操作</code>都要<code>生成一个新的子集</code>，</p>
<p>而且这个子集不能与<code>之前已生成的子集</code>发生<code>重复</code>。</p>
<p>我们可以用<code>图</code>来建模，将<code>每个特定的子集</code>作为<code>顶点</code>，而将<code>每一步转变</code>作为<code>边</code>。</p>
<blockquote>
<p>如果两个顶点之间存在边，则说明 这两个顶点所对应的子集 之间<code>可以互相转换 (Transform)</code></p>
</blockquote>
<p>这样，我们只需要<code>合适地构建这些顶点之间的顺序</code>，则问题转化为：<code>寻找该图的哈密顿路径</code>。</p>
<hr>
<p>对于<code>寻找哈密顿路径</code>来说是简单的，如果<code>确实存在这种生成方法</code>，<code>那么我们总是能找到哈密顿路径</code>。</p>
<blockquote>
<p>实际上，我们并不会真正地去运行<code>寻找哈密顿路径的算法</code>。而是通过<code>反射Gray码</code>方式来<code>确定这样一条路径</code>。反射Gary码一种很巧妙的方式，不但可以构建更高阶的n方体，而且还能同时确定路径。</p>
<p>这里有一些相关的资料：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34629230/answer/88012219">https://www.zhihu.com/question/34629230/answer/88012219</a></p>
</blockquote>
<p>这里最大的问题在于，<code>如何将n元素的所有的</code>2^n<code>个子集所对应的顶点</code>在<code>题目所给的约束规则下</code>构造到<code>图</code>中。</p>
<ul>
<li><p>n &#x3D; 1：图为一条<code>线段</code>，这显然满足题意。</p>
</li>
<li><p>n &#x3D; 2：图为一个<code>正方形</code></p>
<blockquote>
<p>我们有4个顶点，我们从<code>空集所对应的顶点 (00)</code> 出发，则由于任意顶点的<code>出度</code>均为<code>2</code>，</p>
<p>所以，我们可以给<code>顶点00</code>的<code>所有出边</code>均<code>进行添加元素操作</code>，即<code>将(00)连接到(01), (10)</code></p>
<p>现在，我们<code>以顶点(01)为例</code>，它也有<code>2条出边</code>，对于<code>已经存在的每一条与顶点(01)相连的边</code>，</p>
<p>它的含义是<code>顶点(01)的集合中 某个元素的变换方式：增加该元素 或 删除该元素。这取决于 路径中该边的方向是如何确定的</code>。</p>
<p>由于<code>顶点(01)已经和顶点(00)相连，故我们知道</code>x_0<code>的转变方式 已经体现了处理</code>。</p>
<p>接下来<code>仅需要考虑为</code>x_1<code>这个对象建立 转变方式</code>：于是我们<code>连接 顶点(01) 和 顶点(11)</code>。</p>
<hr>
<p>同理，对<code>顶点 (10)</code>也做如此考虑，最终我们得到的图是一个<code>正方形</code></p>
</blockquote>
</li>
<li><p>n &#x3D; 3：图为一个<code>正方体</code>。</p>
<blockquote>
<p>关于<code>最终构造的图的形状</code>，我们进行分析。</p>
<p>首先，图的顶点数图的顶点数 V &#x3D; 2^n，而且，我们<code>猜测最终形成的图的形状，具有比较好的对称性</code>。</p>
<p>不妨仍从<code>空集所对应的顶点</code>(x_{n-1},x_{n-2}, \cdots, x_0)考虑，由于<code>空集不包含任何元素</code>，所以我们只能进行<code>添加元素操作</code>。</p>
<p>如果我们<code>要从空集所对应的顶点</code>(x_{n-1},x_{n-2}, \cdots, x_0)<code>开始，生成 所有元素的单元素集合</code>，则<code>空集所对应的顶点</code>的出度应该为<code>n</code></p>
<p>那么，出于<code>对称性</code>考虑，我们<code>希望每个顶点的出度都为n</code>。</p>
<p><code>对于每一个顶点</code>，如果<code>n增加1，则意味着 多一个对象</code>，那么<code>每个顶点都需要多引出1条出边 （这也意味着多1个顶点）</code></p>
<blockquote>
<p>这种<code>从n方体生成n+1方体</code>的方法，实际等效于 <code>反射Gray码</code>：拷贝一份当前的n方体，并连接相对应的角点。</p>
<p>如果<code>同时拷贝了路径的走向 并将它反向</code>，则我们将可以得到<code>n+1方体</code>中的<code>哈密顿路径</code>。</p>
</blockquote>
<p>所以<code>增加的顶点数量 = n * 1 = n</code>，符合图的顶点数图的顶点数 V &#x3D; 2^n的式子。</p>
<p>更重要的是，<code>对于每一个顶点所新多出的那条边，它的操作对象必须是 新增的那一个对象，并且必须是 添加元素操作</code></p>
<blockquote>
<p>因为在<code>低阶情况下，这个新增的对象根本不存在（相当于它的二进制值为0</code>），同时要<code>避免重复的生成子集</code>，</p>
<p>所以我们能做的，只有<code>在当前顶点所表示的集合的二进制模式</code>中<code>添加前缀1</code></p>
<blockquote>
<p>而且，如果你对<code>n = 4的情况下，忽略掉 超立方体 中的第0位二进制位</code>，则可以<code>重新得到</code> <code>n=3时的正方体的一个同构</code></p>
<p><img src="https://s2.loli.net/2022/04/03/Wv418w3iN9OoFJL.png" alt="image-20220403104604545"></p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>n &#x3D; 4：图为一个<code>超立方体</code></p>
<blockquote>
<p>根据公式我们知道<code>总共有16个顶点</code>。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/04/03/wBXchzVHDoWuJMF.png" alt="image-20220403104630619"></p>
</li>
<li><p>…</p>
</li>
</ul>
<p>综上，我们可以拓展到<code>单位n方体</code>的情况。</p>
</blockquote>
</blockquote>
<p>生成<code>只在1个二进制位上与n元组不同的其后继n元素</code>，对应着<code>沿着n方体的边，访问该n方体的每个顶点恰好一次</code>。</p>
<p><code>任何一个这样的遍历</code>称为<code>n阶Gray码</code></p>
<blockquote>
<p><code>n阶Gray码</code>即<code>哈密顿路径</code>，而<code>循环的n阶Gray码</code>即<code>哈密顿圈</code></p>
</blockquote>
<ul>
<li><p>初始化：从a_{n-1}a_{n-2}\cdots a_0 &#x3D; 00\cdots0开始</p>
</li>
<li><p>持续：当a_{n-1}a_{n-2}\cdots a_0 \ne 11\cdots1时</p>
<ol>
<li><p>计算\sigma(a_{n-1}a_{n-2}\cdots a_0) &#x3D; a_{n-1} + a_{n-2} + \cdots + a_0</p>
<ol>
<li>如果\sigma是偶数，则<code>翻转</code>a_0</li>
<li>否则，确定j使得：a_j &#x3D; 1 \and (\forall i \lt j, a_i &#x3D; 0)，<code>翻转</code>a_{j+1}</li>
</ol>
</li>
</ol>
</li>
<li><p>终止：我们得到<code>n阶反射Gray码</code></p>
</li>
</ul>
<blockquote>
<p>在码序表的位置在字典序表的位置</p>
</blockquote>
<h2 id="Generate-R-Element-Subsets"><a href="#Generate-R-Element-Subsets" class="headerlink" title="Generate R-Element Subsets"></a>Generate R-Element Subsets</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><blockquote>
<p>注： <code>集合中的元素</code>是<code>无序的</code>，但我们约定，按<code>严格递增顺序排列集合中的元素</code>，并将<code>集合中的元素</code>视为<code>字母</code>，使得<code>一个集合</code>形成<code>一个单词</code></p>
</blockquote>
<hr>
<p>已知<code>第一个r子集</code>是12\cdots r，而<code>最后一个r子集</code>是(n-r+1)(n-r+2)\cdots n</p>
<p>是以开始的最后子集是以开始的第一个子集</p>
<blockquote>
<p>\textcolor{red}{(n - r + k + 1) &#x3D; (n - (r - k)) + 1}</p>
<p>这因为如果<code>生成的r子集</code>a_1a_2\cdots a_r我们<code>已经确定以</code>a_1\cdots a_{k-1}a_{k}<code>开始的话</code>，则意味着<code>前k个字母已经确定</code>。</p>
<p>于是问题从<code>生成r子集</code>变为<code>生成r-k子集</code></p>
</blockquote>
<h3 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h3><h4 id="Dictionary-Generate-Method"><a href="#Dictionary-Generate-Method" class="headerlink" title="Dictionary Generate Method"></a>Dictionary Generate Method</h4><ul>
<li><p>初始化：从<code>r子集</code>a_1a_2\cdots a_r &#x3D; 12\cdots r开始</p>
</li>
<li><p>持续：当a_1a_2\cdots a_r \ne (n-r+1)(n-r+2)\cdots(n)时</p>
<ol>
<li><p>确定<code>最大的整数k</code>，使得\textcolor{blue}{a_k + 1 \le n}且\textcolor{blue}{a_k + 1 \notin \{a_1, a_2,\cdots,a_r\}}</p>
</li>
<li><p>使用<code>r子集</code>a_1\cdots a_{k-1}\textcolor{red}{\underbrace{(a_k + 1)(a_k + 2)\cdots(a_k + r - k + 1)}_{r-k+1 \ items}}替换a_1a_2\cdots a_r</p>
<blockquote>
<p>对于<code>生成r子集</code>，如果<code>已经确定以某k个元素作为开头</code>，则<code>剩下的元素的个数</code> 就是 \textcolor{red}{r - k + 1}</p>
<p>即(k) + (r-k) &#x3D; r</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<blockquote>
<p>再次强调我们的约定：<code>集合的元素</code>是<code>无序的</code>，但我们<code>按严格递增顺序</code>来<code>排列由集合的元素组成的单词</code></p>
<p>因此，<code>1256</code>和<code>1265</code>实际上是<code>同一个集合</code>，但我们仅选取<code>遵守严格升序的表示 1256</code></p>
</blockquote>
<h3 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h3><p>的子集出现在所有的子集的字典序中的位置下标</p>
<hr>
<p>计算出现在后面的子集的数目在的后面且以开始但第个元素比大的子集数目在的后面且以开始但第个元素比大的子集数目在的后面且以开始但第个元素比大的子集数目</p>
<h2 id="Partial-Ordering-Relation-and-Equivalence-Relation"><a href="#Partial-Ordering-Relation-and-Equivalence-Relation" class="headerlink" title="Partial Ordering Relation and Equivalence Relation"></a>Partial Ordering Relation and Equivalence Relation</h2><h3 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h3><p><code>集合X</code>上的<code>关系R</code>可能具有的一些特性的定义：</p>
<ul>
<li><p>自反性（Reflexive）：\forall x \in X, x R x</p>
</li>
<li><p>反自反性（Irreflexive）：\forall x \in X, x \cancel{R} x</p>
</li>
<li><p>对称性（Symmetric）：\forall x,y \in X, x R y \implies y R x</p>
</li>
<li><p>反对称性（Anti-symmetric）：\forall x,y, x \ne y, xRy \implies y \cancel{R} x</p>
<blockquote>
<p>注意：<code>反对称性</code>并不考虑<code>对角线上的取值情况</code></p>
</blockquote>
</li>
<li><p>传递性（Transitive）：\forall x,y,z, x R y, y R z \implies x R z</p>
</li>
</ul>
<h4 id="Partial-Ordering-Relation"><a href="#Partial-Ordering-Relation" class="headerlink" title="Partial Ordering Relation"></a>Partial Ordering Relation</h4><h5 id="Diagram-Hasse-Disgram"><a href="#Diagram-Hasse-Disgram" class="headerlink" title="Diagram: Hasse Disgram"></a>Diagram: Hasse Disgram</h5><p><code>偏序集</code>中<code>a被b覆盖</code>是指：a \lt_c b \iff \left\{\begin{aligned}&amp;a,b,c \in X \\ &amp;a \lt b \\ &amp;\nexists c, a \lt c \lt b \end{aligned}\right.</p>
<h5 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h5><h6 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory 1"></a>Theory 1</h6><blockquote>
<ul>
<li>Background</li>
</ul>
<p>如果<code>偏序集</code>(X, \le)的<code>集合X</code>中的每一对元素都是<code>可比的</code>，那么在集合X上的偏序R是<code>全序的</code></p>
<blockquote>
<p><code>全序集</code> 也称为<code>线性有序集</code>，因为我们可以把全序集进行<code>线性展开</code></p>
</blockquote>
</blockquote>
<p>设<code>集合X</code>是有n个元素的有限集。则<code>集合X上的全序</code>与<code>X的排列</code>之间存在一一对应。</p>
<p>而且，集合X上的全序的个数为<code>n!</code></p>
<hr>
<ul>
<li>Proof</li>
</ul>
<p>使用<code>归纳法</code>证明a_1,a_2\cdots,a_n是<code>X的元素的一个排列</code>，且a_1 \lt a_2 \lt a_3 \cdots a_n</p>
<blockquote>
<p>通过证明去除极小元a_1后仍满足假设，完成归纳。</p>
</blockquote>
<h6 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory 2"></a>Theory 2</h6><p>设(X, \le)是<code>有限偏序集</code>，则它有<code>线性拓展</code>。</p>
<hr>
<ul>
<li>Proof</li>
</ul>
<p>使用归纳法：每次从<code>偏序集</code>中<code>取出1个极小元</code>，将这些极小元按顺序排列即可得到一个线性拓展。</p>
<h4 id="Equivalence-Relation"><a href="#Equivalence-Relation" class="headerlink" title="Equivalence Relation"></a>Equivalence Relation</h4><h5 id="Diagram-Set-Partition-Chart"><a href="#Diagram-Set-Partition-Chart" class="headerlink" title="Diagram: Set Partition Chart"></a>Diagram: Set Partition Chart</h5><h5 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory"></a>Theory</h5><p>设<code>~</code>是<code>集合X</code>上的<code>等价关系</code>。不同的<code>等价类</code>把<code>集合X</code>划分成<code>若干非空的部分</code>。</p>
<p>反之，对于<code>任意把X分割成非空部分的划分</code>，存在<code>X上的等价关系</code>，它的<code>等价类</code>就是<code>这个划分的部分</code></p>
<hr>
<ul>
<li>Proof</li>
</ul>
<ol>
<li>证明<code>所有等价类的并集为X</code>：<code>X的每个元素都包含在一个等价类中</code>，Q.E.D</li>
<li>证明<code>两个不同的等价类之间不存在交集</code>：利用<code>等价关系的传递性</code>，Q.E.D</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/02/computer-composition-representation-and-computation-integer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/computer-composition-representation-and-computation-integer/" class="post-title-link" itemprop="url">Computer Composition - Representation and Computation – Integer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-02 20:11:49" itemprop="dateCreated datePublished" datetime="2022-04-02T20:11:49+00:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Representation-and-Computation-Integer"><a href="#Representation-and-Computation-Integer" class="headerlink" title="Representation and Computation - Integer"></a>Representation and Computation - Integer</h1><h2 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h2><h3 id="The-Representation-of-Integer"><a href="#The-Representation-of-Integer" class="headerlink" title="The Representation of Integer"></a>The Representation of Integer</h3><h4 id="Unsigned-Integer"><a href="#Unsigned-Integer" class="headerlink" title="Unsigned Integer"></a>Unsigned Integer</h4><blockquote>
<p>这是我们最常见的<code>整数表示法</code>，在<code>进制转换</code>中经常使用该等式作为<code>中介</code></p>
<p>由于是<code>无符号数</code>，我们并不需要考虑<code>负整数</code>的问题，该表示方式建立了一个<code>二进制位模式</code>和<code>十进制非负整数</code>之间的一个简单的双射：</p>
<p>因而，我们说<code>无符号数编码</code>具有<code>唯一性</code></p>
</blockquote>
<h4 id="Signed-Integer"><a href="#Signed-Integer" class="headerlink" title="Signed Integer"></a>Signed Integer</h4><h5 id="Tow’s-Complement-Method"><a href="#Tow’s-Complement-Method" class="headerlink" title="Tow’s Complement Method"></a>Tow’s Complement Method</h5><blockquote>
<p>大部分的机器采用<code>补码编码</code>, 补码的含义为：对于非负整数x，我们使用2^{w} - x<code>来计算-x的w位表示</code></p>
</blockquote>
<blockquote>
<p><code>补码编码</code>在<code>无符号数编码</code>的基础上，将<code>二进制位模式的最高位</code>作为<code>符号位</code>，权重为-2^{w-1}</p>
<blockquote>
<p>也可以把<code>补码编码</code>看成：将<code>无符号数编码</code>的<code>求和式最后一项 取相反数</code>从而得到。</p>
</blockquote>
<p>注意到，除了<code>最高位拥有一个非常大的负权重</code>之外，<code>二进制位模式中的其他位的权重均为 正权重</code>！</p>
<blockquote>
<p>进而我们可以表示的最小负数最小负数 &#x3D; UMin_w \dot{&#x3D;} [10\cdots0] &#x3D; (1)\times (-2^{w-1})，最大正数最大正数 &#x3D; UMax_w \dot{&#x3D;} [01\cdots111] &#x3D; \sum_{i&#x3D;0}^{w-2}{(1)\times2^i}</p>
<blockquote>
<p>注意这个表示范围，因为2^{n} - \sum_{i&#x3D;0}^{n-1}{2^i} &#x3D; 1 \implies TMin &#x3D; TMax + 1</p>
<p>准确地说，<code>补码编码</code>是将<code>整数</code>划分为<code>负数</code>和<code>非负数</code>。</p>
</blockquote>
<p>同理，<code>补码编码</code>也具有<code>唯一性</code></p>
</blockquote>
<blockquote>
<p>此外，我们还发现UMax_w &#x3D; 2TMax_w + 1</p>
<blockquote>
<p>证明：思路是让<code>等式两边的值相等</code>。</p>
<p>Q.E.D</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="Ones’-Complement"><a href="#Ones’-Complement" class="headerlink" title="Ones’ Complement"></a>Ones’ Complement</h5><blockquote>
<p><code>反码编码</code>与<code>补码编码</code>的区别在于，<code>反码编码最高位的权重</code>比<code>补码编码的最高位权重</code> <code>小1</code></p>
</blockquote>
<blockquote>
<p>反码表示的含义为：使用<code>[111...1] - 1</code>来表示<code>-x</code>的反码表示</p>
</blockquote>
<h5 id="Sign-Magnitude"><a href="#Sign-Magnitude" class="headerlink" title="Sign-Magnitude"></a>Sign-Magnitude</h5><blockquote>
<p><code>原码编码</code>与<code>补码编码</code>虽然都是<code>由最高位来决定符号</code>，但<code>原码编码的最高位</code>仅仅用于<code>表示正负</code>。</p>
<p>而且，我们注意到后面的\sum_{i&#x3D;0}^{w-1}{x_i2^i}部分<code>相等</code>，但由于<code>对负数的表示方法不同</code>。</p>
<p><code>原码编码的 正整数个数 = 负整数个数</code>，并且，<code>我们还发现表示0的位模式有两个： +0 和 -0</code></p>
<blockquote>
<p><code>多出来的一个0</code>是由<code>补码编码中的最小的负整数 的位模式</code>所得来的。</p>
<p>2^w &#x3D; \sum_{i&#x3D;0}^{w-1}{x_i2^i} + 1</p>
</blockquote>
</blockquote>
<h3 id="Coding-Conversion"><a href="#Coding-Conversion" class="headerlink" title="Coding Conversion"></a>Coding Conversion</h3><h4 id="T2U"><a href="#T2U" class="headerlink" title="T2U"></a>T2U</h4><hr>
<p><code>补码编码</code>和<code>无符号数编码</code>的区别在于<code>位模式的最高位的权重</code>。</p>
<p>因此，需要分情况考虑<code>x的补码编码表示下的位模式的最高位</code>：</p>
<ol>
<li><p>最高位 &#x3D; 0：即<code>x在补码编码下为非负整数，则可以直接转化为 无符号数编码的x</code></p>
<blockquote>
<p>因为<code>无符号数编码的非负整数的范围 &gt; 补码编码的非负整数的范围</code>，所以<code>当前的非负数必定可以被装下</code></p>
</blockquote>
</li>
<li><p>最高位 &#x3D; 1：即<code>x的补码编码下为负数</code>，则<code>在补码编码的表示下，最高位权重为</code>-2^{w-1}，<code>在无符号数的编码表示下，最高位的权重为</code>2^{w-1}。</p>
<p>因此，\Delta weight &#x3D; 2^{w-1} - (-2^{w-1} &#x3D; 2 * 2^{w-1} &#x3D; 2^w)</p>
</li>
</ol>
<p>综上，我们得出结论：B2U_w(T2B_w(x)) &#x3D; \textcolor{red}{T2U_w(x) &#x3D; x + x_{w-1} * 2^{w}}</p>
<blockquote>
<p>该结论表明，当<code>有符号数</code>(即用<code>补码编码</code>)被映射到<code>无符号数</code>（即用<code>无符号正数编码</code>）时，<code>负数</code>会被转化为<code>大的正数</code>，而<code>非负数</code>保持不变。</p>
</blockquote>
<h4 id="U2T"><a href="#U2T" class="headerlink" title="U2T"></a>U2T</h4><hr>
<p><code>Unsigned Integer</code>和<code>Two&#39;s Complement</code>的区别就在于<code>位模式的最高位</code>，而<code>除了最高的其他w-1位所表示的权重是一样的</code></p>
<p>因此，我们仍然需要从<code>位模式的最高位 的取值情况 来考虑</code>：</p>
<ol>
<li><p>x_{w-1} &#x3D; 0 \implies u \le TMax_w：在这种情况下，<code>无符号数编码</code>和<code>补码编码</code>所表示的含义就是一样的了。</p>
</li>
<li><p>x_{w-1} &#x3D; 1 \implies u \gt TMax_w：对于<code>位模式的最高位为1</code>的情况。</p>
<blockquote>
<p>转换后位模式的最高位的权重转换前位模式的最高位的权重</p>
</blockquote>
</li>
</ol>
<p>我们可以得出结论：\textcolor{red}{U2T_w(u) &#x3D; u -u_{w-1} \times 2^{w}}</p>
<blockquote>
<p>与<code>有符号数</code>和<code>无符号数</code>转换相关的结论：</p>
<p>UMax_w &#x3D; 2TMax_w+ 1</p>
</blockquote>
<p>综上，Q.E.D</p>
<h3 id="Extend-Bit-Mode"><a href="#Extend-Bit-Mode" class="headerlink" title="Extend Bit Mode"></a>Extend Bit Mode</h3><p>当在<code>不同字长的证整数</code>之间进行<code>转换</code>，同时又想<code>保持数值不变</code>时。</p>
<p>显然，我们只可能<code>从较小的数据类型 -&gt; 较大的数据类型</code></p>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><h5 id="Zero-Extension"><a href="#Zero-Extension" class="headerlink" title="Zero Extension"></a>Zero Extension</h5><p>无符号数的零拓展</p>
<h5 id="Sign-Extension"><a href="#Sign-Extension" class="headerlink" title="Sign Extension"></a>Sign Extension</h5><p>在需要将<code>补码数字</code>转化为<code>一个更大的数据类型</code>且<code>保持数值不变</code>时，可使用<code>符号拓展</code>。</p>
<blockquote>
<p>也就是说：我们可以将<code>较小的补码数字表示</code> <code>拓展到较大的补码数字表示</code>并且<code>保持数值不变</code></p>
</blockquote>
<p>补码数的符号拓展</p>
<hr>
<p>由于x_0,\cdots,x_{w-2},x_{w-1}<code>的部分在补码编码下的拓展前后的前后的权重 相等</code>。</p>
<p>故接下来我们只需要证明，我们<code>为</code>\vec{x}’<code>拓展的位的权重的累加 = 0</code>。</p>
<p>但为了证明的简单，我们使用<code>归纳法</code>：仅证明<code>符号拓展了1位的补码编码的数值 不会发生改变</code>，进而<code>得出对补码编码符号拓展任意多位，数值也不会改变</code></p>
<p>分类讨论x_{w-1}的取值</p>
<ol>
<li>x_{w-1} &#x3D; 0：显然成立</li>
<li>x_{w-1} \ne 0：</li>
</ol>
<p>Q.E.D</p>
<blockquote>
<p>蓝色部分：先考虑从\vec{x}和\vec{x}’的x_{w-1}，当<code>位数拓展1位后，拓展前后的第w-1位的含义就不同了</code></p>
<p>红色部分：这部分是多出来的，可以直接相加即可。<code>第w位的值</code>为 x_{w-1}，权重为-2^{w}</p>
</blockquote>
<blockquote>
<p>另一种观点是：2^w - 2^{w-1} &#x3D; 2^{w-1}</p>
<p>即<code>加上一个权为-2^w的位</code> &#x3D; <code>将一个权为-2^&#123;w-1&#125;的位 转换为 权为2^&#123;w-1&#125;</code></p>
<blockquote>
<p>PROOF</p>
<ol>
<li>如果权重前的系数&#x3D;0，则显然成立</li>
<li>如果权重前的系数≠0，则 ((2^{w-1}) - (-2^{w-1})) + (-2^w) &#x3D; 0</li>
</ol>
</blockquote>
</blockquote>
<h3 id="Truncate-Integer"><a href="#Truncate-Integer" class="headerlink" title="Truncate Integer"></a>Truncate Integer</h3><p><code>截断</code>发生在<code>较大的数据类型 -&gt; 较小的数据类型</code></p>
<h4 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h4><h5 id="Truncate-Unsigned-Integer"><a href="#Truncate-Unsigned-Integer" class="headerlink" title="Truncate Unsigned Integer"></a>Truncate Unsigned Integer</h5><p>截断无符号数</p>
<hr>
<p>对于<code>无符号数编码</code> ：i \in N, weight(x_i) &#x3D; 2^i</p>
<p>分别计算<code>等式左侧</code>和<code>等式右侧</code></p>
<p>B2U_w(\vec{x}) &#x3D; \sum_{i&#x3D;0}^w x_i 2^i</p>
<p>B2U_k(\vec{x}’) &#x3D; \sum_{i&#x3D;0}^{k}{x_i2^i}</p>
<blockquote>
<p><code>所有被截去的位的重数都是</code>2^i, i \ge k 因此<code>这些权在 取模操作 下都变为0</code></p>
<p>也就是说：<code>取模操作</code>\mod 2^k可以使得weight(x_i) &#x3D; 0, i \ge k</p>
</blockquote>
<p>Q.E.D</p>
<h5 id="Truncate-Two’s-Complement-Integer"><a href="#Truncate-Two’s-Complement-Integer" class="headerlink" title="Truncate Two’s Complement Integer"></a>Truncate Two’s Complement Integer</h5><p>截断补码数</p>
<hr>
<blockquote>
<p>0 \le x \mod 2^k \le 2^k - 1 等效于<code>将最高有效位</code>x_{k-1}<code>的权重 从</code>2^{k-1}<code>转换到</code>-2^{k-1}</p>
<blockquote>
<p>注：<code>在对最高位k进行</code>\mod 2^k<code>操作之前，如果</code>x_k &#x3D; 1<code>则我们当然可以 加权</code>2^{k-1}，<code>但是，在进行 取模操作后，即使</code>x_k &#x3D; 1<code>，则在取模运算后，我们加权+0</code></p>
<ul>
<li>如果x_k &#x3D; 0，那么<code>权重转换的等效性 显然成立</code>。</li>
<li>如果x_k &#x3D; 1，则<code>在取模运算后，相当于 最高位是废的，本应当加权</code>2^{k-1}<code>实际却只加权</code>+0。这<code>等价于我们损失了</code>2^{k-1}<code>数量的权</code>（即实际加权为-2^{k-1}）</li>
</ul>
</blockquote>
</blockquote>
<p>Q.E.D</p>
<h2 id="Computation"><a href="#Computation" class="headerlink" title="Computation"></a>Computation</h2><h3 id="Unsigned-Addition"><a href="#Unsigned-Addition" class="headerlink" title="Unsigned Addition"></a>Unsigned Addition</h3><p>无符号数加法</p>
<p>如果sum &#x3D; x+y \lt 2^w，则sum_{w+1} &#x3D; 0<code>该位被丢弃不会影响数值</code></p>
<p>如果sum &#x3D; x + y \ge 2^w，则sum_{w+1} &#x3D; 1<code>该位被丢弃会影响数值</code>，<code>丢弃该位最高位</code>=<code>数值减少</code>2^w</p>
<hr>
<h4 id="Overflow-Detection"><a href="#Overflow-Detection" class="headerlink" title="Overflow Detection"></a>Overflow Detection</h4><p>溢出检测</p>
<h4 id="Unsigned-for-Non"><a href="#Unsigned-for-Non" class="headerlink" title="Unsigned for Non"></a>Unsigned for Non</h4><p>无符号数求反</p>
<blockquote>
<p>注：上面的<code>-号</code>并不是<code>减号</code>，而是表示<code>求逆元</code></p>
</blockquote>
<blockquote>
<p>根据<code>模数加法（阿贝尔群 Abelian Group）</code>：对于_w^ux \implies \exists -_w^ux, -_w^ux + _w^ux &#x3D; 0</p>
</blockquote>
<hr>
<ol>
<li>当x &#x3D; 0时，<code>加法逆元</code>即为<code>0</code></li>
<li>当x &gt; 0时，<code>考虑</code>2^w - x，有0 \lt 2^w - x \lt 2^w 且(x + \textcolor{hotpink}{(2^w - x)}) \mod 2^w &#x3D; 2^w \mod 2^w &#x3D; 0。故2^w-x是_w^u+下的<code>加法逆元</code></li>
</ol>
<h3 id="Tow’s-Complement-Addition"><a href="#Tow’s-Complement-Addition" class="headerlink" title="Tow’s Complement Addition"></a>Tow’s Complement Addition</h3><p>补码加法</p>
<blockquote>
<p>上述式子告诉我们，<code>补码加法</code>和<code>无符号加法</code>之间有<code>完全相同的位级表示</code>。</p>
<p>所以，对于+_w^t运算：可以先将参数转化为<code>无符号数</code>，执行<code>无符号加法</code>，然后再将结果转化为<code>补码</code>：</p>
</blockquote>
<hr>
<p><img src="https://s2.loli.net/2022/04/02/x6RhgBImwsWEuLl.png" alt="image-20220402193536399"></p>
<h4 id="Overflow-Detection-for-Two’s-Complement-Addition"><a href="#Overflow-Detection-for-Two’s-Complement-Addition" class="headerlink" title="Overflow Detection for Two’s Complement Addition"></a>Overflow Detection for Two’s Complement Addition</h4><p>补法加法的溢出检测</p>
<h3 id="Two’s-Complement-for-Non"><a href="#Two’s-Complement-for-Non" class="headerlink" title="Two’s Complement for Non"></a>Two’s Complement for Non</h3><p>补法求非</p>
<hr>
<p>TMin_w + TMin_w &#x3D; -2^{w-1} + (-2^{w-1}) &#x3D; -2^w \implies \text{Negative Overflow}</p>
<p>\therefore TMin_w + _w^tTMin_w &#x3D; -2^w \textcolor{red}{\underbrace{+ 2^w}_{\text{Negative Overflow}}}&#x3D; 0</p>
<p>\because\forall x \gt TMin_w, -x + x &#x3D; 0</p>
<p>Q.E.D</p>
<h3 id="Unsigned-Multiplication"><a href="#Unsigned-Multiplication" class="headerlink" title="Unsigned Multiplication"></a>Unsigned Multiplication</h3><p>无符号数乘法</p>
<h3 id="Two’s-Multiplication"><a href="#Two’s-Multiplication" class="headerlink" title="Two’s Multiplication"></a>Two’s Multiplication</h3><p>对于-2^{w-1} \le x,y \le 2^{w-1} -1内的整数x和y可以被表示为<code>w位的补码数字</code>。</p>
<p>但（-2^{w-1} \cdot （2^{w-1} - 1) &#x3D; -2^{w-1} \cdot -2^{w-1} &#x3D; -2^{2w-2} \implies -2^{2w-2} \le x \cdot _w^ty \le -2^{2w-2}</p>
<p>对于C语言的有符号数乘法，是<code>通过将2w位的乘积 截断为 w位</code>来实现的。</p>
<p>补码乘法</p>
<hr>
<p><code>无符号数乘法</code>和<code>补法乘法</code>在<code>位级表示</code>具有<code>等价性</code></p>
<blockquote>
<p>补码乘法和无符号数乘法的等价性</p>
</blockquote>
<h3 id="Multiply-by-a-Constant"><a href="#Multiply-by-a-Constant" class="headerlink" title="Multiply by a Constant"></a>Multiply by a Constant</h3><p>无符号数乘以的幂</p>
<p>与的幂相乘的无符号乘法逻辑左移</p>
<p>与的幂相乘的补码乘法逻辑左移</p>
<blockquote>
<p>无论x是<code>无符号编码</code>还是<code>补码编码</code>，<code>移位运算</code>所产生的结果<code>与乘法运算</code>相同。</p>
</blockquote>
<h3 id="Divided-by-a-Constant"><a href="#Divided-by-a-Constant" class="headerlink" title="Divided by a Constant"></a>Divided by a Constant</h3><p>除以的幂相除的无符号除法逻辑右移</p>
<p>除以的幂相除的补码除法算术右移向下舍入</p>
<blockquote>
<p>上式告诉我们，当<code>除法运算不需要舍入时</code>，它的效果和<code>算术右移</code>是一样的。</p>
<p>但若<code>存在舍入</code>时将会<code>向下舍入</code>，导致<code>算术右移的结果</code>与<code>除法运算</code>有<code>偏差</code></p>
<blockquote>
<p>我们可以通过<code>在移位前进行偏置 (Biasing)</code>来修复这种偏差。</p>
</blockquote>
</blockquote>
<p>除以的幂的补码除法算术右移向上舍入</p>
<blockquote>
<p>原理：\lceil x&#x2F;y \rceil &#x3D; \lfloor(x\textcolor{blue}{+y-1})&#x2F;y \rfloor</p>
<p>证明</p>
<p>采用修复算术右移默认的向下舍入误差</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/02/computer-composition-representation-and-computation-floating-point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/computer-composition-representation-and-computation-floating-point/" class="post-title-link" itemprop="url">Computer Composition - Representation and Computation - Floating Point</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-02 18:02:30" itemprop="dateCreated datePublished" datetime="2022-04-02T18:02:30+00:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Representation-and-Computation-Floating-Point"><a href="#Representation-and-Computation-Floating-Point" class="headerlink" title="Representation and Computation - Floating Point"></a>Representation and Computation - Floating Point</h1><h2 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h2><p><code>浮点表示</code>对形如V &#x3D; x \times 2^y的有理数进行编码。</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><h4 id="Decimal-Representation"><a href="#Decimal-Representation" class="headerlink" title="Decimal Representation"></a>Decimal Representation</h4><p>d &#x3D; d_md_{m-1}\cdots d_0.d_{-1}d_{-2}\cdots d_{-n} &#x3D; \sum_{i &#x3D; -n}^{m}{10^i \times d_i}</p>
<h4 id="Binary-Representation"><a href="#Binary-Representation" class="headerlink" title="Binary Representation"></a>Binary Representation</h4><p>b &#x3D; b_mb_{m-1}\cdots b_0.b_{-1}b_{-2}\cdots b_{-n} &#x3D; \sum_{i&#x3D;-n}^{m}{2^i \times b_i}</p>
<h4 id="IEEE-754-Floating-Point-Representation"><a href="#IEEE-754-Floating-Point-Representation" class="headerlink" title="IEEE 754 Floating Point Representation"></a>IEEE 754 Floating Point Representation</h4><h5 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h5><p>\textcolor{red}{V &#x3D; (-1)^s \times M \times 2^E}</p>
<ul>
<li>符号（Sign）：正数为0，负数为1。对于<code>数值0</code>，符号位另外做解释。</li>
<li>尾数（Significand）：<code>尾数M</code>是<code>二进制小数</code>。范围为<code>1~2-ε</code>或<code>0~1-ε</code></li>
<li>阶码（Exponent）：<code>阶码E</code>的作用是<code>对浮点数进行加权</code></li>
</ul>
<h5 id="Formats"><a href="#Formats" class="headerlink" title="Formats"></a>Formats</h5><p><img src="https://s2.loli.net/2022/04/02/DAQOaC8PEtZXiuT.png" alt="image-20220402161750736"></p>
<p>该表示方法将<code>位模式</code>分为<code>3个字段</code>：</p>
<ol>
<li><p>符号字段 (s)：1表示正数，0表示负数</p>
</li>
<li><p>阶码字段 (exp)：exp用于<code>编码</code> <code>阶码E</code></p>
<blockquote>
<p>注意：这并不是说<code>阶码E 的数值</code>直接等于<code>exp的数值</code>，而是需要通过一定的编码规则。</p>
</blockquote>
</li>
<li><p>小数字段 (frac)：frac用于<code>编码</code> <code>尾数M</code></p>
</li>
</ol>
<h5 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h5><p><img src="https://s2.loli.net/2022/04/02/UqL3ZGsMOSyFQK6.png" alt="image-20220402162120226"></p>
<hr>
<ul>
<li>情况1：规格化的值</li>
</ul>
<p><code>阶码字段</code>：E &#x3D; e - Bias &#x3D; e - (2^{k-1} -1)</p>
<p><code>小数字段</code>：0 \le f \lt 1, f &#x3D; [0.f_{n-1}f_{n-2}\cdots f_0]</p>
<blockquote>
<p>尾数尾数 M \dot{&#x3D;} 1 + f &#x3D; \textcolor{red}{1}.f_{n-1}f_{n-2}\cdots f_0</p>
<blockquote>
<p>它必然是以1开头的，所以我们也称这种方式为<code>隐含的以1开头的表示 (Implied Leading 1)</code>。</p>
<p>因为我们总是可以通过<code>调整阶码E</code>使得1 \le M \lt 2（假设没溢出），则我们可以知道，<code>第一位必定是1</code>，</p>
<p>因此我们不需要存储该位，从而获得<code>多一位的精度</code>。</p>
</blockquote>
</blockquote>
<ul>
<li>情况2：非规格化的值</li>
</ul>
<p><code>阶码字段</code>：E &#x3D; 1 - Bias &#x3D; 1 - (2^{k-1} - 1)</p>
<blockquote>
<p>通过定义<code>非规格化的值的E = 1 - Bias</code>而不是<code>E = -Bias</code>，则我们可以非常方便地进行<code>非规格化 → 规格化</code>的过程。</p>
<blockquote>
<p>这样可以<code>补偿非规格化的数的尾数M 所没有的隐含的开头的1</code></p>
</blockquote>
</blockquote>
<p><code>小数字段</code>：此时M &#x3D; f，此时<code>小数的值</code>等于<code>尾数的值</code>，尾数不包含开头隐含的1.</p>
<ul>
<li><p>情况3：特殊值</p>
<ul>
<li>正负无穷大：当s&#x3D;1时为<code>正无穷大</code>， 当s&#x3D;0时为<code>负无穷大</code>。无穷大用于表示<code>溢出</code></li>
<li>非数字</li>
</ul>
</li>
</ul>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://s2.loli.net/2022/04/02/rYVS5tHciEzM943.png" alt="image-20220402173123914"></p>
<h2 id="Rounding"><a href="#Rounding" class="headerlink" title="Rounding"></a>Rounding</h2><p>由于<code>浮点数</code>只能<code>近似地</code>表示<code>实数</code>，因此，我们希望对于某个实数，可以找到<code>最接近的匹配值</code>来近似它，</p>
<p>并用浮点格式表示出来，这就是<code>舍入 (Rounding)</code> 。</p>
<h3 id="Strategies"><a href="#Strategies" class="headerlink" title="Strategies"></a>Strategies</h3><h4 id="Rount-Down"><a href="#Rount-Down" class="headerlink" title="Rount Down"></a>Rount Down</h4><p>\lfloor x \rfloor</p>
<h4 id="Rount-Up"><a href="#Rount-Up" class="headerlink" title="Rount Up"></a>Rount Up</h4><p>\lceil x \rceil</p>
<h4 id="Rount-towards-Zero"><a href="#Rount-towards-Zero" class="headerlink" title="Rount towards Zero"></a>Rount towards Zero</h4><blockquote>
<p><code>向零舍入</code>和<code>向下舍入</code>在处理<code>负数</code>时会有不同。</p>
</blockquote>
<h4 id="Rount-to-Even-Round-to-Nearest"><a href="#Rount-to-Even-Round-to-Nearest" class="headerlink" title="Rount to Even (Round to Nearest)"></a>Rount to Even (Round to Nearest)</h4><p><code>向偶数舍入 （向最接近的值舍入）</code>是<code>默认的舍入策略</code>：它将<code>数字</code>进行<code>向上舍入</code>或<code>向下舍入</code>，使得<code>结果的最低有效位的数字</code>是<code>偶数</code></p>
<blockquote>
<p>该方法期望于<code>最低有效位的二进制位</code>在<code>50%的情况为0，而另外50%的情况为1</code>，进而使得计算结果对<code>统计数据</code>更为友好。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/04/02/2VWkT5acCMGZDnL.png" alt="image-20220402174325557"></p>
<h2 id="Computation"><a href="#Computation" class="headerlink" title="Computation"></a>Computation</h2><p><code>IEEE标准</code>将<code>浮点数</code>视为<code>实数</code>，而<code>某个运算</code>\odot定义在实数上，计算产生Round(x \odot y)是对<code>实际运算的精确结果</code>的<code>舍入</code></p>
<blockquote>
<p>因为<code>舍入</code>和<code>溢出</code>的存在，<code>浮点运算</code>的精度会比<code>整数运算</code>更容易受影响，而且不遵守普通的算术属性（如结合性）。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/01/counting-system-of-distinct-representative/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/counting-system-of-distinct-representative/" class="post-title-link" itemprop="url">Combinatorics - System of Distinct Representative</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-01 10:42:36" itemprop="dateCreated datePublished" datetime="2022-04-01T10:42:36+00:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="System-of-Distinct-Representative"><a href="#System-of-Distinct-Representative" class="headerlink" title="System of Distinct Representative"></a>System of Distinct Representative</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>设<code>Y是有限集合</code>。而\mathcal{A} &#x3D; (A_1, A_2, \cdots, A_n)是Y的n个<code>子集族</code>。</p>
<blockquote>
<p><code>族 (Family)</code>是<code>序列</code>，<code>子集族</code>即<code>子集的序列</code>，只不过这个序列的每个项不是<code>数字</code>而是<code>集合</code>，因而<code>序列</code>中可以有<code>相同的项</code>。</p>
</blockquote>
<blockquote>
<p>可以将<code>集合Y</code>当成<code>资源集合</code>，而<code>子集族</code>\mathcal{A}即为<code>对象族</code>，它的每个项是一个<code>对象（或者说：是该对象所需要的资源的集合）</code></p>
</blockquote>
<p>如果<code>Y的元素的一个族</code>(e_1,e_2,\cdots,e_n)满足e_1 \in A_1, e_2 \in A_2, \cdots, e_i \in A_i，则称它为\mathcal{A}的一个<code>代表系 (System of Representative)</code></p>
<p>在一个代表系中，若e_i \in A_i，则该元素e_i称为A_i的<code>代表</code></p>
<blockquote>
<p><code>代表</code>的英文是从<code>Representative</code>翻译而来的，但是后面我们会使用<code>代表元</code>而不是<code>代表</code>，因为<code>代表元</code>这个词可以使表达更准确。</p>
</blockquote>
<blockquote>
<p>也就是说，<code>只要能从某个集合中选出1个元素，那么这个元素就可以称为 该集合的代表元</code>。</p>
<p>进而，我们知道，<code>非空集合的族 必定存在 代表系， 但不一定存在SDR</code></p>
</blockquote>
<p>如果在一个<code>代表系</code>中，元素e_i都是不同的，则称(e_1, e_2, \cdots, e_n)为<code>相异代表系 (System of Distinct Representative)</code></p>
<blockquote>
<p>注意：即使A_1和A_2是<code>相同的集合</code>，他们在<code>SDR</code>中也必须要有<code>不同的代表元</code>，因为他们是<code>这个族的不同项</code>。</p>
</blockquote>
<blockquote>
<p>换句话说：在<code>代表系</code>中，<code>1个代表元 可以代表 多个集合</code>，而在<code>相异代表系</code>中，<code>1个代表元 只能代表 1个集合</code></p>
</blockquote>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>设\mathcal{A}&#x3D;(A_1,A_2,\cdots,A_n)<code>有限集合Y的子集族</code>，则需要解决的问题是：</p>
<ol>
<li>确定\mathcal{A}什么时候存在<code>SDR</code> ?</li>
<li>如果\mathcal{A}不存在<code>SDR</code>，<code>存在SDR的子族</code>\mathcal{A}(i_1, i_2, \cdots, i_t) &#x3D; (A_{i_1}, A_{i_2}, \cdots, A_{i_t})<code>中的t最大为多少?</code></li>
</ol>
<h3 id="Application-Non-Attack-Rooks-Problem"><a href="#Application-Non-Attack-Rooks-Problem" class="headerlink" title="Application: Non-Attack Rooks Problem"></a>Application: Non-Attack Rooks Problem</h3><p>能够将<code>k个非攻击型车</code>放置到<code>棋盘</code>上，当且仅当，<code>存在 有SDR的k个集合的子族</code>\mathcal{A}(i_1,i_2,\cdots,i_k) &#x3D; (A_{i_1}, A_{i_2}, \cdots, A_{i_k}) \qquad(1 \le i_1 \le i_2 \cdots \le i_k \le \text{Rows of the Board})</p>
<h3 id="Application-Checkerboard-Covering-Problem"><a href="#Application-Checkerboard-Covering-Problem" class="headerlink" title="Application: Checkerboard Covering Problem"></a>Application: Checkerboard Covering Problem</h3><p>能够将<code>k个不重叠的多米诺骨牌</code>放置到<code>棋盘</code>上，当且仅当，<code>存在 有SDR的k个集合的子族</code>\mathcal{A}(i_1, i_2, \cdots, i_k) &#x3D; (A_{i_1}, A_{i_2}, \cdots, A_{i_k}) \qquad (1 \le i_1 \le i_2 \cdots \le i_k \le \text{Black Squares})</p>
<blockquote>
<p>上述中的<code>Black Square</code>表示<code>棋盘上黑格的数量</code>，这是因为我们这里是将<code>黑格</code>视为<code>对象</code>来考虑的，所以<code>子集族的大小 = 黑格的数量</code>。</p>
<p>同理，也可以将<code>白格</code>视为<code>对象</code>。</p>
</blockquote>
<h3 id="Application-Complete-Marriage-Problem"><a href="#Application-Complete-Marriage-Problem" class="headerlink" title="Application: Complete Marriage Problem"></a>Application: Complete Marriage Problem</h3><p>有<code>n位女士</code>和<code>n位男士</code>，我们希望<code>配对每一位男士和女士</code>，并<code>使得配对给男士的女士 是 该男士的所偏爱的</code>。</p>
<p>则<code>所有的男士能够结婚</code>对应于(A_1, A_2, \cdots, A_n)<code>存在一个SDR</code>(w_1, w_2, \cdots, w_n)</p>
<h3 id="Application-Stable-Complete-Marriage-Problem"><a href="#Application-Stable-Complete-Marriage-Problem" class="headerlink" title="Application: Stable Complete Marriage Problem"></a>Application: Stable Complete Marriage Problem</h3><h4 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h4><p>在一个社区中有<code>n位男士</code>和<code>n位女士</code>。<code>每位女士</code> 按照 <code>其对每位男士作为配偶的偏爱程度</code>来<code>给每位男士进行排名</code>（不允许有并列排名），这样<code>每位女士</code>将<code>这些男士</code>排成<code>顺序1,2, ..., n</code>。类似地，<code>每位男士</code>也将<code>每位女士</code>排成<code>顺序1,2, ... n</code>。</p>
<blockquote>
<p>也就是说：<code>每名男士和每名女士</code>对<code>所有的异性进行排名排名 且 不存在并列排名</code></p>
</blockquote>
<blockquote>
<p>我们使用<code>优先排名矩阵 (Preferential Ranking Matrix)</code>来描述<code>男士</code>和<code>女士</code>对<code>每一个异性的偏爱程度</code>，</p>
<p>这是一张<code>二维表格</code>，每个<code>单元格</code>表示的是<code>第i个男士和第j个女士</code>之间：<code>第i个男士 对 第j个女士 的排名</code>和<code>第j个女士 对 第i个男士的排名</code> 所组成的<code>二元组</code></p>
</blockquote>
<hr>
<p>如果存在<code>两位女士 A 和 B</code>以及<code>两位男士 a 和 b</code>，使得：</p>
<ol>
<li>A和a结婚</li>
<li>B和b结婚</li>
<li>A更偏爱b（而非a）</li>
<li>b更偏爱A（而非B）</li>
</ol>
<blockquote>
<p>也就是说：如果存在一男一女，他们都不喜欢自己现在的配偶，而且这两个人之间相互喜欢。那么该婚姻的配对就是<code>不稳定婚姻</code></p>
</blockquote>
<p>则我们称该婚姻为<code>不稳定婚姻 (Unstable Marriage)</code>，而我们定义<code>稳定婚姻 (Stable Marriage)</code>：是那些非<code>不稳定婚姻</code>的婚姻</p>
<h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><h5 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h5><h6 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h6><p>对于<code>任何一个优先排名矩阵</code>，总是存在<code>稳定的完美婚姻</code>。</p>
<h6 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h6><h6 id="延迟认可算法-Deferred-Acceptance-Algorithm-x2F-Gale-Shapley-Algorithm"><a href="#延迟认可算法-Deferred-Acceptance-Algorithm-x2F-Gale-Shapley-Algorithm" class="headerlink" title="延迟认可算法 (Deferred Acceptance Algorithm &#x2F; Gale-Shapley Algorithm)"></a>延迟认可算法 (Deferred Acceptance Algorithm &#x2F; Gale-Shapley Algorithm)</h6><ol>
<li><p>初始化：将<code>每一位女士</code>标记为<code>被拒绝</code></p>
</li>
<li><p>持续：当<code>存在 被拒绝的女士 时</code>，执行：</p>
<ol>
<li><code>每一位被标记为被拒绝的女士</code>在<code>所有尚未拒绝它的男士</code>之中<code>选择一位被她排名最高的男士</code></li>
<li><code>每一位男士</code>在<code>所有选择他 并且 尚未被他拒绝的女士</code>之中<code>选择一位被他排名最高的女士</code>，<code>对她做延迟决定（即：移除该女士的拒绝状态）</code>并且<code>拒绝其他所有的女士</code></li>
</ol>
</li>
<li><p>终止：我们得到一个<code>稳定的完美婚姻</code></p>
</li>
</ol>
<hr>
<p>在算法的执行期间，<code>女士</code>向<code>男士</code>进行<code>求婚</code>，而男士可以接受女士的<code>订婚</code>（即做<code>延迟决定</code>）和<code>拒绝</code>女士。</p>
<ul>
<li>一旦男士订婚，则<code>该男士</code> <code>始终保持 订婚状态</code></li>
<li>如果男士收到<code>更好的女士的求婚</code>，则该男士可以<code>改变未婚妻</code> <code>拒绝</code> <code>他之前的未婚妻（如果有的话）</code>。</li>
<li>女士可以对不同的男士进行多次<code>求婚</code>，但<code>每次求婚的对象</code>只会<code>比上一次求婚的对象</code> <code>更差</code></li>
</ul>
<hr>
<p><code>证明：该算法所得的完美婚姻是稳定的完美婚姻</code></p>
<p><code>假设</code>： <code>女士A和B</code>以及<code>男士a和b</code>，使<code>A和a配对，B和b配对</code>，但<code>A更偏爱b</code>。</p>
<p>我们<code>证明</code>：不存在<code>b更偏爱A</code></p>
<p>在算法过程中，<code>A和B</code> <code>都向所有的男士进行了</code> <code>求婚</code>。如果<code>A更偏爱b</code>而<code>最终却是 A和a配对</code>，则说明<code>A在第一轮向b求婚时 被b拒绝了</code>，这是因为<code>b也收到B的求婚，显然b更偏爱B</code></p>
<blockquote>
<p>可以直接使用<code>反证法</code>：如果<code>A更偏爱b</code>而且<code>b更偏爱A</code>，那么<code>没有任何其他的男士或女士</code>可以<code>阻止A和b的配对</code>。因为<code>A会在第一轮中立即向b求婚</code>，而<code>b也会立即接受A的求婚，并且，后续任何其他女士的求婚都不会动摇b的订婚</code>。</p>
<p>因此，我们可以说：<code>如果存在一个男士和一个女士，他们互相为最喜欢对方，则他们最终必定成为一对</code></p>
</blockquote>
<p>Q.E.D</p>
<hr>
<h5 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h5><h6 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h6><blockquote>
<p><code>对该女士最优的稳定的完美婚姻</code>：<code>该女士得到的配偶的排名</code> <code>至少不差于</code> 从<code>其他的完美婚姻中得到的配偶的排名</code></p>
<p><code>女士最优的稳定的完美婚姻</code>：如果<code>一个稳定的完美婚姻</code>对于<code>每一位女士而言，都是最优的</code>。</p>
</blockquote>
<p>通过<code>延迟认可算法</code>，用<code>女士主动求婚的方式</code>来得到的<code>稳定的完美婚姻</code>是<code>女士最优的</code>。</p>
<h6 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h6><p>通过<code>女士主动求婚的方式</code>，<code>女士</code>可以<code>在每一轮中不断地尝试 从尚未拒绝她的男士中选择她最偏爱的男士 来进行求婚</code>。</p>
<p>而<code>最终与该女士配对的男士</code>将是<code>该女士所能配对的男士中她最偏爱的男士</code>。</p>
<blockquote>
<p>这种方式中，<code>每一位女士</code>都会获得<code>一位对她来说合适的男士</code>（尽管<code>这个男士可能不是该女士的排名中最高的）</code>。</p>
<p>我们无法<code>满足让每一位女士都获得 她的排名中的最高的男士</code> （如果无法通过该方法达成的话），否则<code>将导致得到的完美婚姻 是 不稳定的</code>。</p>
<p>回到之前的结论：<code>如果男士A和女士B之间互相是最偏爱的，则他们最终肯定能配对在一起</code>，<code>否则，说明 男士A 不是偏爱 女士B（如果女士B向男士A求婚，说明男士A是该女士 未拒绝该女士的男士中排名最高的男士）</code>，我们不妨<code>假设 男士A 和 女士C 配对在一起，则说明 男士A更偏爱女士C， 而男士A也是未拒绝女士C的所有男士中女士C所最偏爱的。</code>因此，<code>如果我们强行让 男士A 和 女士 B进行配对，则导致 男士A和女士C之间 不满足稳定的完美婚姻的定义</code></p>
<blockquote>
<p>注：<code>男士A 更偏爱 女士C</code>，则说明<code>女士C 是 向男士A求婚的所有女士中被男士排名最高的女士</code>。（如果<code>女士C</code>并不是<code>男士A对所有女士的排名中最高的女士</code>，则说明，<code>在男士A对所有女士的排名中 比 该女士C所处的排名更高的 哪些女士</code> <code>早已向其他的这些女士更偏爱的男士 进行求婚，而且，已经被接受了！（否则这些女士会来找男士A，然后男士A肯定会比偏爱女士C来说更偏爱这些女士）</code> ）</p>
</blockquote>
</blockquote>
<h5 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h5><h6 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h6><p>在<code>女士最优的稳定的完美婚姻</code>中，<code>每一位男士</code>与<code>一位他在稳定的完美婚姻中所有对他合适的伴侣</code>中<code>排名最低的女士</code>进行<code>结合</code></p>
<h6 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h6><p>如果在<code>该女士最优的稳定的完美婚姻</code>中，<code>男士A 和 女士B 配对</code>，<code>男士C 和 女士D 配对</code></p>
<p>则说明<code>男士A 是对女士B来说最合适的（也就是：男士A是 所有的没有拒绝女士B的男士中的被女性B排名最高的男士）</code></p>
<p>则说明<code>男士C 是对女士D来说最合适的</code></p>
<p>如果我们让<code>男士A 和 女士D 进行配对</code>，则<code>该稳定的完美婚姻 不是对 女士D 最优的，因而这个稳定的完美婚姻 根本就不是 女士最优的</code></p>
<h2 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h2><h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><p><code>族</code>\mathcal{A} &#x3D; {A_1, A_2,\cdots,A_n}<code>存在SDR的必要条件是</code> <code>婚姻条件 (Marrige Condition)</code>：对于<code>每一个 k = 1, 2, ..., n</code>和<code>取自于&#123;1,2, ..., n&#125;的下标</code>i_1, i_2, \cdots, i_k的<code>每一种选择</code>，应满足</p>
<blockquote>
<p>换句话说：这个<code>族</code>的<code>每k个子集的并集</code>都<code>至少包含k个元素x</code></p>
<p>也就是说：任意<code>k位男士的合意列表</code>中<code>至少含有k位女士</code>。</p>
<p>证明：<code>族的每k个子集的并集的数量</code>含义为<code>这个族内的所选取的这k个对象的所需求的不同的资源的数量</code>，即<code>我们目前拥有的不同的资源的数量</code>，而<code>数字k</code>表示<code>总共有k个人</code>。根据<code>鸽巢原理</code>可以证明上述结论。</p>
<p>当然，如果直接令<code>k = n</code>即表示为<code>整个族的所有对象</code>的情形。但是，很显然如果当<code>k &lt; n</code>时的<code>子问题</code>中不存在<code>SDR</code>，则将<code>问题规模</code>扩大到<code>整个族的所有对象</code>后，仍然不存在SDR。</p>
</blockquote>
<h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><p><code>集合Y的子集族</code>\mathcal{A} &#x3D; (A_1, A_2, \cdots, A_n) <code>存在SDR</code> \iff满足<code>婚姻条件 (Marriage Condition)</code>。</p>
<h5 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h5><ul>
<li>族\mathcal{A}存在SDR的必要条件是满足婚姻条件：已证</li>
<li>族\mathcal{A}存在SDR的充分条件是满足婚姻条件：</li>
</ul>
<p>我们<code>假设：满足婚姻条件</code>，然后<code>对族</code>\mathcal{A}<code>的集合个数n</code>进行<code>归纳法</code></p>
<ol>
<li><p>如果n &#x3D; 1：则\mathcal{A}中仅包含<code>唯一的非空集合</code>，从该集合中<code>任选一个元素</code>即可。</p>
</li>
<li><p>如果n &#x3D; 2：现在\mathcal{A}中包含<code>两个非空集合</code>A_1, A_2。则接下来，我们考虑<code>2个集合之间的关系</code>：</p>
<ul>
<li>如果A_1和A_2没有<code>交集</code>：则存在e_1 \in A_1, e_2 \in A_2且e_1 \ne e_2。则为A_1选取e_1，为A_2选取e_2</li>
<li>如果A_1和A_2存在<code>部分相交</code>：则存在e_1 \in A_1 -A_2, e_2 \in A_2 - A_1且e_1 \ne e_2。则为A_1选取e_1，为A_2选取e_2</li>
<li>如果A_1和A_2存在<code>包含</code>：根本不存在这种情况，否则A_1 \cup A_2 \lt 2，不满足我们的假设<code>婚姻条件</code></li>
</ul>
</li>
<li><p>如果n &#x3D; 3：…</p>
</li>
</ol>
<p>Q.E.D</p>
<h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h5><p>设\mathcal{A}&#x3D;(A_1, A_2,\cdots,A_n)<code>是有限集合Y的子集族</code>。设t \in Z,0 \le t \le n</p>
<p>则<code>存在</code>\mathcal{A}<code>的有SDR的t集合的子族</code> <code>当且仅当</code>：\textcolor{blue}{A_{i_1} \cupA_{i_2} \cup \dots \cup A_{i_t} \ge k - (n - t)}对于<code>所有的k ≥ n - t 的k</code>和<code>取自&#123;1,2, ..., n&#125;的k个不同的下标</code>i_1, i_2, \cdots, i_k的<code>所有选择</code>都成立。</p>
<h4 id="Inference-1"><a href="#Inference-1" class="headerlink" title="Inference"></a>Inference</h4><h5 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h5><p>设\mathcal{A}&#x3D;(A_1,A_2,\cdots,A_n)是<code>有限集合Y的子集族</code>。则<code>拥有SDR的子族 中集合的最大数目</code>为：A_{i_1} \cup A_{i_2} \cup \cdots \cup A_{i_k} + n - k 对<code>所有的k=1,2, ..., n</code>和<code>满足</code>1 \le i_1 \le i_2\ \lt \cdots \le n<code>的k个下标</code>i_1, i_2, \cdots, i_k的<code>所有选择</code>的<code>最小值</code></p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p>Q.E.D</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/31/counting-in-exclusion-principle-mobius-inversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/counting-in-exclusion-principle-mobius-inversion/" class="post-title-link" itemprop="url">Combinatorics - In-Exclusion Principle & Mobius Inversion</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-31 21:20:01" itemprop="dateCreated datePublished" datetime="2022-03-31T21:20:01+00:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Inclusion-Exclusion-Principle"><a href="#Inclusion-Exclusion-Principle" class="headerlink" title="Inclusion-Exclusion Principle"></a>Inclusion-Exclusion Principle</h1><p>[TOC]</p>
<h2 id="Inclusion-Exclusion-Principle-1"><a href="#Inclusion-Exclusion-Principle-1" class="headerlink" title="Inclusion-Exclusion Principle"></a>Inclusion-Exclusion Principle</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>设P_1, P_2, \cdots, P_m为<code>集合S</code>的<code>对象所涉及的性质</code>，则<code>集合S</code>中<code>不具有性质</code>P_1, P_2, \cdots, Pm<code>的对象个数</code>，A_i &#x3D; \{x: x\in S \quad and \quad x\ has\ property\ P_i\}，可以由下面的交错表达式求出：</p>
<p>其中，<code>第1个和</code>对<code>&#123;1,2, ... , m&#125;的所有1子集&#123;i&#125;</code>进行求和，<code>第2个和</code>对<code>&#123;1,2, ..., m&#125;的所有2子集&#123;i, j&#125;</code>进行求和，<code>第3个和</code>对<code>&#123;1,2, ..., m&#125;的所有3子集&#123;i, j, k&#125;</code>进行求和，…，<code>第m个和对&#123;1,2, ..., m&#125;的所有m子集</code>进行求和。</p>
<blockquote>
<p>注意：</p>
<p><code>上述式子所描述的对象</code> <code>恰好不包含m条性质中的任何一条性质</code></p>
<p><code>m</code>表示的是<code>集合S的所有对象所涉及的性质的总数</code>，也就是说<code>总共有m条性质</code>。</p>
<p>而<code>k</code>表示的是<code>集合S的某个对象所具有的k条性质</code>，也就是说<code>0 ≤ k ≤ m</code>。</p>
<p>上述的<code>容斥原理公式</code>中，如果<code>某个对象并没有具有全部的m条性质，而仅仅具有m条性质中的k条性质</code>，则<code>左式为 该对象所具有的k条性质的交集</code>，<code>右式可以保持不变，但应清楚:</code> <code>所有的集合S中的具有k+1条性质的集合的交集 = 0</code>。从而可以直接<code>去除这些零项</code></p>
<p>原因是：对于<code>只具有k条性质的某个对象x</code>，则意味着<code>对象x 不具有 第k+1条性质</code>，那么A_{k+1} &#x3D; \varnothing，则A_{k+1}与<code>任何其他集合的交集，最终都为空集</code>。</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p><code>等式左侧</code>表示的是<code>不具有任何性质的对象的个数</code>，我们证明的思路是：</p>
<ol>
<li>证明<code>不具有</code>P_1, P_2, \cdots, P_m<code>中任何性质的对象</code>对于这个<code>等式的右边</code>的<code>净贡献 = 1</code></li>
<li>证明<code>至少具有</code>P_1, P_2, \cdots, P_m<code>中任何性质的对象</code>对于这个<code>等式的右边</code>的<code>净贡献 = 0</code></li>
</ol>
<hr>
<p>假设<code>对象x</code> <code>不具有任何一条性质</code>，则它对等式右边的净贡献对等式右边的净贡献 &#x3D; 1。</p>
<blockquote>
<p>因为x \in S，所以等式右边的S &#x3D; 1</p>
<p>而因为x \notin A_i，所以等式右边的其他项均 &#x3D; 0</p>
</blockquote>
<hr>
<p>假设<code>对象y</code> <code>恰好具有n ≥ 1条性质</code>，则它对的净贡献对S的净贡献 &#x3D; 1</p>
<p><code>对象y</code>对\sum A_i的<code>净贡献 =</code>\binom{n}{1} &#x3D; n</p>
<blockquote>
<p>因为<code>对象y</code> <code>恰好具有n条性质</code>，因此它是A_1, A_2, \cdots, A_m中<code>恰好n个集合的成员</code>。</p>
</blockquote>
<p><code>对象y</code>对\sum A_i \cap A_j的<code>净贡献 =</code>\binom{n}{2}</p>
<blockquote>
<p>因为我们可以从<code>包含对象y的n个集合</code>中<code>任意地选取对象y所含的2条性质</code></p>
</blockquote>
<p><code>对象y</code>对\sumA_i \cap A_j \cap A_k的<code>净贡献 =</code>\binom{n}{3}</p>
<blockquote>
<p>因为我们可以从<code>包含对象y的n个集合</code>中<code>任意地选取对象y所含的3条性质</code></p>
</blockquote>
<p>依此进行，可以得出<code>y对等式右边的净贡献</code> &#x3D; \binom{n}{0} - \binom{n}{1} + \binom{n}{2} - \binom{n}{3} + \cdots + (-1)^m \binom{n}{m} &#x3D; 0</p>
<blockquote>
<p>注：因为<code>n元素集合的包含奇数个元素的子集 的数量</code>=<code>n元素集合的包含偶数个元素的子集 的数量</code>，故该等式为0</p>
<p>注：实际上<code>有效的项</code>仅到(-1)^n \binom{n}{n}，因为当m &gt; n, \binom{n}{m} &#x3D; 0，这些项都可以被去除。</p>
</blockquote>
<hr>
<p>Q.E.D</p>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h4><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p><code>集合S</code>中<code>至少具有性质</code>P_1, P_2,\cdots,P_m<code>之一的对象的个数</code>，可以由下面的式子得出：</p>
<h3 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h3><h4 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h4><p>如果<code>容斥原理</code>中A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k}<code>仅依赖于k</code>而<code>不依赖于交集中到底使用了哪k个集合</code>，则<code>所有的k子集的大小均相同</code>：</p>
<blockquote>
<p>也就是说，<code>包含任意k条性质的集合</code>的<code>大小均相同</code></p>
</blockquote>
<p>则得到<code>简化版容斥原理</code>：</p>
<blockquote>
<p>即：在<code>容斥原理</code>中<code>出现的第k个求和</code>包含\binom{m}{k}个<code>被加数</code>，而<code>每个被加数</code>均等于\alpha_k</p>
</blockquote>
<blockquote>
<p>当k &gt; m时，\binom{m}{k} &#x3D; 0</p>
</blockquote>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1"><a href="#Application-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h5><p>求<code>从1到1000之间</code> <code>不能被5，6,8整除的整数的个数</code></p>
<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>通过<code>观察</code>给出<code>能被n整除的解释</code>：<code>从1开始的每连续的第n个整数</code>可以<code>被n整除</code>。则</p>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5整除的整数个数</code>：\lfloor\frac{1000}{5}\rfloor &#x3D; 200</p>
<p><code>从1到1000之间能被6整除的整数个数</code>：\lfloor\frac{1000}{6}\rfloor &#x3D; 166</p>
<p><code>从1到1000之间能被8整除的整数个数</code>：\lfloor\frac{1000}{8}\rfloor &#x3D; 125</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5和6整除的整数个数</code>：\lfloor\frac{1000}{30}\rfloor &#x3D; 33</p>
<p><code>从1到1000之间能被5和8整除的整数个数</code>：\lfloor\frac{1000}{40}\rfloor &#x3D; 25</p>
<p><code>从1到1000之间能被6和8整除的整数个数</code>：\lfloor\frac{1000}{24}\rfloor &#x3D; 41</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5和6和8整除的整数个数</code>：\lfloor\frac{1000}{120}\rfloor &#x3D; 8</p>
<blockquote>
<p>注意：求能被某些数整除，应该求的是<code>最小公倍数</code>，而该值不一定是<code>直接将这些数相乘起来</code>。</p>
<p>如lcm\{5,6,8\}&#x3D;120 \ne 5*6*8 &#x3D; 240</p>
</blockquote>
<p>综上，运用<code>容斥原理</code>得：answer &#x3D; 1000 - (200+166+125) + (33 + 25 + 41) - (8) &#x3D; 600</p>
<h4 id="Application-2"><a href="#Application-2" class="headerlink" title="Application 2"></a>Application 2</h4><h5 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h5><p><code>字母集&#123;M, A, T, H, I, S, F, U, N&#125;</code>的<code>排列中</code>，有多少排列使得<code>MATH</code>，<code>IS</code>，<code>FUN</code>不作为<code>连续字符</code>出现在排列中？</p>
<h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h5><p>在运用<code>容斥原理</code>时，首先考虑如何定义P_i。</p>
<p>由于题干需要求出<code>使得MATH，IS，FUN不作为连续字符出现在排列中的个数</code></p>
<p>因此可以考虑<code>分别设这3个单词作为连续字符出现为性质</code>再<code>从全集S中去除满足这3个性质中任何性质的哪些元素</code></p>
<p>故，不妨设</p>
<p>P_{math}为<code>排列中math作为连续字符出现的排列</code></p>
<p>P_{is}为<code>排列中is作为连续字符出现的排列</code></p>
<p>P_{fun}为<code>排列中fun作为连续字符出现的排列</code></p>
<p>同时，设A_i为<code>集合S中满足性质i的集合</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的所有子集</code></li>
</ul>
<p>S &#x3D; 9!</p>
<blockquote>
<p>也就是说，我们可以将<code>全集S</code>特别地看作<code>具有0条性质的所有子集</code>。</p>
<p>这么做的原因是为了表达式的规整统一。</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p>A_{math} &#x3D; (9 - 4 + 1)! &#x3D; 6!</p>
<p>A_{is} &#x3D; (9 - 2 + 1)! &#x3D; 8!</p>
<p>A_{fun} &#x3D; (9-3+1)! &#x3D; 7!</p>
<blockquote>
<p>因为这些<code>单词中的字母</code>需要<code>按一定顺序连续出现</code>，所以可以将他们视为一个<code>整体</code>来看待。</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p>A_{math} \cap A_{is} &#x3D; (9 - 4 + 1 - 2 + 1)! &#x3D; 5!</p>
<p>A_{math} \cap A_{fun} &#x3D; (9 - 4 + 1 - 3 + 1)! &#x3D; 4!</p>
<p>A_{is} \cap A_{fun} &#x3D; (9 - 2 + 1 - 3 + 1)! &#x3D; 6!</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p>A_{math} \cap A_{is} \cap A_{fun} &#x3D; (9 - 4 + 1 - 2 + 1 - 3 + 1)! &#x3D; 3!</p>
<hr>
<p>综上，运用<code>容斥原理</code>得：answer &#x3D; (9!) - (6! + 8! + 7!) + (5! + 4! + 6!) - (3!) &#x3D; 317658</p>
<h4 id="Application-3"><a href="#Application-3" class="headerlink" title="Application 3"></a>Application 3</h4><h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><p>在<code>0到99999之间</code>有多少<code>含有数字2,5和8的整数</code>？</p>
<h5 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h5><p>不妨设：</p>
<p>P_{1}为<code>不含数字2的整数的性质</code></p>
<p>P_{2}为<code>不含数字5的整数的性质</code></p>
<p>P_{3}为<code>不含数字8的整数的性质</code></p>
<p>且设A_i为<code>具有性质i的所有元素的集合</code></p>
<p>我们可以构造<code>多重集合</code>\{5 \cdot 0, 5 \cdot 1, 5 \cdot 2, \cdots, 5 \cdot 9 \}</p>
<p>按这种表示方法，则得出</p>
<blockquote>
<p>也就是说，这里运用了<code>简化版的容斥原理：</code>所有的包含k条性质的集合<code>的</code>大小都相同`</p>
<p>\alpha_0表示：<code>不包含任何性质</code>，也就是本题中<code>不限制对数字的使用</code>。则大小为<code>0~99999之间有多少个数字 = 10^5 = 100000</code></p>
<p>\alpha_1表示：<code>具有性质</code>P_1，也就是<code>不含数字2的整数的性质</code>。等价地，我们要从<code>多重集合</code>里<code>去除掉</code>5 \cdot 2<code>这个多重元素</code>。所以<code>合法整数的数量 = 9^5</code></p>
</blockquote>
<p>综上，</p>
<h4 id="Application-4"><a href="#Application-4" class="headerlink" title="Application 4"></a>Application 4</h4><h5 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h5><p>确定<code>多重集合</code>T &#x3D; \{3 \cdot a, 4 \cdot b, 5 \cdot c\}的<code>10组合的数目</code></p>
<h5 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h5><p>设<code>多重集合</code>T^* &#x3D; \{\infty \cdot a, \infty \cdot b, \infty \cdot c\}的所有10组合的<code>集合S</code>。</p>
<p>设P_1是T^*<code>的10组合中a出现多于3次的性质</code></p>
<p>设P_2是T^*<code>的10组合中b出现多于4次的性质</code></p>
<p>设P_3是T^*<code>的10组合中c出现多于5次的性质</code></p>
<p>且设A_i是T^*<code>的10组合中不具有性质i的哪些10组合的集合</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的所有子集</code></li>
</ul>
<p>S &#x3D; \binom{10 + 3 - 1}{10} &#x3D; 66</p>
<blockquote>
<p>根据<code>每个元素的重数为无限的多重集合</code>的<code>r组合公式</code>：\binom{r+k-1}{r}</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p>A_1 &#x3D; \binom{(10-4) + 3 - 1}{6} &#x3D; 28</p>
<blockquote>
<p>由于P_1是的组合中出现多于次的性质T^*的10组合中a出现多于3次的性质，故A_1是的组合中至少出现次T^*的10组合中a至少出现4次。</p>
<p>所以，等价地，我们可以从T_*中<code>取走4个a</code>。这样即可将问题转化为求取走个后的的组合求取走4个a后的T^*的6组合 （也就是说，相当于这4个a先<code>固定地取走了</code>）</p>
</blockquote>
<blockquote>
<p>这类似于<code>处理仅有2个集合的情况</code>，但我们用<code>容斥原理</code>将这个问题拓展到了<code>3个集合的情况</code></p>
</blockquote>
<p>A_2 &#x3D; \binom{(10-5) + 3 - 1}{5} &#x3D; 21</p>
<p>A_3 &#x3D; \binom{(10-6)+3-1}{4} &#x3D; 15</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; \binom{(10- 4 - 5) + 3 - 1}{1} &#x3D; 3</p>
<p>A_1 \cap A_3 &#x3D; \binom{(10-4-6)+3-1}{0} &#x3D; 1</p>
<p>A_2 \cap A_3 &#x3D; \binom{(10-5-6)+3-1}{1} &#x3D; \binom{1}{-1} &#x3D; 0</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p>A_1 \cap A_2 \cap A_3 &#x3D; \binom{(10-4-5-6)+3-1}{-5} &#x3D; \binom{-3}{-5}&#x3D; 0</p>
<hr>
<p>综上，answer &#x3D; (66) - (28+21+15) + (3+1+0) - (0) &#x3D; 6</p>
<h4 id="Application-5"><a href="#Application-5" class="headerlink" title="Application 5"></a>Application 5</h4><h5 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h5><p>求该方程的<code>非负整数解</code>个数？</p>
<h5 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h5><p>首先使用<code>变量替换</code>，以便将<code>变量的下界提升到0</code>。则</p>
<p>设<code>集合S</code>是<code>新方程的所有非负整数解的集合</code>，则</p>
<p>设</p>
<p>P_1是y_1 \ge 5<code>的性质</code></p>
<p>P_2是y_2 \ge 7<code>的性质</code></p>
<p>P_3是y_3 \ge 6<code>的性质</code></p>
<p>P_4是y_4 \ge 7<code>的性质</code></p>
<p>并设A_i是<code>集合S中满足性质</code>P_i<code>的解 组成的子集</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; 969</p>
<ul>
<li>求<code>所有的集合S中具有1条性质的子集</code></li>
</ul>
<p>假设欲求A_1：也就是y_1 \ge 5，那也就是等价地，我们<code>提前固定地从</code>y_1<code>中选取5个</code>。即</p>
<p>A_1 &#x3D; \binom{(16 - 5) + 4 - 1}{11} &#x3D; 364</p>
<blockquote>
<p>对于<code>要求至少选取集合中某个元素k个</code>的<code>约束条件</code>，我们可以<code>等价地转化为：事前提前取走这k个元素</code>，从而<code>规约为一个新的等价问题</code></p>
</blockquote>
<p>同理地，可求得：</p>
<p>A_2 &#x3D; \binom{(16 - 7) + 4 - 1}{9}</p>
<p>A_3 &#x3D; \binom{(16-6)+4-1}{10}</p>
<p>A_4 &#x3D; \binom{(16-7)+4-1}{9}</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; \binom{(16-5-7)+4-1}{4}</p>
<p>A_1 \cap A_3 &#x3D; \binom{(16-5-6)+4-1}{5}</p>
<p>A_1 \cap A_4 &#x3D; \binom{(16-5-7)+4-1}{4}</p>
<p>A_2 \cap A_3 &#x3D; \binom{(16-7-6)+4-1}{3}</p>
<p>A_2 \cap A_4 &#x3D; \binom{(16-7-7)+4-1}{2}</p>
<p>A_3 \cap A_4 &#x3D; \binom{(16-6-7)+4-1}{3}</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的子集</code></li>
</ul>
<p>这些<code>子集</code>均为空集</p>
<ul>
<li>求<code>所有的集合S中具有4条性质的子集</code></li>
</ul>
<p>这些<code>子集</code>均为空集</p>
<hr>
<p>综上，运用<code>容斥原理</code>得出answer &#x3D; 55</p>
<h2 id="Derangement-Formula"><a href="#Derangement-Formula" class="headerlink" title="Derangement Formula"></a>Derangement Formula</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>若<code>集合</code>S &#x3D; \{1, 2, \cdots, n\}，其中<code>每个整数的位置</code>由<code>一个排列</code>i_1i_2\cdots i_n <code>$$所确定</code>。</p>
<p>则<code>集合S</code>的<code>一个错位排列</code>是这样的<code>一个排列</code>，满足：i_1 \ne 1, i_2 \ne 2, \cdots, i_n \ne n</p>
<blockquote>
<p>换句话说，<code>错位排列</code>中<code>没有任何一个整数</code>位于<code>自然位置</code></p>
</blockquote>
<hr>
<h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>设<code>集合S</code>为<code>n个整数的所有排列方案组成的集合</code>：S &#x3D; n!</p>
<p>设P_i为<code>整数i位于自然位置的性质</code></p>
<p>设A_i为<code>集合S中的具有性质</code>P_i<code>的子集</code></p>
<p>我们需要求出<code>这样的一些排列</code>：<code>没有任何整数位于自然位置</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中的具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; n!</p>
<ul>
<li>求<code>所有的集合S中的具有1条性质的子集</code></li>
</ul>
<p>A_1 &#x3D; (n-1)!</p>
<p>A_2 &#x3D; (n-1)!</p>
<p>\vdots</p>
<p>A_n &#x3D; (n-1)!</p>
<ul>
<li>求<code>所有的集合S中的具有2条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; (n-2)!</p>
<p>\vdots</p>
<p>A_{n-1} \cap A_n &#x3D; (n-2)!</p>
<p>……</p>
<ul>
<li>求<code>所有的集合S中的具有n条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 \cap \cdots \cap A_n &#x3D; 1</p>
<hr>
<p>根据<code>容斥原理</code>得出：</p>
<p>Q.E.D</p>
<h3 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-Approximation"><a href="#Theory-Approximation" class="headerlink" title="Theory: Approximation"></a>Theory: Approximation</h4><p>我们有e^{-1} &#x3D; 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \frac{1}{4!} - \dots</p>
<p>则e^{-1} &#x3D; \frac{D_n}{n!} \textcolor{red}{ + (-1)^{n+1}\frac{1}{(n+1)!} + (-1)^{n+2}\frac{1}{(n+2)!} + \dots}</p>
<p>所以，我们得出结论：e^{-1} - \frac{D_n}{n!} \le \frac{1}{(n+1)!}</p>
<blockquote>
<p>这个近似提供了一个非常简单的求D_n的方法：D_n &#x3D; \frac{n!}{e} &#x3D; \frac{n!}{2.7182818284\dots}</p>
</blockquote>
<h4 id="Theory-Recurrence-Formula"><a href="#Theory-Recurrence-Formula" class="headerlink" title="Theory: Recurrence Formula"></a>Theory: Recurrence Formula</h4><p>D_n &#x3D; (n-1)(D_{n-2} + D_{n-1}) \quad (n &#x3D; 3, 4,5,\dots)</p>
<hr>
<p>考虑\{1,2,\dots,n\}的D_n个错位排列。</p>
<p>可以按照<code>将2,3,...,n中的哪一个数字放置到第一位</code>而将D_n个错位排列<code>划分</code>为<code>n-1 个部分</code></p>
<blockquote>
<p>显然，这<code>n-1个部分</code>都包含<code>相同的错位排列个数</code></p>
</blockquote>
<p>这样，D_n &#x3D; (n-1)d_n，其中d_n是<code>数字2位于排列第一个位置上的错位排列的数目</code></p>
<p>在这d_n个错位排列中，可继续按照<code>数字1是否位于第二个位置</code>来<code>划分为2个部分</code>：</p>
<p>设d_n^\prime表示<code>数字1位于第二个位置的错位排列个数</code></p>
<p>设d_n^{\prime\prime}表示<code>数字1不位于第二个位置的错位排列个数</code></p>
<p>故d_n &#x3D; d_n^{\prime} + d_n^{\prime\prime}</p>
<blockquote>
<p>d_n是形式为2i_2i_3\dotsi_n,\quad i_2 \ne 2, i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
<p>d_n^\prime是形式为21i_3i_4\dotsi_n, \quad i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
<p>d_n^{\prime\prime}是形式为2i_2i_3\dotsi_n,\quad i_2 \ne 1, i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
</blockquote>
<p>所以 D_n &#x3D; (n-1)d_n &#x3D; (n-1)(d_n^{\prime} + d_n^{\prime\prime})</p>
<p>我们<code>观察</code>到，d_n^{\prime} &#x3D; D_{n-2}和d_n^{\prime\prime} &#x3D; D_{n-1}</p>
<blockquote>
<p>实际上，我们<code>并不关心</code> <code>数字是多少</code>和<code>位置是多少</code>。</p>
<p>我们<code>关心的仅仅是</code> <code>数字和位置所构成的二元组 的个数</code>。</p>
<p>换句话说，我们可以设<code>（数字num，位置pos）二元组</code> <code>表示当数字num不位于位置pos时，【视为】满足【错位排序】</code></p>
<p>正常情况下，我们称<code>错位排序</code>需要满足<code>形式如这样的二元组约束条件</code>：<code>(1,1)</code>，<code>(2,2)</code>，…，<code>(n,n)</code> 。</p>
<p>这样的<code>n个整数的错位排列的数量 =</code>D_n</p>
<p>但是，我们如果将<code>数字num</code>和<code>位置pos</code>进行重新映射，比如说<code>映射为如下的约束条件: (1,2), (2,1), (3,3), (4,4), ..., (n,n)</code></p>
<p>或者说，<code>映射为如下的约束条件：(1, 2), (2, 3), (3, 4), ..., (n - 1, n), (n, 1)</code>。</p>
<p>那么上述的<code>两个对约束条件的重新映射</code>，<code>并不会改变错位排列的数量</code>，<code>错位排列的数量仍然是</code>D_n</p>
<hr>
<p>总而言之，<code>错位排序问题的规模</code>并不是<code>数字是什么</code>或者<code>位置是什么</code>。而是<code>(数字，位置)的二元组约束条件的数量</code></p>
</blockquote>
<blockquote>
<p>d_n^\prime实际上<code>等价于</code>的排列中，共个约束条件\{3,4,…,n\}的排列i_3i_4\dotsi_n中，\textcolor{blue}{i_3 \ne 3, i_4 \ne 4,\dots, i_n \ne n \quad(共n-2个约束条件)}的排列个数，<code>等价地，我们的问题规模就从</code>D_n减少到了D_{n-2}</p>
<p>d_n^{\prime\prime}实际上<code>等价于</code>的排列中，共个约束条件\{1, 3,4,\dots,n\}的排列i_1i_3i_4\dots i_n中，\textcolor{blue}{i_1\ne 1, i_3 \ne 2, i_4 \ne 3, \dots, i_n \ne n-1 \quad (共n-1个约束条件)}，<code>等价地，我们的问题规模就从</code>D_n减少到了D_{n-1}</p>
</blockquote>
<p>综上，D_n &#x3D; (n-1)(D_{n-1} + D_{n-2})</p>
<p>Q.E.D</p>
<h4 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory"></a>Theory</h4><p>通过不断对Dn &#x3D; (n-1)(D_{n-1}+D_{n-2})运用<code>递推公式</code>，可以<code>降解得到</code></p>
<p>D_n &#x3D; nD_{n-1} + (-1)^n, \quad(n &#x3D; 2,3,4,…)</p>
<h2 id="Arrangement-Problems-with-Prohibited-Positions"><a href="#Arrangement-Problems-with-Prohibited-Positions" class="headerlink" title="Arrangement Problems with Prohibited Positions"></a>Arrangement Problems with Prohibited Positions</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>我们设P(X_1, X_2, \cdots, X_n)表示\{1,2,\cdots,n\}的<code>所有排列</code>i_1i_2\dots i_n的集合，使得i_1 \notin X_1, i_2 \notin X_2, \cdots, i_n \notin X_n</p>
<blockquote>
<p><code>错位排列</code>是一种<code>特化的带禁止位置的排列</code>：X_1&#x3D;\{1\}, X_2&#x3D;\{2\}, \cdots, X_n\{n\} \implies P(X_1, X_2, \cdots, X_n) &#x3D; D_n</p>
</blockquote>
<blockquote>
<p><code>带禁止方格的非攻击型车棋盘问题</code>是一种<code>特化的带禁止位置的排列</code>：<code>按逐行顺序放置车</code>，则<code>放置方案</code>即为一个<code>排列</code>i_1i_2\cdots i_n</p>
</blockquote>
<h3 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1-Non-Attack-Rook-Problem-with-Prohibited-Positions"><a href="#Application-1-Non-Attack-Rook-Problem-with-Prohibited-Positions" class="headerlink" title="Application 1: Non-Attack Rook Problem with Prohibited Positions"></a>Application 1: Non-Attack Rook Problem with Prohibited Positions</h4><h5 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h5><p>将<code>n个攻击型不可区分的车</code>放到<code>带有禁止位置的n行n列棋盘</code>上的<code>放置方法数</code>等于</p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h5><p>设<code>集合S</code>表示<code>n个非攻击型车在n行n列的棋盘上的所有n!种放置方案的集合</code>。</p>
<p>设P_j表示在行列的车，的性质在j行i列的车， i \in X_j \ 的性质</p>
<blockquote>
<p>也就是说，<code>逐行放置非攻击型车，且必须放置在当前行的禁止位置上的性质</code></p>
</blockquote>
<p>设A_i表示<code>满足</code>P_j \quad(j &#x3D; 1,2,\cdots,n)<code>的车的放置方案的集合</code></p>
<p>设P(X_1, X_2, \cdots, X_n)是<code>n个非攻击型车的所有放置方案</code>中<code>不满足性质</code>P_1, P_2, \cdots, P_n<code>的放置方案所组成的集合</code></p>
<hr>
<p>则P(X_1, X_2, \cdots, X_n) &#x3D; \overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n}</p>
<p>则A_i &#x3D; X_i (n-1)!,\quad(i &#x3D; 1,2,\cdots, n)</p>
<p>则\sum{A_i} &#x3D; (X_1 + X_2 + \cdots + X_n)(n-1)!</p>
<p>设r_k等于<code>把k个非攻击型车放到棋盘上的禁止位置的方法数</code></p>
<p>则对于<code>所有的集合S中的具有k条性质的子集</code>有\textcolor{blue}{\sumA_{i_1}\cap A_{i_2} \cap \cdots \cap A_{i_k} &#x3D; r_k(n-k)!,\quad(k&#x3D;1,2,\cdots,n)}</p>
<p>\sum{A_i} &#x3D; r_1(n-1)!</p>
<p>\sum{A_i \cap A_j} &#x3D; r_2(n-2)!</p>
<p>\sum{A_i \cap A_j \cap A_k} &#x3D; r_3(n-3)!</p>
<p>运用<code>容斥原理</code>，得出结论。</p>
<p>Q.E.D</p>
<h5 id="Content-7"><a href="#Content-7" class="headerlink" title="Content"></a>Content</h5><p>求<code>将2个非攻击型车放置到下列的6×6的带禁止位置的棋盘上的方案数</code></p>
<p><img src="https://s2.loli.net/2022/04/03/78Bds6FNvDUTYbq.png" alt="image-20220330173743577"></p>
<h5 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h5><p>r_1 &#x3D;7</p>
<blockquote>
<p>因为<code>在该棋盘上放置1个非攻击型车的方案数有7种</code></p>
</blockquote>
<p>r_2 &#x3D; (1) + (2) + (3 × 4) &#x3D; 15</p>
<blockquote>
<p>2个非攻击型车都放在左上角区域有1种方案。</p>
<p>2个非攻击型车都放在右下角区域有2种方案。</p>
<p>2个非攻击型车分别位于两个区域有3×4&#x3D;12种方案。</p>
</blockquote>
<blockquote>
<p>这里可以直接使用<code>乘法</code>来计算方案数，是因为<code>这两个红色区域</code>是<code>独立的</code>：</p>
<p>也就是说，<code>两个区域是独立的，则无论如何放置车</code>，<code>一个区域内的车</code>不会攻击到<code>另一个区域内的车</code>！</p>
</blockquote>
<p>r_3 &#x3D; (1 \times 4) + (3 \times 2) &#x3D; 10</p>
<p>r_4 &#x3D; (1 \times 2) &#x3D; 2</p>
<hr>
<p>综上，answer &#x3D; (6!) - 7\times(5)! + 15\times(4)! - 10\times(3)! + 2\times(2)! &#x3D; 184</p>
<h4 id="Application-2-Boys-Queuing-Problem"><a href="#Application-2-Boys-Queuing-Problem" class="headerlink" title="Application 2: Boys Queuing Problem"></a>Application 2: Boys Queuing Problem</h4><h5 id="Content-8"><a href="#Content-8" class="headerlink" title="Content"></a>Content</h5><p>若有<code>5个男孩</code>每天练习走步。这些男孩站成<code>一队纵列</code>前行，<code>除了第一个男孩外的每个男孩的前面都有另一个男孩</code>。</p>
<p>为了让<code>每个男孩不总是看到他前面的同一个人</code>，<code>第二天</code>，<code>他们决定交换位置</code>，<code>使得没有男孩的前面的男孩与他第一天在他前面的男孩是同一个人</code></p>
<h5 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h5><p>设Q_n表示\{1,2,\cdots,8\}的排列中，<code>不出现模式12,23,34，..., (n-1)n 的那些排列的个数</code></p>
<p>对于n \ge 1</p>
<blockquote>
<p>Q_n &#x3D; D_n + D_{n-1}, \quad (n \ge 2)</p>
</blockquote>
<h5 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h5><p>设S是\{1,2,\cdots,n\}的全部n!个排列所组成的集合</p>
<p>设P_j是<code>在一个排列中模式j(j+1)出现的性质 (j = 1, 2, ..., n-1)</code></p>
<p>设A_j是\{1,2,\cdots,n\}的满足P_j的排列所组成的集合。</p>
<blockquote>
<p>注：由于P_j共n-1个，故A_j的数量也为n-1个</p>
</blockquote>
<hr>
<ul>
<li>求<code>所有的集合S中的具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; 5!</p>
<ul>
<li>求<code>所有的集合S中的具有1条性质的子集</code></li>
</ul>
<p>A_j &#x3D; (n-1)!, \quad(j &#x3D; 1,2,\cdots,n-1)</p>
<ul>
<li>求<code>所有的集合S中的具有2条性质的子集</code></li>
</ul>
<p>考虑A_i \cap A_j</p>
<p>那么需要考虑A_i和A_j的<code>模式</code>之间是否存在<code>共享元素</code></p>
<p>不存在：如<code>12</code>和<code>34</code>，则可视为<code>n-2个符号的集合&#123;12, 34, 5, 6, ..., n&#125;的一个排列</code></p>
<blockquote>
<p>元素个数差 &#x3D; -4 + 2 &#x3D; -2</p>
</blockquote>
<ol>
<li><p>存在：如<code>12</code>和<code>23</code>，则可视为<code>个符号的集合&#123;12, 23, 4, 5, 6, ..., n&#125;的一个排列</code></p>
<blockquote>
<p>元素个数差 &#x3D; -3 + 1 &#x3D; -2</p>
</blockquote>
</li>
</ol>
<p>也就是说，无论是<code>不同模式</code>之间<code>是否存在共享的元素</code>，都不会影响<code>参与排列的符号的个数</code></p>
<p>即A_i \cap A_j &#x3D; (n-2)!</p>
<ul>
<li>求<code>所有的集合S中的具有k条性质的子集</code></li>
</ul>
<p>A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_{k}} &#x3D; (n-k)! \qquad(k &#x3D; 1,2,\cdots,n-1)</p>
<hr>
<p>综上，根据<code>容斥原理</code>：answer &#x3D; 5! - \binom{4}{1}A_{i_1} + \binom{4}{2}A_{i_1} \cap A_{i_2} - \binom{4}{3}A_{i_1} \cap A_{i_2} \cap A_{i_3} \cap A_{i_4} + \binom{4}{4} A_{i_1} \cap A_{i_2} \cap A_{i_3} \cap A_{i_4}</p>
<h2 id="Mobius-Inversion"><a href="#Mobius-Inversion" class="headerlink" title="Mobius Inversion"></a>Mobius Inversion</h2><h3 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h3><p>设<code>n为正整数</code>，考虑<code>n元素集合</code>X_n &#x3D; \{1,2,\cdots,n\}，以及<code>由包含关系所定义的</code>X_n<code>的所有子集的集合上的偏序集</code>(\mathcal{P}, \subseteq)</p>
<p>设<code>函数</code>F:\mathcal{P}(X_n) \rightarrow \real 是<code>定义在</code>\mathcal{P}(X_n)<code>上的实值函数</code></p>
<p>设<code>函数</code>G: \mathcal{P}(X_n) \rightarrow \real，使得\textcolor{blue}{G(K) &#x3D; \sum_{L \subseteq K}{F(L)},\quad(K \subseteq X_n)}</p>
<p>则，<code>莫比乌斯反解</code>可从<code>函数G</code>恢复<code>函数F</code></p>
<blockquote>
<p>也就是说，给定G(K)可以得出F(K)</p>
</blockquote>
<p>我们有\textcolor{blue}{F(K) &#x3D; \sum_{L\subseteq K}{\textcolor{green}{(-1)^{K-L}}G(L)}, \quad (K \subseteq X_n)}</p>
<p>设<code>有限集S的子集</code>为 A_1, A_2,\cdots,A_n</p>
<p>对于<code>集合</code>K \subseteq \{1,2,\cdots,n\}，<code>定义</code>F(K)为<code>集合S中正好</code> <code>属于所有满足</code>i \notin K<code>的集合</code>A_i<code>的元素个数</code></p>
<blockquote>
<p>也就是说，对于<code>给定的F(K)中的K</code>：</p>
<p><code>对于</code>s \in S, F(K)<code>计数s</code> <code>当且仅当</code> s \notin A_i, \forall i \in K和s \in A_j, \forall j \notin K</p>
<hr>
<p>用<code>容斥原理</code>的角度看，<code>集合K</code>相当于是<code>1个给定的一些性质的集合</code>（只不过我们对<code>性质</code>做了<code>编号</code>，而<code>所有性质的编号组成了 集合</code>X_n）,</p>
<p>而<code>集合A</code>相当于<code>集合S中的 具有指定某个性质的所有元素 所组成的集合</code></p>
<hr>
<p>再换句话说，如果我们<code>给定了 1个包含了特定的某些性质的集合K</code>，并<code>将这个 集合K 作为参数 传递给函数F</code>，即<code>F(K)</code>，</p>
<p>则<code>函数F 的作用类似于</code> <code>过滤器</code>和<code>计数器</code>：<code>函数F(K)</code>会<code>循环检查 集合S的每一个元素</code>（假如我们设<code>循环变量</code>为<code>s</code>），并<code>对该元素（即临时的循环变量s）循环检查K中的每一条性质</code> ：如果<code>这个元素不具有K中的任何一条性质</code>或者<code>这个元素具有K中没有的性质</code>。那么我们<code>计数该元素</code></p>
<hr>
<p>实际上，(-1)^{K -L}就是<code>偏序集</code>(\mathcal{P}(X_n), \le)<code>的莫比乌斯函数</code></p>
<hr>
<p>从<code>编程</code>的角度看，如果实现一个<code>容斥原理</code>解法：<code>F(tempPropertySet)和G(tempPropertySet)</code>是<code>2个存在递归的函数</code>（<code>函数F</code>通过调用<code>函数G</code>来再次调用<code>函数F</code>自身，但<code>每次对函数F的调用 所传入的参数并不同，也就是 所传入的特定的某些性质的集合 不同</code>）我们可以从F(K)开始运行，<code>刚开始（也就是第一次）传递给G(tempPropertySet)的参数是 所有的给定的某些性质</code>，<code>但G(K)并没有立即开始计算，而是继续递归下降直到 递归的基本情况</code>（注意我们的<code>约束条件</code>：K \subseteq X_n），我们可以<code>编程</code>使得<code>G(tempPropertySet)在 所输入的参数为空集后，不再继续调用F(tempPropertySet)进行递归</code>（如果<code>如果输入参数为空集</code>，<code>意味着 给定的一些性质的集合大小为0，也就是 没有给定任何性质，即具有0条性质</code>，而这也就是<code>容斥原理里右式的第一项：S</code>）。</p>
<p>从<code>整个程序的实际计数顺序（递归下降过程仅保留帧栈，但不进行实际的计数）来看</code>，它与我们在<code>计算容斥原理时从左到右 计算的顺序一样：先计算具有0条性质的情形，再计算具有1条性质的情形...</code></p>
<p>TODO</p>
</blockquote>
<p>故\textcolor{blue}{G(K) &#x3D; \sum_{L \subseteq K}{F(L)}} \textcolor{red}{&#x3D; \bigcap_{i \notin K}A_i }</p>
<p>计数<code>S中属于 j不在K中的所有</code>A_j<code>的元素</code> 以及 <code>属于其他一些集合的元素</code> <code>的个数</code>。</p>
<blockquote>
<p><code>G(K)</code>等价于<code>对所有的 具有我们K中没有指定的其他性质中的某条性质的元素所组成集合 进行交集运算</code></p>
</blockquote>
<p>则F(K) &#x3D; \sum_{L \subseteq K}{(-1)^{K - L}G(L)}</p>
<p>取<code>集合K</code>为<code>集合</code>X_n，得\textcolor{red}{F(X_n)}&#x3D;\sum_{L \subseteq \textcolor{blue}{X_n}}{(-1)^{\textcolor{blue}{n}-L}G(L)} &#x3D; \textcolor{red}{\overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n}}，则此F(X_n)<code>计数的是</code> <code>S中 仅属于满足</code>i \notin X_n<code>的那些集合</code>A_i<code>的元素</code>。</p>
<blockquote>
<p>这也就是说，F(X_n)是<code>集合S中 不属于集合</code>A_1,A_2,\cdots,A_n<code>中任何一个集合的元素 的个数</code>。</p>
<hr>
<p>也就是说，我们将<code>所有性质的集合</code>X_n传参给F(tempPropertySet)，我们<code>计数</code> <code>不含</code>X_n<code>中的性质的对象个数</code></p>
</blockquote>
<p>因此，我们得到</p>
<p>F(X_n) &#x3D; \overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n} &#x3D; \sum_{L \subseteq X_n}{(-1)^{n - L} \textcolor{blue}{\Big\bigcap_{i\notin L}A_i\Big}}</p>
<blockquote>
<p>等价地，使用<code>L在</code>X_n<code>中的补集J</code>代替<code>L</code>得到</p>
<p>\overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n} &#x3D; \sum_{\textcolor{blue}{J} \subseteq X_n}{(-1)^{\textcolor{blue}{J}} \Big \bigcap_{i \textcolor{blue}{\in J}}{A_i} \Big }</p>
<p>根据该式子，<code>容斥原理</code>是<code>莫比乌斯反演</code>在<code>有限偏序集</code>上的一个实例。</p>
</blockquote>
<hr>
<p>我们在上面的基础上，使用<code>任意的有限偏序集</code>(X, \le) 代替<code>偏序集</code> (\mathcal{P}(X_n), \subseteq)</p>
<blockquote>
<p>对于<code>有限偏序集</code>，可以用<code>更弱的性质</code>来代替<code>有限的性质</code>，即<code>局部有限</code>：对于<code>所有</code>a \le b<code>的a和b</code>而言<code>区间</code>\{x: a \le x \le b\}是<code>局部有限</code></p>
</blockquote>
<p>首先考虑<code>二变量函数</code>：</p>
<p>设\mathcal{F}(X)是<code>满足只要</code>x \not{\le} y<code>就有</code>f(x,y) &#x3D; 0<code>的所有实值函数</code>f: X \times X\rightarrow \real<code>的集合</code></p>
<p>于是，f(x,y)<code>只在</code>x \le y<code>时有可能不等于0</code>，而一旦x \gt y<code>则必定等于0</code>。</p>
<p>我们<code>定义</code>\mathcal{F}(X)<code>中的两个函数f和g的卷积</code>h &#x3D; f * g如下</p>
<blockquote>
<p>也就是说，我们通过<code>关于z求积</code>f(x,z)g(z,y)<code>的和</code>，来计算x \le y<code>的h(x,y)</code></p>
</blockquote>
<hr>
<p>我们考虑\textcolor{green}{\mathcal{F}(X)}<code>中的三种特殊的函数</code>：</p>
<ul>
<li>克罗内克Delta函数（Kronecker Delta Function） \delta(x, y) &#x3D;\begin{cases}1,&amp; x&#x3D; y \\ 0,&amp;else\end{cases}</li>
</ul>
<blockquote>
<p>注：对所有的<code>函数</code>f \in \mathcal{F}(X), \delta * f &#x3D; f * \delta &#x3D; f</p>
<p>因此，对于<code>卷积</code>来说，\delta就是一个<code>恒等函数</code></p>
</blockquote>
<blockquote>
<p><code>函数</code>δ其实就是一个<code>相等谓词</code>。</p>
</blockquote>
<ul>
<li>\zeta函数（Zeta Function） \zeta &#x3D; \begin{cases}1, &amp; x \le y\\0 ,&amp; else\end{cases}</li>
</ul>
<blockquote>
<p>\zeta<code>函数</code>是<code>偏序集</code>(X, \le )的一种<code>表示</code>，该函数<code>包含了所有满足</code>x \le y<code>的元素</code>对<code>x，y的全部信息</code></p>
</blockquote>
<blockquote>
<p><code>函数</code>\zeta其实就是一个<code>偏序谓词</code>。</p>
</blockquote>
<ul>
<li>莫比乌斯函数（Mobius Function）\mu</li>
</ul>
<p>设f \in \mathcal{F} 对<code>X中的所有y满足</code>f(y,y) \ne 0，则我们可以<code>递归地</code>定义\mathcal{F}(X)<code>中的函数g</code>：</p>
<p>设\textcolor{blue}{g(y,y) &#x3D; \frac{1}{f(y,y)} \qquad, (y \in X, f(y,y) \ne 0)}</p>
<p>然后<code>令</code></p>
<p>于是，我们可以得到</p>
<p>因此，g * f &#x3D; \delta</p>
<blockquote>
<p>即：g是<code>f关于卷积*的左逆函数</code></p>
</blockquote>
<p>我们得出结论：</p>
<p><code>每个对X中的所有y满足</code>f(y,y) \ne 0<code>的函数</code>f \in \mathcal{F}，都有<code>函数f的逆函数g</code>满足\textcolor{green}{g * f &#x3D; f * g &#x3D; \delta}</p>
<blockquote>
<p>证明方式如上，设出g(y,y)和g(x,y)</p>
</blockquote>
<hr>
<p><code>因为</code>\zeta(y,y) &#x3D; 1, \forall y \in X</p>
<p><code>故</code>\zeta存在<code>逆函数</code>\mu满足</p>
<blockquote>
<p>也就是说：<code>莫比乌斯函数</code>\mu是\zeta<code>函数</code>的<code>逆函数</code></p>
<p>同理可得：\textcolor{green}{\mu * \zeta &#x3D; \zeta * \mu &#x3D; \delta}</p>
</blockquote>
<p>所以，我们令\textcolor{blue}{f &#x3D; \zeta, g &#x3D; \mu}得到</p>
<blockquote>
<p>由于<code>函数</code>\zeta是一个<code>偏序谓词</code>，而显然z \le y \implies \zeta(z,y) &#x3D; 1，故可直接消去\zeta(z,y)</p>
</blockquote>
<blockquote>
<p>注意：上式中我们所做的<code>代换</code>f &#x3D; \zeta, g &#x3D; \mu需要指定<code>约束条件</code>x \le y，否则，<code>作为f函数的</code>\zeta<code>函数无法保证 非0</code></p>
</blockquote>
<p>上述式子表明2个事实：</p>
<ol>
<li><p>\textcolor{green}{\mu(x,x) &#x3D; 1, \forall x}</p>
<blockquote>
<p>这意味着<code>求和的上界和下界相等，故 求和值 =</code>\mu(x,x) &#x3D; \delta(x,x) &#x3D; 1</p>
</blockquote>
</li>
<li><p>\textcolor{green}{\mu(x,y) &#x3D; -\sum_{\{z: x \le z \lt y\}}{\mu(x,z)} \quad,(x \lt y)}</p>
<blockquote>
<p>TODO</p>
</blockquote>
</li>
</ol>
<h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p>设(X, \le)是<code>偏序集</code>且<code>有最小元 0</code>，设<code>它的莫比乌斯函数</code>为\mu</p>
<p>设<code>函数</code>F: X \rightarrow \real是<code>定义在X上的实值函数</code></p>
<p>设<code>函数</code>G: X \rightarrow \real定义为\textcolor{blue}{G(x) &#x3D; \sum_{\{z: z \le x\}}{F(z)}, \quad(x \in X)}</p>
<p>则\textcolor{blue}{F(x) &#x3D; \sum_{\{y: y \le x\}} {G(y)\textcolor{green}{\mu(y,x)}}, \quad (x \in X)}</p>
<h3 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h3><p>设\zeta为(X, \le) 的\zeta<code>函数</code>，对于x \in X，有</p>
<p>ζδ</p>
<blockquote>
<p>注意：对于上式而言，<code>元素x</code>并不是<code>变量</code>，而应当被视为<code>常量</code></p>
</blockquote>
<blockquote>
<p>\sum_{\{z: z \le y\}}{F(z)} &#x3D; \sum_{\{z: z \in X\}}{\zeta(z, y) F(z)}</p>
<p>对于<code>左式</code>：直接<code>求和z &lt;= y的范围</code></p>
<p>而对于<code>右式</code>：我们是通过引入\zeta函数（它是一个<code>偏序过滤器</code>），进而我们可以转变<code>求和范围</code>为<code>集合X中的任何元素z</code>。</p>
<p>这是因为，对于<code>对于不满足条件的元素</code>，会被\zeta函数所<code>过滤掉</code>（也就是说，这个<code>项</code>的值为<code>0</code>）</p>
<p>这类似于我们在前面<code>容斥原理中第k条性质之后的零项</code>的情况。</p>
</blockquote>
<blockquote>
<p>同理，\delta(z,x)作为<code>相等过滤器</code>，故</p>
<p>\sum_{\{z: z \in X\}}{\delta(z, x)F(z)} &#x3D; F(x)</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h4><p>计算<code>偏序集</code>(\mathcal{P}(X_n), \subseteq)<code>的莫比乌斯函数</code>，其中X_n &#x3D; \{1,2,\cdots,n\}</p>
<p>设A \subseteq B \subseteq X_n，然后，我们对B - A作<code>归纳法</code>，以<code>证明</code>\mu(A,B) &#x3D; (-1)^{B - A}</p>
<hr>
<p>如果A &#x3D; B</p>
<p>我们注意到\mu(x,x) &#x3D; 1, \forall x</p>
<p>则<code>证明完成</code></p>
<hr>
<p>如果A \ne B</p>
<p>设\textcolor{blue}{p &#x3D; B \backslash A &#x3D; B - A}</p>
<p>我们有</p>
<hr>
<p>对于<code>满足</code>0 \le k \le p-1<code>的每个整数k</code>，<code>满足</code>A \subseteq C \subset B<code>且</code>C - A &#x3D; k<code>的集合C</code> 的个数 等于 <code>包含在基数为p的集合</code>B \backslash A<code>中且基数为k的子集</code> 的个数</p>
<p>根据<code>二项式定理</code>有 \textcolor{blue}{0 &#x3D; (1-1)^p &#x3D; \sum_{k&#x3D;0}^{p}{(-1)^k \binom{p}{k}}}</p>
<p>因此\textcolor{blue}{\sum_{k&#x3D;0}^{p-1}{(-1)^k \binom{p}{k}} &#x3D; -(-1)^p \binom{p}{p} &#x3D; -(-1)^p\binom{p}{p}}</p>
<p>因而，我们可以得到</p>
<p>Q.E.D</p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h4><p>计算<code>线性有序集的莫比乌斯函数</code>。</p>
<hr>
<p>设X_n &#x3D; \{1,2,\cdots, n\}, 考虑<code>线性有序集</code>(X_n, \le) \quad, (1 \lt 2 \lt \cdots \lt n)</p>
<p>因为\mu(k,k) &#x3D; 1, \forall k \in \{1,2,\cdots,n\} 且 \textcolor{blue}{\mu(k,l) &#x3D; 0,\quad(1 \le l \lt k \le n)}</p>
<p>假设l &#x3D; k + 1, \quad (1 \le k \le n - 1)，则\sum_{\{j: k \le j \le k+1\}}{\mu(k,j)} &#x3D; 0</p>
<p>因此\mu(k,k) + \mu(k,k+1) &#x3D; 0</p>
<p>而这意味着\textcolor{blue}{\mu(k, k+1) &#x3D; -\mu(k, k) &#x3D; -1}</p>
<p>若假设1 \le k \le n-2，则\mu(k,k) + \mu(k,k+1) + \mu(k, k+2) &#x3D; 0</p>
<p>故\mu(k,k+2) &#x3D; -(\mu(k,k) + \mu(k, k+1)) &#x3D; -(1+(-1)) &#x3D; 0</p>
<p>继续如此，我们可以<code>归纳法</code>得出</p>
<p>Q.E.D</p>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h4><p>设n为正整数，X_n &#x3D; \{1,2,\cdots,n\}，考虑<code>偏序集</code>D_n &#x3D; (X_n, )，计算<code>偏序集的</code>\mu(1,n)</p>
<blockquote>
<p>整除性：a b 当且仅当 a 是 b的因子</p>
</blockquote>
<hr>
<p><code>整数n</code>有<code>唯一素数因数分解</code>，设为 \textcolor{blue}{n &#x3D; p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}}</p>
<p>则\mu(1,n)可递归定义为\textcolor{blue}{\mu(1,n) &#x3D; -\sum_{\{m \ge 1: mn, m \ne n\}}{\mu(1,m)}}</p>
<blockquote>
<p>即令1 \le m \le n，这里m \le n<code>的信息 被隐藏在</code>m n<code>中</code>。</p>
<p>之后利用<code>莫比乌斯函数的公式</code>求和即可。</p>
</blockquote>
<p>因此，只需要考虑(X_n^*, )，其中\textcolor{blue}{X_n^*}<code>是</code>X_n<code>中所有满足的正整k n数k组成的子集</code></p>
<p>设\textcolor{blue}{r, s \in X_n^*}，我们有 r &#x3D; p_1^{\beta_1}p_2^{\beta_2}\cdots p_k^{\beta_k}和s &#x3D; p_1^{\gamma_1}p_2^{\gamma_2}\cdots p_k^{\gamma_k}</p>
<p>其中\textcolor{blue}{0 \le \beta_i,\gamma_i \le \alpha_i (i&#x3D;1,2,\cdots,k)}</p>
<p>则rs \iff \beta_i \le \gamma_i(i&#x3D;1,2,\cdots,k)</p>
<blockquote>
<p>因为我们对<code>整数r</code> 和<code>整数s</code>做了<code>素数因子分解</code>，从<code>形式上来看</code>，应该如此。</p>
<p>如：r &#x3D; 8 &#x3D; 2^3, s &#x3D; 32 &#x3D; 2^5 \implies r s</p>
</blockquote>
<p>因此，<code>偏序集</code>(X_n^*, )正是<code>大小分别为</code>\alpha_1 + 1, \alpha_2 + 2, \cdots, \alpha_k + 1<code>的k个线性序的直积</code></p>
<p>则\textcolor{blue}{\mu(1,n) &#x3D; \prod_{i&#x3D;1}^{k}{\mu(1,p_i^{\alpha_i})}}</p>
<blockquote>
<p>我们首先是对<code>整数n</code>进行<code>素数因子分解</code>，然后对于r,s \in X_n^*，我们再<code>逐个对应地比较</code>p_i<code>的大小</code>，</p>
<p>从而来确定<code>是否有</code>r s</p>
<p>因此，此处<code>乘积</code>含义为：对<code>所有的k个的</code>p_i<code>所相关的偏序关系</code>\mu(1,p_i)<code>进行了 直积运算</code></p>
</blockquote>
<p>则</p>
<p>因此</p>
<p>若是互不相同的素数的乘积</p>
<p>Q.E.D</p>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h4><p><code>欧拉φ函数</code>的定义是：\phi(n) &#x3D; S_n</p>
<p>其中，Sn &#x3D; \{k: 1\le k\le n, GCD(k,n) &#x3D; 1\}</p>
<blockquote>
<p>即\phi(n)为<code>不超过n且与n互素的正整数个数</code></p>
</blockquote>
<blockquote>
<p>提示：可以对X_n<code>中的任何整数a和b</code>计算出\mu(a,b)：\textcolor{green}{ab \implies \mu(a,b) &#x3D; \mu(1, \frac{b}{a})}</p>
</blockquote>
<p>求\phi(n)的<code>莫比乌斯函数</code></p>
<hr>
<p>设是的正因子\textcolor{blue}{S_n^d} &#x3D; \{k: 1\le k \le n, \textcolor{blue}{GCD(k,n) &#x3D; d}\}, \quad \text{(d是n的正因子)}</p>
<p>任何满足GCD(k,n) &#x3D; 1的 <code>整数k</code>都有且\textcolor{blue}{k &#x3D; dk’, \quad 1\le k’ \le n&#x2F;d且GCD(k’, n&#x2F;d) &#x3D; 1}的形式</p>
<p>因此S_n^d &#x3D; \phi(n&#x2F;d)</p>
<p>设F(X)为\phi(n)</p>
<p>并设G(n) &#x3D; \sum_{\{d: d n\}}{\phi(d)}</p>
<blockquote>
<p>\phi(d)等于满足GCD(k,n)&#x3D;1的1和n之间的整数k的个数。</p>
<p>而对于<code>每个这样的k</code>，对<code>某个满足dn的整数d</code>，<code>GCD(k,n) = d</code>成立。</p>
<p>则我们得到G(n) &#x3D; n</p>
</blockquote>
<p>故\textcolor{blue}{G(n) &#x3D; n &#x3D; \sum_{\{d:dn\}}{\phi(d)}}</p>
<p>则通过<code>莫比乌斯反解</code>得</p>
<blockquote>
<p>\mu(d)非0 当且仅当：</p>
<ol>
<li>d &#x3D; 1</li>
<li>d是<code>互不相同的素数</code>的乘积</li>
</ol>
<blockquote>
<p>则\mu(d) &#x3D; (-1)^r，其中<code>r 是d中互不相同的素数的个数</code>。设<code>这些互异素数除以n为</code>p_1,p_2,\cdots,p_r则</p>
<blockquote>
<p>其中的<code>乘积</code>对<code>所有整除n的互不相同的素数p</code>进行求积</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h4><p>计算<code>k个不同符号</code>a_1,a_2,\cdots,a_k<code>的循环n排列</code>的个数，其中的<code>每个符号</code>可以使用<code>任意多次</code>。</p>
<blockquote>
<p>即<code>计数多重集合</code>\{\infty \cdot a_1, \infty \cdot a_2, \cdots, \infty \cdot a_k\}<code>的循环n排列的个数</code></p>
</blockquote>
<p>定义<code>周期</code>：<code>移动后使得留下的循环字不变</code>的<code>顺时针循环移位</code>的最小整数d，且1 \le d \le n和d n</p>
<p>设h(n)是<code>可能使用符号</code>a_1,a_2,\cdots,a_k<code>的串</code>的个数</p>
<blockquote>
<p>注：h(n)依赖于k，但这里没有表示出来。</p>
<p>可以将<code>一个循环排列</code>一一对应到为<code>线性的字</code></p>
</blockquote>
<p>设f(m)是<code>长度为m且可能用到符号</code>a_1,a_2,\cdots,a_k<code>的串的个数</code></p>
<p>因为<code>每个串</code>有<code>1个周期d</code>，其中<code>d n</code></p>
<p>则\textcolor{blue}{h(n) &#x3D; \sum_{\{d: dn\}}{\frac{f(d)}{d}}}</p>
<p>若能够计算<code>周期为d长度为n的串的个数</code>，则<code>能够计算h(n)</code></p>
<p><code>设</code>\textcolor{blue}{g(m) &#x3D; \sum_{\{e:em\}}{f(e)}}</p>
<p><code>g(m)长度为m的串的总数</code>，故\textcolor{blue}{g(m) &#x3D; k^m}，因而</p>
<p>则</p>
<blockquote>
<p>和\because ed 和 dn \therefore d &#x3D; me</p>
<p>其中me n \implies m n&#x2F;e</p>
</blockquote>
<h3 id="Theory-3"><a href="#Theory-3" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Inference-1"><a href="#Inference-1" class="headerlink" title="Inference"></a>Inference</h4><h5 id="Content-9"><a href="#Content-9" class="headerlink" title="Content"></a>Content</h5><p>设X_n &#x3D; \{1,2,\cdots, n\}，且设F: \mathcal{P} \rightarrow \real为<code>定义在</code>X_n<code>的子集上的函数</code></p>
<p>设G: \mathcal{P} \rightarrow \real是<code>由定义如下的函数</code>G(K) &#x3D; \sum_{L \subseteq K}{F(L)}, \quad(K \subseteq X_n)</p>
<p>则F(K) &#x3D; \sum_{L \subseteq K}{(-1)^{K -L} G(L)}, \quad (K \subseteq X_n)</p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p>由之前的例子可知， <code>偏序集</code>(\mathcal{P}(X_n),\le)<code>的莫比乌斯函数</code>为(-1)^{K - L}</p>
<p>Q.E.D</p>
<h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Background-2"><a href="#Background-2" class="headerlink" title="Background"></a>Background</h5><p>若(X, \le_1)和(Y, \le_2)是两个<code>有限偏序集</code>，则在<code>X和Y的笛卡尔乘积</code>上<code>定义的偏序关系</code>\le_3为</p>
<p>而我们将(X \times Y, \le_3)叫做(X, \le_1)和(Y, \le_2)的<code>直积</code></p>
<blockquote>
<p>这类似于<code>编程语言</code>中<code>对于UDT的boolean compare(another object)</code>的定义。</p>
<p>比如说，我们有<code>Person &#123;String name, int age&#125;</code>，则对<code>String类型的属性name</code>和<code>int类型的属性age</code>所<code>调用的比较函数</code>是<code>不同的</code>，</p>
<p>而且，我们可以用这种方式<code>组合任意多的不同类型的属性的比较函数</code>。</p>
</blockquote>
<h5 id="Content-10"><a href="#Content-10" class="headerlink" title="Content"></a>Content</h5><p>设(X, \le_1)和(Y, \le_2)为<code>两个有限偏序集</code>，且<code>他们的莫比乌斯函数</code>分别为\mu_1和\mu_2，</p>
<p>设\mu为(X, \le_1)和(Y, \mu_2)<code>的直积的莫比乌斯函数</code>。则：</p>
<h5 id="Proof-5"><a href="#Proof-5" class="headerlink" title="Proof"></a>Proof</h5><blockquote>
<p>换句话说，<code>有限个有限偏序集的直积的莫比乌斯函数</code>是<code>他们的莫比乌斯函数的乘积</code></p>
</blockquote>
<h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Conent"><a href="#Conent" class="headerlink" title="Conent"></a>Conent</h5><p>设<code>F为定义在正整数集上的实值函数</code>，则定义<code>正整数集上的实值函数</code>\textcolor{blue}{G(n) &#x3D; \sum_{k: kn}F(k)}</p>
<p>则，对于<code>每一个正整数n</code>，我们有F(n) &#x3D; \sum_{k:kn}{\textcolor{green}{\mu(1, n&#x2F;k)}G(k)}</p>
<h5 id="Proof-6"><a href="#Proof-6" class="headerlink" title="Proof"></a>Proof</h5><blockquote>
<p><code>G(n)的定义</code> 仅依赖于<code>F在集合</code>X_n&#x3D;\{1,2,\cdots,n\}<code>的值</code></p>
</blockquote>
<p>Q.E.D</p>
<h3 id="Application-2"><a href="#Application-2" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1-1"><a href="#Application-1-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-11"><a href="#Content-11" class="headerlink" title="Content"></a>Content</h5><p>求<code>将n个非攻击型车</code>放置到<code>n × n棋盘</code>A &#x3D; [a_{ij}: 1 \le i, j \le n]的<code>方案数</code>：</p>
<h5 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h5><p>设X_n &#x3D; \{1,2,\cdots,n\}，设\mathcal{P}_n表示<code>全部n!个双射</code>f: X_n \rightarrow X_n</p>
<blockquote>
<p>1个f 就是 1个排列方案</p>
</blockquote>
<p>则，<code>将n个非攻击型车</code>放置到<code>n × n矩阵</code>A&#x3D;[a_{ij}]<code>的棋盘的方法数</code>为</p>
<blockquote>
<p>a_{if(i)}表示<code>第i行第f(i)列的值</code></p>
<p>上述式子的<code>乘积</code>用于<code>验证某个特定的放置方案</code>是否<code>合法</code>，若合法为1，否则为0</p>
<p>而<code>累加</code>用于<code>对所有可能的放置方案进行验证，并统计有几个合法方案</code></p>
</blockquote>
<hr>
<p>考虑<code>偏序集</code>(\mathcal{P}(X_n), \le)，X_n<code>的每个基数为k的子集S 从A挑选k个列的集合</code>，我们将<code>这些列组成的n × k的子矩阵 记为</code>\textcolor{blue}{A[S]}</p>
<p>设\mathcal{F}_n(S)表示<code>所有的函数</code>f: \{1,2,\cdots,n\} \rightarrow S<code>的集合</code></p>
<p>设\mathcal{G}_n(S)表示<code>满射函数的子集</code></p>
<p>则有\textcolor{blue}{\mathcal{F}_n(S) &#x3D; \cup_{T \subseteq S}{\mathcal{G}(T)}}</p>
<p><code>定义</code> <code>函数</code>F: \mathcal{P}(X_n) \rightarrow \real为\textcolor{blue}{F(S) &#x3D; \sum_{f \in \mathcal{G}(S)}{\prod_{i&#x3D;1}{a_{if(i)}}}, \quad (S \subseteq X_n)}</p>
<blockquote>
<p>F(X_n)即为plans：因为<code>函数f</code>不但是<code>满射函数</code>，而且是<code>双射函数</code></p>
</blockquote>
<p>设G(S) &#x3D; \sum_{T \subseteq S}{F(T)}, \quad (S \subseteq X_n)</p>
<p>则\textcolor{blue}{G(S) &#x3D; \sum_{g \in \mathcal{F}_n(S)}{\prod_{i&#x3D;1}{a_{ig(i)}}},\quad (S \subseteq X_n)}</p>
<p>根据<code>偏序集</code>(\mathcal{P}(X_n), \le)的<code>莫比乌斯函数</code>，得F(X_n) &#x3D; \sum_{S \subseteq X_n}{\textcolor{green}{(-1)^{n-S}}G(S)}</p>
<p>又G(S)<code>是关于所有的函数</code>g: X_n \rightarrow S<code>对</code>a_{1g(1)}, a_{2g(2), \cdots, a_{ng(n)}}<code>的求和</code>,故它的值为：</p>
<p>G(S) &#x3D; \prod_{i&#x3D;1}^n{(\sum_{j \in S}}{a_{ij})}</p>
<blockquote>
<p>也就是说，G(S)是对A[S]的<code>每行上的元素先求和，再乘积</code></p>
</blockquote>
<p>则</p>
<blockquote>
<p>上式表明了一种<code>把n个非攻击型车放置到n × n的棋盘上的方案数</code>的计算方法：</p>
<p>选出<code>列的一个子集</code>，计算<code>这些列上的所有元素的和</code>，<code>再把这些和相乘起来</code>，加上<code>适当的符号</code>，并对<code>所有列的选择求和</code>。（<code>被加数</code>的个数 &#x3D; <code>大小为n的集合的子集的个数</code>）</p>
</blockquote>
<blockquote>
<p>我们<code>常规的解法是：将棋盘矩阵A的每一行视为一个对象</code>，而<code>该解法是：将棋盘矩阵A的每一列视为一个对象</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/29/counting-the-pigeonhole-theorem-ramsey-theorem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/counting-the-pigeonhole-theorem-ramsey-theorem/" class="post-title-link" itemprop="url">Combinatorics - The Pigeonhole Principle & Ramsey Theorem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-29 18:48:07" itemprop="dateCreated datePublished" datetime="2022-03-29T18:48:07+00:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-Pigeonhole-Principle"><a href="#The-Pigeonhole-Principle" class="headerlink" title="The Pigeonhole Principle"></a>The Pigeonhole Principle</h1><h2 id="The-Simple-Pigeonhole-Principle"><a href="#The-Simple-Pigeonhole-Principle" class="headerlink" title="The Simple Pigeonhole Principle"></a>The Simple Pigeonhole Principle</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h4 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h4><p>如果把<code>n+1个物体</code>放入<code>n个盒子</code>中，那么<code>至少有一个盒子</code>将<code>包含两个或更多的物体</code>。</p>
<blockquote>
<p>如果将<code>n个物体</code>放入<code>n个盒子</code>中，且<code>没有任何一个盒子是空的</code>。则<code>每个盒子恰好包含1个物体</code></p>
</blockquote>
<blockquote>
<p>如果将<code>n个物体</code>放入<code>n个盒子</code>中，且<code>没有盒子被放入多于1个的物体</code>。则<code>则每个盒子恰好包含1个物体</code></p>
</blockquote>
<blockquote>
<p>如果<code>集合X</code>和<code>集合Y</code>是<code>有限集合</code>，并令f: X \rightarrow Y是<code>一个从X到Y的映射</code>：</p>
<ul>
<li>如果X &gt; Y，那么就不是<code>双射 (即一一对应)</code></li>
<li>如果X &#x3D; Y 且 该映射是<code>满射</code>，则该映射是<code>双射</code></li>
<li>如果X &lt; Y 且 该映射是<code>双射</code>，则该映射是<code>满射</code></li>
</ul>
</blockquote>
<h4 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h4><h5 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof 1"></a>Proof 1</h5><p>先在<code>n个盒子</code>里<code>放入1个物体</code>，则<code>剩下的1个物体</code> <code>所处的盒子</code>将<code>包含2个或更多的物体</code></p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof 2"></a>Proof 2</h5><p>对于<code>显而易见的结论</code>，可以采用<code>反证法</code>。</p>
<p>我们<code>假设</code> <code>没有任何盒子将包含两个或更多物体</code>，也就是说<code>每个盒子最多包含1个物体</code>。</p>
<p>所以，<code>n个盒子</code>应当<code>最多包含n个物体</code>。而n \lt n + 1，这与<code>我们的假设产生矛盾</code>。</p>
<p>Q.E.D</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1"><a href="#Application-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h5><p>给定m个整数a_1,a_2,\cdots,a_m，存在满足0 \le k \le l \le m的<code>整数k</code>和<code>整数l</code>，使得a_{k+1} + a_{k+2} + \cdots + a_l能被<code>整数m</code>整除。</p>
<h5 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h5><p>考虑<code>m个和</code>：</p>
<p>如果<code>这m个和之中</code>存在<code>一个和 可被m整除</code>，则结论成立。</p>
<p>因此，我们可以假设<code>这m个和</code>中<code>每一个除以m的余数</code>，<code>余数</code>等于1,2,\cdots,m-1中的一个数。</p>
<p>由于有<code>m个和</code>，而有<code>m-1个余数</code>，所以必定有<code>2个和 他们除以m的余数相同</code>。</p>
<p>因此，存在<code>整数k</code>和<code>整数l</code>，使得a_1+a_2+\cdots+a_k和a_1+a_2+\cdots+a_l <code>除以m有相同的余数r</code> 。即</p>
<p>将<code>两式相减</code>得</p>
<p>因此，存在满足条件的<code>整数k</code>和<code>整数l</code>，使得结论成立。</p>
<blockquote>
<p>这里的关键点在于，如果我们将<code>前缀和k</code>和<code>前缀和l</code>分别表示成<code>前缀和 = p * m + r的形式</code>。由于r_1 &#x3D; r_2 &#x3D; r，</p>
<p>所以我们只需要将<code>两个前缀和相减</code>即可得到<code>一个能被m整除的数:</code>(p_1 - p_2)m</p>
<p>而且，当我们对<code>前缀和进行相减</code>时，并不会<code>破坏所得序列的连续性</code>！</p>
</blockquote>
<p>Q.E.D</p>
<h4 id="Application-2"><a href="#Application-2" class="headerlink" title="Application 2"></a>Application 2</h4><h5 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h5><p>一位<code>国际象棋大师</code>有<code>11周的时间</code>来备战一场锦标赛。</p>
<ul>
<li>他决定<code>每天至少下一盘棋</code>。</li>
<li>但为了不使自己过于疲劳，他还决定<code>每周不能下超过12盘棋</code></li>
</ul>
<p>证明：存在<code>连续的若干天</code>，使得这位大师<code>恰好下了21盘棋</code></p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h5><p>我们设a_i表示<code>前i天所下的棋数的总和</code>。则有序列</p>
<p>因为<code>每天至少要下一盘棋</code>，<code>该序列</code>是<code>严格递增的</code> 且 a_1 \ge 1。</p>
<p>因为<code>每周不能下超过12盘棋</code>，则a_{77} \le 12 \times 11 &#x3D; 132</p>
<p>故 1 \le a_1 \le a_2 \le \cdots \le a_{77} \le 132</p>
<p>故22 \le a_1 + 21 \le a_2 + 21 \le \cdots \le a_{77} +21 \le 153</p>
<p>构造新序列</p>
<p>则<code>这2 × 77 = 154个数字</code>\in \{1, 2, \cdots, 153\}这个<code>含有153个元素的集合</code>。</p>
<p>因此，<code>这154个数字</code>中<code>有两个数字是相等的</code>。</p>
<blockquote>
<p>题干中的<code>21盘棋</code>并非随意选取，<code>154 &gt; 11 * 21 = 153</code>，因而<code>21盘棋</code>正好是一个<code>阈值</code></p>
</blockquote>
<p>但由于\{a_1, a_2, \cdots, a_{77}\}中<code>没有相同的数字</code>，而\{a_1 + 21 , a_2 + 21, \cdots, a_{77} + 21\}中也<code>没有相同的数字</code>。</p>
<p>故存在<code>i</code>和<code>j</code>，使得a_i &#x3D; a_j + 21：大师在<code>第j+1天</code>，<code>第j+2天</code>，…，<code>第i天</code>总共下了<code>21盘棋</code></p>
<p>Q.E.D</p>
<h4 id="Application-3"><a href="#Application-3" class="headerlink" title="Application 3"></a>Application 3</h4><h5 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h5><p>从整数1,2,\cdots,200中选取101个整数，证明<code>其中的一个整数</code>可被<code>另一个整数</code>所整除。</p>
<h5 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h5><p>根据<code>任何整数都可以写成</code>2^k \times a \qquad (k \ge 0 \quad and \quad a \% 2&#x3D;1)的形式</p>
<p>对于<code>1和200之间的任何整数</code>，<code>a</code>是<code>100个数：1,3,5，...，199的总共100个数</code>中的一个数。</p>
<p>因为<code>总共选取101个整数</code>，则必定有<code>两个选取的整数</code>使得<code>存在相同的a</code>，即a_1 &#x3D; a_2 &#x3D; a</p>
<p>将<code>所选取的这2个数</code>表示为：2^{k_1} \times a和2^{k_2} \times a</p>
<p>因此，<code>其中一个数</code>必定是<code>另一个整数</code>的<code>2的倍数</code>。</p>
<p>Q.E.D</p>
<h4 id="Application-4-Chinese-Remainder-Theorem"><a href="#Application-4-Chinese-Remainder-Theorem" class="headerlink" title="Application 4: Chinese Remainder Theorem"></a>Application 4: Chinese Remainder Theorem</h4><h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><p>设<code>m</code>和<code>n</code>是<code>互素的正整数</code>，并设<code>a和b</code>为<code>整数</code>，其中0 \le a \le m - 1以及\textcolor{red}{0 \le b \le n -1}</p>
<p>则，存在<code>正整数x</code>,使得<code>x除以m的余数为a</code>，并且<code>x除以n的余数为b</code></p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p>将这个<code>正整数x</code>表示为如下形式：</p>
<hr>
<p>考虑这<code>n个整数</code>\textcolor{red}{a, m + a, 2m + a, \cdots, (n-1)m + a}</p>
<blockquote>
<p>这里我们让<code>p</code>取<code>b的所有可能取值</code>：0 \le b \le n-1</p>
</blockquote>
<p>这两个数<code>为</code>im + a<code>和</code>jm + a`且\textcolor{blue}{0 \le i \lt j \le n-1}</p>
<p>故存在<code>两个整数</code>q_i和q_j</p>
<p><code>两式相减</code>得</p>
<p>故<code>n是(j-i)m</code>的因子。又因为<code>m和n互素</code>，所以<code>只能</code> <code>n是j-i的因子</code>。</p>
<p>然而，\textcolor{blue}{0 \le i \lt j \le n-1 \Rightarrow 0 \lt j - i \le n - 1}，这告诉我们，<code>n不可能是j-i的因子</code>。故<code>与假设产生矛盾</code>。</p>
<p>所以，<code>这n个数中的每一个数</code> <code>除以n都有不同的余数</code>：也就是说，<code>n个数:</code>\textcolor{red}{a, 1, 2,…, n - 1} <code>中的每一个</code>都要作为余数而出现。</p>
<blockquote>
<p>注：在这个<code>反证法</code>中，我们不但证明了a, m+a, 2m+a, \cdots, (n-1)m + a除以<code>n</code> <code>所产生的余数都不相同</code>。</p>
<p>而且，还得出了<code>这n个余数就是</code>a, 1, 2, \cdots, n-1 而 <code>b</code>就包含在这些余数中！</p>
</blockquote>
<hr>
<p>若设<code>整数p</code>满足0 \le p \le n-1 ，使得 \textcolor{green}{x &#x3D; p \times m + a} <code>除以n的余数</code>为<code>b</code>。</p>
<p>则，对于某个<code>整数q</code>，有</p>
<p>Q.E.D</p>
<h4 id="Application-5"><a href="#Application-5" class="headerlink" title="Application 5"></a>Application 5</h4><h5 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h5><p><code>有理数a/b</code>最终可以表示成<code>十进制的循环小数</code></p>
<h2 id="The-Enhanced-Pigeonhole-Principle"><a href="#The-Enhanced-Pigeonhole-Principle" class="headerlink" title="The Enhanced Pigeonhole Principle"></a>The Enhanced Pigeonhole Principle</h2><h3 id="Definiton"><a href="#Definiton" class="headerlink" title="Definiton"></a>Definiton</h3><h4 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h4><p>设q_1, q_2, \cdots, q_n是正整数。如果将 q_1 + q_2 + \cdots + q_n - n + 1个<code>物体</code>放入<code>n个盒子</code>。</p>
<p>那么<code>或者第一个盒子至少含</code> q_1个物体，<code>或者第二个盒子至少含</code>q_2个物体，…，<code>或者第n个盒子至少含</code>q_n个物体</p>
<blockquote>
<p>通过令q_i &#x3D; 2，可以得到<code>The Simple Pigeonhole Principle</code></p>
</blockquote>
<h4 id="Proof-5"><a href="#Proof-5" class="headerlink" title="Proof"></a>Proof</h4><h5 id="Proof-1-1"><a href="#Proof-1-1" class="headerlink" title="Proof 1"></a>Proof 1</h5><p>先把q_i个<code>物体</code>放入<code>第i个盒子</code>。然后<code>从所有的盒子</code>中<code>取走n-1个物体</code>。</p>
<p>即使是对于<code>从每个盒子中取走1个物体</code>，那么<code>仍然有1个盒子没有被取走物体</code>。</p>
<p>Q.E.D</p>
<h5 id="Proof-2-1"><a href="#Proof-2-1" class="headerlink" title="Proof 2"></a>Proof 2</h5><p>使用<code>反证法</code>：<code>假设第i个盒子所含物体少于i个</code>。</p>
<p>则<code>总共需要的物体数量 &lt;=</code>(q_1 - 1) + (q_2 - 1) + \cdots + (q_i - 1) &#x3D; (q_1 + q_2 + \cdots + q_i) + n</p>
<p>与题干矛盾。</p>
<p>Q.E.D</p>
<h3 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1-1"><a href="#Application-1-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-7"><a href="#Content-7" class="headerlink" title="Content"></a>Content</h5><p>设n和r都是正整数。如果把<code>n(r-1)+1个物体</code>分配到<code>n个盒子</code>，那么<code>至少有1个盒子含有r个或更多的物体</code></p>
<h5 id="Proof-6"><a href="#Proof-6" class="headerlink" title="Proof"></a>Proof</h5><h6 id="Proof-1-2"><a href="#Proof-1-2" class="headerlink" title="Proof 1"></a>Proof 1</h6><p>我们仍然可以采用<code>组合计数</code>的方法来证明。</p>
<p>首先，将<code>r-1个物体</code>分别放入<code>n个盒子</code>，这样，<code>n个盒子的每个盒子均含有r-1个物体</code>。</p>
<p>接下来，我们考虑将<code>剩下的1个物体</code>随便地放入<code>n个盒子中的1个盒子</code>。</p>
<p>则<code>该盒子含有r个物体</code></p>
<p>Q.E.D</p>
<h6 id="Proof-2-2"><a href="#Proof-2-2" class="headerlink" title="Proof 2"></a>Proof 2</h6><p>我们可以采用<code>平均原理</code>来证明。</p>
<p>如果<code>至少有1个盒子含有r个或更多的物体</code>，则意味着<code>n个盒子中的每个盒子平均包含的物体数 &gt;= r-1个物体</code></p>
<blockquote>
<p>可以想象，如果<code>所有的n个盒子</code>都<code>恰好含r-1个物体</code>，则<code>平均数 = r-1</code>。</p>
<p>如果<code>平均数 &gt; r-1</code>则说明<code>至少有1个盒子包含超过r-1个物体，这个盒子拉高了平均值</code>，即等价地说：<code>这个盒子至少包含r个物体</code></p>
</blockquote>
<h4 id="Application-2-1"><a href="#Application-2-1" class="headerlink" title="Application 2"></a>Application 2</h4><h5 id="Content-8"><a href="#Content-8" class="headerlink" title="Content"></a>Content</h5><p>证明每个由n^2+1个实数构成的序列a_1,a_2,\cdots,a_{n^2+1} <code>或者含有长度为n+1的递增子序列</code>，<code>或者含有长度为n+1的递减子序列</code>。</p>
<blockquote>
<p>单调性不是严格的</p>
</blockquote>
<h5 id="Proof-7"><a href="#Proof-7" class="headerlink" title="Proof"></a>Proof</h5><h6 id="Proof-1-3"><a href="#Proof-1-3" class="headerlink" title="Proof 1"></a>Proof 1</h6><p><code>假设：不存在长度为n+1的递增子序列</code>。<code>证明：必然存在长度为n+1的递减子序列</code></p>
<p>对于k &#x3D; 1,2,\cdots,n^2+1，设 m_k为<code>从</code>a_k<code>开始的最长的递增子序列的长度</code>，则\textcolor{blue}{1 \le m_k \le n}</p>
<p>故：\textcolor{blue}{m_1, m_2, \cdots, m_{n^2+1}}是\textcolor{blue}{1,2,\cdots,n}之间的n^2 +1个整数</p>
<blockquote>
<p>如果存在某个m_k \gt n，则很显然结论成立。</p>
<p>故此处限定m_k \in \{1,2,\cdots, n\}</p>
</blockquote>
<p>根据<code>鸽巢原理</code>知，这n^2+1个整数中有n+1个整数是<code>相等的</code></p>
<blockquote>
<p>这是因为我们<code>假设：不存在长度为n+1的递增子序列</code></p>
<p>n \times n + 1 &#x3D; n^2 + 1</p>
</blockquote>
<p>令m_{k_1} &#x3D; m_{k_2} &#x3D; \cdots &#x3D; m_{k_{n+1}} , \quad (1 \le k_1 \le k_2 \cdots \le n^2 +1 )</p>
<p>假设对某个i &#x3D; 1,2,\cdots, n，存在a_{k_i} \lt a_{k_{i+1}}。</p>
<p>则由于k_i &lt; k_{i+1}，我们可以做成一个从a_{k_{i+1}}开始的最长的递增子序列，并将a_{k_i}放在前面而得到<code>一个从$a_&#123;k_&#123;i&#125;&#125;$开始的递增子序列</code>。</p>
<p>由于这意味着m_{k_i} \gt m_{k_{i+1}}，因此我们得出a_{k_{i}} \ge a_{k_{i+1}}的结论。</p>
<p>而这对每个i &#x3D; 1,2,\cdots, n均成立，则我们有a_{k_{1}} \ge a_{k_{2}} \ge \cdots \ge a_{k_{n+1}}</p>
<p>从而得出，a_{k_{1}}, a_{k_{2}},\cdots, a_{k_n+1}是<code>一个长度为k+1的递减子序列</code></p>
<h4 id="Application-3-1"><a href="#Application-3-1" class="headerlink" title="Application 3"></a>Application 3</h4><h5 id="Content-9"><a href="#Content-9" class="headerlink" title="Content"></a>Content</h5><p>有两个<code>碟子</code>，其中一个比另一个小，这<code>两个碟子</code>分别被<code>分成200个均等的扇形</code>。</p>
<ul>
<li>对<code>大碟子</code>：任选<code>100个扇形</code>着色为<code>红色</code>，任选<code>100个扇形</code>着色为<code>蓝色</code></li>
<li>对<code>小碟子</code>：<code>200个扇形</code>任意地<code>着色</code>为<code>红色</code>或<code>蓝色</code></li>
</ul>
<p>然后，将<code>小碟子</code>放在<code>大碟子</code>上，使得<code>它们的中心重叠</code>。证明：<code>存在某种对齐方案</code>使得<code>两个碟子上相同颜色重合的扇形数目</code> <code>至少为100个</code></p>
<blockquote>
<p>也就是说，这两个碟子 其实就是 同心圆</p>
</blockquote>
<h5 id="Proof-8"><a href="#Proof-8" class="headerlink" title="Proof"></a>Proof</h5><p>利用<code>平均原理</code></p>
<p>首先，将<code>大碟子</code> <code>固定住</code>。</p>
<p>则<code>小碟子上的每个扇形都存在200个可能位置</code>，且<code>小碟子上的每一个扇形</code> <code>都恰好在100个位置上与大碟子上的对应扇形颜色一致</code></p>
<blockquote>
<p>因为<code>大碟子的涂色 = 100个红色 + 100个蓝色</code>。<code>对于小碟子上的每一个扇形</code>，<code>这个扇形</code>与<code>大碟子的200个颜色中的100个颜色相一致</code></p>
</blockquote>
<p>故，在<code>考虑所有的200个位置</code>时，<code>颜色重合总数 = 小碟子上的扇形数 × 100 = 20000</code>。</p>
<blockquote>
<p>该乘法运算独立了<code>小碟子上的某个扇形</code>和<code>大碟子上的某个位置</code>，即形成<code>有序对（小碟子上的某个扇形，大碟子上的某个位置）</code>是<code>满足颜色一致的</code></p>
<p>因而，使用<code>笛卡尔乘积</code>可以得出，<code>这样的有序对数量 = 200 × 100 = 20000</code></p>
</blockquote>
<p>因此，<code>每一个位置上的平均颜色重合数 = 20000 / 200 = 100</code>。</p>
<blockquote>
<p>我们有<code>20000个 有序对（小碟子上的某个扇形，大碟子上的某个位置）</code>，则<code>分解该有序对</code>得到：</p>
<p>20000 &#x2F; 200 &#x3D; 100 个 <code>小碟子上的某个扇形</code> 将<code>满足颜色一致的条件</code></p>
</blockquote>
<p>从而，<code>必然存在某个位置</code>使得<code>满足颜色匹配数至少为100</code></p>
<p>Q.E.D</p>
<h2 id="Ramsey-Theorem"><a href="#Ramsey-Theorem" class="headerlink" title="Ramsey Theorem"></a>Ramsey Theorem</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>在<code>6个人（或更多人）中</code>，<code>或者有3个人，他们中的两个人互相认识</code>，<code>或者有3个人，他们中的两个人互相不认识</code>。</p>
<h4 id="Proof-9"><a href="#Proof-9" class="headerlink" title="Proof"></a>Proof</h4><p><img src="https://s2.loli.net/2022/03/29/mnaf9IgTF4AhX7W.png" alt="image-20220329161846149"></p>
<p>将<code>原问题</code>抽象为K_6 \rightarrow K_3, K_3</p>
<blockquote>
<p>K_n表示的是<code>n阶完全图</code>。我们对<code>边</code>进行<code>着色</code>：令<code>红色表示认识</code>，<code>蓝色表示不认识</code>。</p>
<p>因而，K_6 \rightarrow K_3, K_3含义为：无论如何使用<code>红色</code>和<code>蓝色</code>对K_6进行<code>着色</code>，总存在<code>1个红</code>K_3或者<code>1个蓝</code>K_3</p>
</blockquote>
<p>首先，假设K_6已经被<code>任意着色</code>，则取K_6中的<code>任意一点p</code>，那么<code>该点</code>连接了<code>5条边</code>。</p>
<p>则根据<code>鸽巢原理</code>，<code>该点</code> <code>或者连接至少3个红边</code>，<code>或者连接至少3个蓝边</code>。</p>
<p>不妨假设，<code>该点至少连接3个红边</code>，我们假设<code>这3条红边</code>由<code>点p</code>和<code>点a，点b，点c</code>所确定。</p>
<p>考虑<code>将a，b，c两两相连的边</code>：</p>
<ul>
<li>若<code>这些边都是蓝边</code>，则<code>点a，点b，点c</code>确定了一个<code>蓝</code>K_3</li>
<li>若<code>这些边有一条是红边（假设为连接a和b的边）</code>，则<code>点p，点a，点b</code>确定了一个<code>红</code>K_3</li>
</ul>
<h3 id="Content-10"><a href="#Content-10" class="headerlink" title="Content"></a>Content</h3><p>如果m \ge 2且n \ge 2是两个整数，则存在<code>正整数p</code>，使得K_p \rightarrow K_m, K_n</p>
<blockquote>
<p><code>Ramsey Number</code>：r(m, n)是使得K_p \rightarrow K_m, K_n成立的<code>最小的整数p</code>。</p>
<p>r(m, n) &#x3D; r(n, m)</p>
</blockquote>
<h3 id="Proof-10"><a href="#Proof-10" class="headerlink" title="Proof"></a>Proof</h3><p>证明r(2,n)&#x3D; n，则我们需要证明<code>2个不等式</code></p>
<ul>
<li><p>r(2,n) \le n：如果将K_n的<code>所有边</code>都着色为<code>红色</code>或<code>蓝色</code>。那么<code>或者得到</code>红红K_2，<code>或者得到</code>蓝K_n</p>
<blockquote>
<p>换句话说：只要我们给K_n着色<code>1条红边</code>，则可得到红K_2。但如果我们不给K_n着色<code>红边</code>，</p>
<p>也就是我们必须给K_n全部着色为<code>蓝边</code>，这样的话，我们就会得到蓝K_n</p>
</blockquote>
</li>
<li><p>r(2,n) \gt n-1：我们可以选择给K_{n-1}的<code>所有边</code>都着色为<code>蓝色</code>，则我们<code>既得不到红</code>K_2，<code>也得不到蓝</code>K_n</p>
<blockquote>
<p>实际上，无论如何着色都不可能得到<code>蓝</code>K_n：因为我们<code>只有n-1个人</code>，肯定不存在<code>n个人相互认识</code></p>
</blockquote>
</li>
</ul>
<p>Q.E.D</p>
<blockquote>
<p>r(2, n)和r(m, 2)称为<code>平凡Ramsey数</code></p>
</blockquote>
<hr>
<p>接下来，我们考虑更一般的情况。</p>
<p>使用<code>双重归纳法</code>证明的存在性\textcolor{blue}{证明r(m,n)的存在性}。</p>
<p>已证得r(2, n) &#x3D; n和r(m, 2) &#x3D; m。</p>
<p>现在<code>假设</code>m \ge 3且n \ge 3。取<code>归纳假设</code>为<code>r(m-1, n) 和 r(m, n-1) 存在</code></p>
<p>设\textcolor{blue}{p &#x3D; r(m-1, n) + r(m, n -1)}，证明K_p \rightarrow K_m, K_n</p>
<p>假设K_p已被<code>任意着色</code>，我们<code>任取</code>K_p中的<code>某点x</code>，并设R_x是<code>通过红边与点x相连的 点的集合</code>，B_x是<code>通过蓝边与点x相连的 点的集合</code>。</p>
<p>则</p>
<p>这意味着：</p>
<ol>
<li>R_x \ge r(m-1, n) 或</li>
<li>B_x \ge r(m, n - 1)</li>
</ol>
<blockquote>
<p>否则，将意味着 R_x + B_x \le \textcolor{red}{r(m-1,n) - 1} + \textcolor{blue}{r(m, n-1) - 1} &#x3D; p - 2，产生矛盾。</p>
</blockquote>
<hr>
<p>当情况1成立时：即R_x \ge r(m-1, n)成立。</p>
<p>设q &#x3D; R_x \ge r(m-1, n)，则考虑<code>由</code>R_x的点组成的K_q，则：</p>
<ol>
<li><p>或者K_q中有<code>m-1个点</code>（即K_p中的点）其所有边被着色为<code>红色</code>。（即存在红K_{m-1}）</p>
<blockquote>
<p>对于这种情况，我们可以将<code>点x</code>加入红红K_{m-1}后得到一个红红K_m，然后<code>完成Ramsey Theorem的证明</code></p>
</blockquote>
</li>
<li><p>或者K_q中有<code>n个点</code>其所有边被着色为<code>蓝色</code>。（即存在蓝K_n）</p>
<blockquote>
<p>对于这种情况，我们可以<code>立即完成Ramsey Theorm的证明</code>：因为我们<code>已经拥有了一个蓝</code>K_n</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>当情况2成立</code>时，与<code>情况1成立时</code>是<code>对称的</code></p>
</blockquote>
<p>当情况2成立时：即B_x \ge r(m, n -1)成立</p>
<p>设q &#x3D; B_x \ge r(m, n-1)，则考虑由的点组成的由B_x的点组成的K_q，则：</p>
<ol>
<li><p>或者K_q中有<code>m个点</code>其所有边被着色为<code>红色</code>（即存在红红K_m）</p>
<blockquote>
<p>对于这种情况，我们可以<code>立即完成Ramsey Theorem</code>的证明：因为我们<code>已经拥有了一个红</code>K_m</p>
</blockquote>
</li>
<li><p>或者K_q中有<code>n-1个点</code>其所有边被着色为<code>蓝色</code>（即存在蓝蓝K_{n-1}）</p>
<blockquote>
<p>对于这种情况，我们可以将<code>点x</code>加入蓝蓝K_{n-1}后得到一个蓝蓝K_n，然后<code>完成Ramsey Theorem的证明</code></p>
</blockquote>
</li>
</ol>
<hr>
<p>综上，对于所有的整数m, n \ge 2，数r(m, n)存在</p>
<p>Q.E.D</p>
<blockquote>
<p>上述定理不但<code>确定了Ramsey Number的存在性</code>，而且给出了<code>上界</code></p>
<p>原因在于：我们所设的f(m,n)与r(m,n)具有<code>相同的递归表达式</code>和<code>相同的初始条件</code></p>
</blockquote>
<h3 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h3><h4 id="Generalization-1"><a href="#Generalization-1" class="headerlink" title="Generalization 1"></a>Generalization 1</h4><p>可以将<code>Ramsey Theorem</code> 拓展到<code>任意多种颜色</code>。即<code>存在最小整数p</code>，使得</p>
<p>我们称这个<code>最小整数p</code>为Ramsey Numeer：r(n_1, n_2, n_3)</p>
<h4 id="Generalization-2"><a href="#Generalization-2" class="headerlink" title="Generalization 2"></a>Generalization 2</h4><p>前面所说的<code>Ramsey Theorem</code>针对的是<code>点对（即两个元素的子集）</code>。现在我们可以拓展到<code>t个元素的子集</code>。</p>
<p>则K_n^t, \quad t \ge 1是<code>n元素集合中所有t元素子集 的集合</code>。</p>
<p>即：给定整数整数p \ge 2，整数整数q_1, q_2, \cdots, q_k \ge t ，存在一个<code>整数p</code>，使得：</p>
<p>成立。</p>
<blockquote>
<p>即存在<code>整数p</code>，使得如果给<code>p元素集合中的每一个t元素子集</code>着色<code>k种颜色中的一种</code>，则：或者存在个元素，这些元素的所有子集都被涂色为或者存在q_1个元素，这些元素的所有t子集 都被涂色为c_1，</p>
<p>或者存在个元素，这些元素的所有子集都被涂色为或者存在q_2个元素，这些元素的所有t子集都被涂色为c_2，…，或者存在个元素，这些元素的所有子集都被涂色为或者存在q_k个元素，这些元素的所有t子集都被涂色为c_k</p>
<p>而这个<code>整数p</code>即为<code>Ramsey Numebr</code>r_t(q_1, q_2,\cdots, q_k)</p>
</blockquote>
<blockquote>
<p>当t &#x3D; 1时，<code>Ramsey Theorem</code> &#x3D; <code>The Enhanced Pigeonhole Principle</code></p>
<p>当t &#x3D; 2时，<code>Ramsey Theorem</code> &#x3D; <code>Ramsey Theorem: r(m, n)</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/28/divide-and-conquer-checkerboard-covering-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/divide-and-conquer-checkerboard-covering-problem/" class="post-title-link" itemprop="url">Divide and Conquer - Checkerboard Covering Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-28 21:32:42" itemprop="dateCreated datePublished" datetime="2022-03-28T21:32:42+00:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Checkerboard-Covering-Problem"><a href="#Checkerboard-Covering-Problem" class="headerlink" title="Checkerboard Covering Problem"></a>Checkerboard Covering Problem</h1><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>在<code>大小为m × n的棋盘</code>上的<code>b格牌(b-ominoe)</code>的一个<code>完美覆盖</code>满足：</p>
<ol>
<li>没有两个b格牌存在<code>重叠</code></li>
<li>每一个b格牌<code>恰好覆盖</code>棋盘上的b个方格</li>
<li>棋盘上的所有方格被覆盖</li>
</ol>
<p>求存在多少种<code>完美覆盖</code>方案数？</p>
<blockquote>
<p><code>b格牌</code>是指<code>1 × b 的条形牌</code>。<code>多米诺骨牌</code>是<code>2格牌</code>，而<code>单牌</code>是<code>1格牌</code></p>
</blockquote>
<h2 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h2><h3 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h3><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p><code>m x n 的棋盘</code>有<code>b格牌</code>的<code>完美覆盖</code> <code>当且仅当</code> <code>b</code>是<code>m的因子</code>或<code>n的因子</code></p>
<h5 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h5><ul>
<li>为棋盘的每个方格进行涂色</li>
</ul>
<p>我们可以把<code>棋盘覆盖问题</code>转化为<code>棋盘着色问题</code>，<code>一个b格牌</code>将会<code>覆盖连续的b个方格</code>，则我们为<code>这连续的b方格</code>涂上<code>b种不同的颜色</code>。</p>
<p>则我们可以知道：<code>棋盘覆盖问题</code>中存在<code>完美覆盖</code>，当且仅当，<code>棋盘着色问题</code>中的<code>着色</code>的<code>b种颜色的方格的数量均相同</code></p>
<p><img src="https://s2.loli.net/2022/03/28/mH5xE3gscMZviFw.png" alt="image-20220328204642533"></p>
<ul>
<li>减小棋盘的规模</li>
</ul>
<p>对于<code>m x n 的棋盘</code>的<code>棋盘覆盖问题</code>，如果我们<code>去掉1个b × b规模的棋盘</code>，不会影响<code>原问题</code>的<code>棋盘覆盖</code>的存在性。</p>
<blockquote>
<p>但这并不意味着<code>随意地从棋盘中挖走方格</code>可以保证<code>两个问题的等价</code>。我们这里仅说明<code>b × b规模的棋盘</code></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/03/28/jxrsqlXEY9IBaky.png" alt="image-20220328210416461"></p>
<h5 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h5><p>我们欲<code>证明</code> <code>m x n 的棋盘</code>有<code>b格牌</code>的<code>完美覆盖</code> <code>当且仅当</code> <code>b</code>是<code>m的因子</code>或<code>n的因子</code>。</p>
<hr>
<p>必要性：如果<code>b</code>是<code>m的因子</code>或<code>n的因子</code>，则显然存在<code>完美覆盖</code></p>
<hr>
<p>充分性：</p>
<p>将<code>m × n 的棋盘</code>表示为下列方式</p>
<p>假设<code>存在完美覆盖</code>但<code>b</code>不是<code>m的因子</code>或<code>n的因子</code>，即<code>r ≠ 0</code>且<code>s ≠ 0</code>。</p>
<p>则，我们将<code>m × n的棋盘</code> <code>分割</code>成3个<code>部分</code>：</p>
<ol>
<li><code>上方的pb × n部分</code>：<code>每一种颜色</code>出现<code>p × n 次</code></li>
<li><code>左下角的r × qb部分</code>：<code>每一种颜色</code>出现<code>q × r次</code></li>
<li><code>右下角的r × s部分</code>：我们认为<code>每一种颜色</code>出现次数<code>也必定要相同</code>。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/28/rsJEzup6Ll4ghwy.png" alt="image-20220328210804466"></p>
<p>对于<code>右下角的r × s部分</code>，我们根据<code>涂色规则</code>知道：<code>颜色1</code>在每一行都出现1次。</p>
<p>故：<code>颜色1</code>在<code>右下角r × s部分</code>共出现<code>r次</code>。</p>
<p>而<code>右下角r × s部分</code>总共有<code>rs个方格</code>。如果<code>b种颜色各出现r次</code>，则需要<code>rb个方格</code></p>
<p>但由于<code>s &lt; b</code>，故我们无法满足这个要求。</p>
<p>故<code>r</code>和<code>s</code>不能同时非零，即<code>b</code>必须是<code>m的因子</code>或<code>n的因子</code></p>
<blockquote>
<p>换句话说：rs &#x3D; rb,\quad s \lt b \Rightarrow r &#x3D; 0 \ or\ s &#x3D; 0</p>
</blockquote>
<p>Q.E.D</p>
<blockquote>
<p>该定理的另一种解释方式：</p>
<p><code>m × n棋盘</code>存在<code>b格牌</code>的<code>完美覆盖</code>当且仅当<code>它有平凡完美覆盖</code> （即<code>只使用水平放置</code>或<code>只使用垂直放置</code>的<code>完美覆盖</code>。）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/28/counting-pascals-triangle-binomial-coefficient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/counting-pascals-triangle-binomial-coefficient/" class="post-title-link" itemprop="url">Combinatorics - Pascal's Triangle & Binomial Coefficient</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-28 17:15:12" itemprop="dateCreated datePublished" datetime="2022-03-28T17:15:12+00:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Binomial-Coefficient"><a href="#Binomial-Coefficient" class="headerlink" title="Binomial Coefficient"></a>Binomial Coefficient</h1><h2 id="Binomial-Coefficent"><a href="#Binomial-Coefficent" class="headerlink" title="Binomial Coefficent"></a>Binomial Coefficent</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h3 id="Diagram-Pascal’s-Triangle"><a href="#Diagram-Pascal’s-Triangle" class="headerlink" title="Diagram: Pascal’s Triangle"></a>Diagram: Pascal’s Triangle</h3><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><h5 id="Property-1"><a href="#Property-1" class="headerlink" title="Property"></a>Property</h5><h5 id="Property-Pascal’s-Formula"><a href="#Property-Pascal’s-Formula" class="headerlink" title="Property: Pascal’s Formula"></a>Property: Pascal’s Formula</h5><h6 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h6><ol>
<li><p>三角形中某个数的值 &#x3D; 该数正上方的数 + 该数的直接左邻项</p>
</li>
<li><p>从三角形左上角到达项（n，k）的所有路径数</p>
<blockquote>
<p>根据该解释，可得\binom{n}{0} &#x3D; 1和\binom{n}{1}</p>
</blockquote>
</li>
<li><p><code>从三角形左上角到项（n，k）</code>的路径数 &#x3D; <code>从(n,k-1)到(n,k)</code>的路径数+<code>从(n-1, k-1)到(n,k)</code>的路径数</p>
</li>
</ol>
<h5 id="Property-2"><a href="#Property-2" class="headerlink" title="Property"></a>Property</h5><h6 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation"></a>Explanation</h6><ol>
<li><code>n元素集合的k子集的个数</code></li>
</ol>
<h5 id="Property-3"><a href="#Property-3" class="headerlink" title="Property"></a>Property</h5><h5 id="Property-Triangular-Number"><a href="#Property-Triangular-Number" class="headerlink" title="Property: Triangular Number"></a>Property: Triangular Number</h5><h6 id="Explanation-2"><a href="#Explanation-2" class="headerlink" title="Explanation"></a>Explanation</h6><ol>
<li><code>以数n规模堆垒起来的三角形中的点个数</code></li>
</ol>
<h5 id="Property-Tetraederzahl"><a href="#Property-Tetraederzahl" class="headerlink" title="Property: Tetraederzahl"></a>Property: Tetraederzahl</h5><h6 id="Explanation-3"><a href="#Explanation-3" class="headerlink" title="Explanation"></a>Explanation</h6><ol>
<li><code>以数n规模堆垒起来的四面体中的点个数</code></li>
</ol>
<h2 id="Binomial-Theorem"><a href="#Binomial-Theorem" class="headerlink" title="Binomial Theorem"></a>Binomial Theorem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><h4 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h4><p>设n是正整数。对所有的x和y，有</p>
<h4 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h4><h5 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof 1"></a>Proof 1</h5><p>基本思路是<code>展开</code>原式后通过<code>组合计数</code>得出2^n项的各项表示。</p>
<p>对<code>(x+y)^n</code>进行<code>展开</code>得</p>
<p>考虑对于<code>n项中的每一项</code>，可以做出<code>2种选择</code></p>
<ol>
<li>选择<code>项x</code></li>
<li>选择<code>项y</code></li>
</ol>
<p>从<code>n项中选取k个项y</code>，则<code>剩下的n-k项选取项x</code>。又0 \le k \le n，得出</p>
<p>其中\binom{n}{k}表示项x^{n-k}y^k出现的次数。</p>
<p>Q.E.D</p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof 2"></a>Proof 2</h5><p>通过采用<code>数学归纳法</code>得出。</p>
<hr>
<p>考虑n&#x3D;1的情况。</p>
<p>左式(x+y)^1 等同于 右式\binom{1}{0}x^{1-0}y^0 + \binom{1}{1}x^{1-1}y^1</p>
<p>显然成立</p>
<hr>
<p>我们<code>假设</code> <code>该公式对于正整数n成立</code>，<code>证明</code> <code>用正整数n+1代替n时，该公式仍然成立</code></p>
<p>即，我们需<code>证明</code>：</p>
<p>将(x+y)^n用<code>另一种方式表示</code></p>
<p>于是，把<code>n+1</code>替换为<code>n</code>可得</p>
<p>Q.E.D</p>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h4><h5 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h5><p>设n是正整数，对于所有的x，有</p>
<h4 id="Theorem-2-Sperner-Theorem"><a href="#Theorem-2-Sperner-Theorem" class="headerlink" title="Theorem 2: Sperner Theorem"></a>Theorem 2: Sperner Theorem</h4><h5 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h5><p>设S是<code>n元素集合</code>，S的一个<code>反链 (AntiChain)</code>是<code>集合S的一个子集的集合</code>\mathcal{A}，其中\mathcal{A}中的子集<code>不相互包含</code> （或者说对于\mathcal{A}中<code>每一对子集</code>，<code>两者中没有一个包含于另一个</code>）</p>
<p>如，<code>集合S = &#123;a, b, c, d&#125;</code>的<code>1个反链</code>为\mathcal{A} &#x3D; \{\{a,b\}, \{b,c,d\}, \{a,d\}, \{a,c\}\}</p>
<hr>
<p>设S是<code>n元素集合</code>，S的一个<code>链 (Chain)</code>是<code>集合S的一个子集的集合</code>\mathcal{C}，其中\mathcal{C}中的<code>每一对子集</code>，<code>总有一个包含在另一个</code>之中</p>
<p>如，<code>集合S = &#123;1, 2, 3, 4, 5&#125;</code>的<code>1个链</code>为\mathcal{C} &#x3D; \{\{2\}, \{2, 3, 5\}, \{1, 2, 3, 5\}\}</p>
<p><code>最大链</code>指的是<code>无法再加入更多的S中的子集的链</code></p>
<p>可以通过为集合S &#x3D; \{1,2,\cdots,n\}确立<code>1个排列</code>来得出<code>1个最大链</code>。从而<code>最大链</code>的数目&#x3D;n!，且大小均为n。</p>
<blockquote>
<p>比如说，如果S&#x3D;\{1,2,3,4,5\}，则<code>1个排列(3,2,1,5,4)</code>表示的是：<code>第一轮</code>并入<code>元素3</code>，<code>第二轮</code>并入<code>元素2</code> …这样的<code>1个最大链</code></p>
</blockquote>
<p>对于<code>给定某个特定的</code> A &#x3D; k且A \subset S，则<code>包含A的最大链</code>总共有k!\times(n-k)!个：<code>k!个包含于A的集合</code>和<code>(n-k)!个包含A的集合</code></p>
<h5 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h5><p>一种<code>构造</code> <code>反链</code>的方法是：首先选择一个整数k \le n，然后取\mathcal{A}_k为<code>S的所有k子集</code>，那么\mathcal{A}_k就是一个<code>反链</code>。</p>
<p>通过<code>这种方式</code>构造的<code>反链</code>最多含有\binom{n}{\lfloor n&#x2F;2\rfloor}个集合。</p>
<p>而我们<code>无法通过让k选择多个值</code>来<code>构造一个更大的反链</code></p>
<h5 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h5><p>若\mathcal{A}是一个<code>反链</code>，<code>有序对（A，C）</code>指：<code>集合A</code>包含于<code>反链</code>\mathcal{A}，<code>最大链C</code>是包含<code>集合A</code>的<code>最大链</code>。令<code>有序对(A,C)的数量 = β</code></p>
<p>因为<code>链和反链的交集最多只有1个元素（元素是集合）</code>，而<code>最大链的个数</code>为n!，故\beta \le n!</p>
<p>对于<code>反链</code>\mathcal{A}中的<code>子集A</code>，设\alpha_k是<code>反链</code>A中<code>大小为k的子集</code>的个数。则\textcolor{blue}{\mathcal{A} &#x3D; \sum_{k&#x3D;0}^n{\alpha_k}}</p>
<p>于是</p>
<blockquote>
<p>对于<code>有序对(A, C)</code>的数量计算，可以视为是由<code>集合A</code>和<code>集合C</code>的<code>笛卡尔乘积</code>而得到。β的值即为两个集合大小的乘积。</p>
</blockquote>
<p>根据\beta \le n!，得出不等式</p>
<p>当k &#x3D; \lfloor n&#x2F;2\rfloor 时，\binom{n}{k}取得最大值。故</p>
<blockquote>
<p>\alpha_k的不等式告诉我们，在k &#x3D; \lfloor n&#x2F;2\rfloor时，可以构造出<code>含n个元素的集合S</code>的<code>最大的反链</code></p>
</blockquote>
<h3 id="Property-4"><a href="#Property-4" class="headerlink" title="Property"></a>Property</h3><h4 id="Property-5"><a href="#Property-5" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h5><h4 id="Property-6"><a href="#Property-6" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><h5 id="Explanation-4"><a href="#Explanation-4" class="headerlink" title="Explanation"></a>Explanation</h5><blockquote>
<p><code>含奇数个元素的集合</code> 和<code>含偶数个元素的集合</code>的数量一样多。</p>
</blockquote>
<p>根据</p>
<p>故</p>
<blockquote>
<p>假设要<code>从n个元素中</code>取出一个<code>大小为奇数的集合</code>，对于<code>前面的n-1个元素</code>都有<code>2种选择</code>，而对于<code>第n个元素</code>却<code>只有1种选择</code>：当面对<code>是否选取第n个元素</code>时，如果<code>当前已取的元素个数</code>为奇数，则<code>第n个元素</code>不能取。否则就必须要<code>取走第n个元素</code></p>
</blockquote>
<h4 id="Property-7"><a href="#Property-7" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h5><p>从等式(1+x)^n&#x3D;\sum_{k&#x3D;0}^{n}{\binom{n}{k}x^k}开始，通过<code>交替地</code> <code>关于x求导</code>和<code>乘以x</code>，我们可以得到\sum_{k&#x3D;1}^n{k^p\binom{n}{k}}相对于任何正整数p的恒等式。</p>
<h5 id="Explanation-5"><a href="#Explanation-5" class="headerlink" title="Explanation"></a>Explanation</h5><p>当p&#x3D;1时</p>
<h4 id="Property-8"><a href="#Property-8" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h5><p><code>帕斯卡三角形</code>上的<code>各行上的数字的平方和</code>满足</p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h5><p>假设<code>集合S</code>是<code>一个有2n个元素的集合</code>，我们将<code>集合S</code>划分为<code>含n个元素的集合A</code>和<code>含n个元素的集合B</code>。</p>
<p>则，对于<code>集合S的n子集</code>，可以看作是由<code>k个来自集合A的元素</code>和<code>n-k个来自集合B的元素</code>所组成。</p>
<p>由于0 \le k \le n，故可以将 <code>S的n子集的集合</code>划分为<code>n+1个部分</code>：C_0, C_1, C_2, \cdots, C_n</p>
<blockquote>
<p>C_k是集合的集合：C_k的每个元素 代表 <code>一个由k个来自A的元素和n-k个来自集合B的元素所构成</code>的<code>集合S的n子集</code>。</p>
</blockquote>
<p>其中，C_k \quad (0 \le k \le n)表示：该<code>部分</code>中的<code>每个集合</code>的元素由<code>k个来自集合A的元素</code>和<code>n-k个来自集合B的元素</code></p>
<p>故</p>
<hr>
<p>现在考虑C_k的数量。</p>
<hr>
<p>综上，</p>
<p>Q.E.D</p>
<h4 id="Property-9"><a href="#Property-9" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-7"><a href="#Content-7" class="headerlink" title="Content"></a>Content</h5><p>设n是正整数，则<code>二项式系数序列</code>\binom{n}{0},\binom{n}{1}, \binom{n}{2}, \cdots, \binom{n}{n}是<code>单峰(Unimodal)序列</code></p>
<h5 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h5><p><code>证明序列的单调性</code>即<code>证明该序列的通项函数的单调性</code>。可采用<code>作商法</code></p>
<p>因此，<code>二项式系数序列</code>的<code>单调性</code>取决于：<code>n-k+1</code>和<code>k</code>的之间的关系。</p>
<h4 id="Property-10"><a href="#Property-10" class="headerlink" title="Property"></a>Property</h4><h5 id="Content-8"><a href="#Content-8" class="headerlink" title="Content"></a>Content</h5><p>对于正整数n，<code>二项式系数</code>\binom{n}{0}, \binom{n}{1}, \binom{n}{2}, \cdots\,\binom{n}{n}中的最大者为\binom{n}{\lfloor n&#x2F;2\rfloor} &#x3D; \binom{n}{\lceil n&#x2F;2\rceil}</p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p>根据<code>二项式系数序列的单调性</code>可证。</p>
<h2 id="Polynomial-Coefficient"><a href="#Polynomial-Coefficient" class="headerlink" title="Polynomial Coefficient"></a>Polynomial Coefficient</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>对于<code>二项式系数</code>的<code>多项式系数</code>表示方法如下</p>
<blockquote>
<p>注意，<code>二项式系数的符号</code>的定义和<code>多项式系数的符号</code>的定义不同。</p>
<p><code>二项式系数</code>中是选择是<code>逻辑型的</code>，<code>只有2种选择</code>，所以如果选中<code>k个A集合元素</code>，则<code>必定选择n-k个B集合元素</code></p>
</blockquote>
<h3 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h3><h4 id="Theorem-1-1"><a href="#Theorem-1-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h4><h5 id="Content-9"><a href="#Content-9" class="headerlink" title="Content"></a>Content</h5><p>设n是正整数。对于所有的x_1,x_2,\cdots,x_t 。有</p>
<h5 id="Proof-5"><a href="#Proof-5" class="headerlink" title="Proof"></a>Proof</h5><p>证明思路同<code>二项式系数</code>，将<code>多项式</code>进行<code>展开</code>。得到<code>n个因子</code>，<code>每个因子含有t项</code>。</p>
<p>最终所得的结果含有t_n项。</p>
<blockquote>
<p>同理，<code>二项式系数</code>和<code>多项式系数</code>的含义都表明<code>与之相对应的项</code>所<code>出现的次数</code>。<code>每1次出现</code>都使得<code>系数+1</code></p>
</blockquote>
<p>这里给出从<code>二项式系数</code>推导出<code>多项式系数</code>的方式</p>
<h2 id="Newton’s-Binomial-Coefficient"><a href="#Newton’s-Binomial-Coefficient" class="headerlink" title="Newton’s Binomial Coefficient"></a>Newton’s Binomial Coefficient</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p>设\alpha是<code>实数</code>。则对于所有满足0 \le x \lt y的x和y，有</p>
<p>其中</p>
<p>对于<code>牛顿二项式定理</code>，当\alpha是正整数时，即为<code>二项式定理</code>。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><ol>
<li>导出无穷级数\frac{1}{(1-z)^n}</li>
<li>求任意精度的平方根: 见<code>高等数学</code>中关于<code>无穷级数</code>的章节。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/27/counting-schroder-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/27/counting-schroder-number/" class="post-title-link" itemprop="url">Combinatorics -  Schroder Number</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-27 21:08:14" itemprop="dateCreated datePublished" datetime="2022-03-27T21:08:14+00:00">2022-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lattice-amp-Schroder-Number"><a href="#Lattice-amp-Schroder-Number" class="headerlink" title="Lattice &amp; Schroder Number"></a>Lattice &amp; Schroder Number</h1><h2 id="Lattice"><a href="#Lattice" class="headerlink" title="Lattice"></a>Lattice</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>考虑坐标平面上<code>具有整数坐标的点的</code> <code>整格 (Integral Lattice)</code>。</p>
<p>给定2个点</p>
<p><code>从(p,q)到(r,s)的矩形格路径 (Rectangular Lattice Path)</code>指的是这样的一条路径：<code>从(r,s)到(p,q)</code>由 <code>水平步(Horizontal Step) H = (1,0)</code>和<code>垂直步 (Vertical Step) V = (0, 1)</code>所组成。</p>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h4><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p>从<code>(r,s)到(p,q)的矩形格路径的数目</code>等于<code>二项式系数</code>：</p>
<h5 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h5><p><code>从(r,s)到(p,q)的路径</code>总共包含<code>(p-r)+(q-s)个水平步和垂直步</code>，</p>
<p>因此我们需要在<code>(p-r)+(q-s)个步</code>中<code>选择</code> <code>(p-r)个水平步</code>或者<code>确定(q-s)个垂直步</code>。</p>
<p>即使用<code>组合数的概念</code></p>
<h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem 2"></a>Theorem 2</h4><h5 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h5><p>设n是非负整数，则<code>从(0,0)到(n,n)的下对角线矩形格路径</code>的数目&#x3D;<code>第n个Catalan数</code></p>
<h5 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h5><p>考虑<code>Catalan数的经典模型</code>，令<code>水平步为+1元素</code>，<code>垂直步为-1元素</code>。</p>
<p>则实际上我们要求的是<code>由n个水平步和n个垂直步所构成的2n个元素的所有序列</code>中<code>可接受序列的数量</code></p>
<blockquote>
<p>可以<code>接触对角线</code>，这并不算<code>越过对角线</code></p>
</blockquote>
<p>Q.E.D</p>
<h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem 3"></a>Theorem 3</h4><h5 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h5><p>设p和q是正整数，且p \ge q，则<code>从(0,0)到(p,q)的下对角线矩形格路径(Subdiagonal Rectangular Lattice Path)</code>的数目等于</p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h5><p><img src="https://s2.loli.net/2022/03/27/TxfX5UbQcAoHRit.png" alt="image-20220327183907639"></p>
<p>设<code>从(0,0)到(p,q)的穿过对角线的矩形格路径</code>\gamma<code>的数目</code>l(p,q)</p>
<p>设<code>从(0,0)到(p,q)的矩形格路径的数目</code>=\binom{p+q}{p}</p>
<p>l(p,q)的数目等于<code>从(0, -1)到(p, q-1)的接触到对角线y=x的矩形格路径</code>\gamma^\prime的数目相同</p>
<blockquote>
<p>矩形格路径\gamma^\prime相当于是将原路径\gamma<code>整体向下平移1个单位格</code>所得到的。如果<code>在路径</code>\gamma^\prime中<code>恰好接触到对角线y=x</code>，则意味着<code>在原路径</code>\gamma中，<code>恰好已经穿过了对角线1个单位格</code>！所以，我们实际上建立了路径\gamma^\prime和路径\gamma之间的<code>一一对应关系</code></p>
</blockquote>
<p>故，</p>
<p>从到的下对角线矩形格路径的数目从到的矩形格路径的数目从到的穿过对角线的矩形格路径的数目</p>
<hr>
<p>我们将路径\gamma^\prime <code>分解</code>为两部分：\gamma^\prime &#x3D; \gamma_1 + \gamma_2</p>
<p>其中，</p>
<p>\gamma_1指<code>从(0,-1)到该路径接触到的第一个对角线点(d,d)的路径</code></p>
<p>\gamma_2指<code>从(d,d)到(p, q-1)的路径</code></p>
<blockquote>
<p>注意：路径\gamma^\prime是指<code>接触到对角线的路径</code>，有可能<code>不止接触对角线1次</code></p>
</blockquote>
<p>然后，我们将\gamma_1关于对角线y&#x3D;x进行<code>反射</code>得到</p>
<p>\gamma_1^*是<code>从(-1,0)到该路径接触到的第一个对角线点(d,d)的路径</code></p>
<p>由于\gamma_1^*是\gamma_1关于对角线y&#x3D;x的反射，若令 \gamma^* &#x3D; \gamma_1^* + \gamma_2，则</p>
<p>\gamma*&#x3D;\gamma_1^*+\gamma_2 与\gamma^\prime&#x3D;\gamma_1+\gamma_2之间存在<code>一一对应关系</code></p>
<p>故l(p,q)等于<code>从(-1,0)到(p,q-1)的矩形格路径的数目</code>，即</p>
<blockquote>
<p>注：由于\gamma_1^*是\gamma_1关于对角线y&#x3D;x进行<code>反射</code>而得到的。路径\gamma_1^*的<code>起点(-1,0)</code>和<code>终点(p, q-1)</code> 分别<code>位于对角线y=x的两侧</code>。</p>
<p>故：<code>所有的从(-1,0)到(p,q-1)的矩形格路径</code>均会<code>穿过对角线</code>！</p>
</blockquote>
<hr>
<p>综上，<code>从(0,0)到(p,q)的下对角线矩形格路径</code>的数目等于</p>
<h4 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="Theorem 4"></a>Theorem 4</h4><h5 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h5><p><code>HVD格路径</code>指的是允许<code>水平步 (Horizontal Step)</code>，<code>垂直步 (Vertical Step)</code>和<code>对角步 (Diagonal Step)</code>的格路径。</p>
<p>设K(p,q)是<code>从(0,0)到(p,q)的HVD格路径的数目</code></p>
<p>设K(p,q:rD)是<code>从(0,0)到(p,q)的恰好使用r个对角步的HVD格路径的数目</code></p>
<h5 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h5><p>设r \le min\{p, q\}，则</p>
<p>以及</p>
<h5 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h5><p>如果<code>某条HVD格路径恰好使用了</code> <code>r个对角步</code>，则意味着<code>这条格路径必定恰好使用了</code> <code>p-r个水平步</code>和<code>q-r个垂直步</code></p>
<p>于是，K(p,q:rD)的值 等同于 <code>求多重集合&#123;(p-r) · H, (q-r) · V, r · D&#125;的排列数</code> 即：</p>
<p>Q.E.D</p>
<h4 id="Theorem-5"><a href="#Theorem-5" class="headerlink" title="Theorem 5"></a>Theorem 5</h4><h5 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h5><p>设R(p,q) \quad p \ge q为<code>从(0,0)到(p,q)的下对角线HVD格路径的数目</code></p>
<p>另外，设R(p,q:rD) 是<code>从(0,0)到(p,q)的恰好使用r个对角步的HVD格路径的数目</code></p>
<p>则，</p>
<h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><p>设p和q是正整数，且p \ge q，并设r是满足r \le q的非负整数。则有</p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p><code>从(0,0)到(p,q)的恰好使用r个对角步的下对角线HVD格路径</code>\gamma 可以在<code>去除了r个对角步</code>之后，转化为</p>
<p><code>从(0,0)到(p-r,q-r)的下对角线HVD格路径</code>\pi</p>
<p>同理，相反的。我们可以对<code>从(0,0)到（p-r,q-r)的下对角线HVD格路径</code>pi的基础上，通过在<code>p-r个水平步</code>，<code>q-r个垂直平</code>的<code>共(p-r)+(q-r)+1=p+q-2r+1个位置中的任意地方</code>插入<code>r个对角步</code>后得到<code>从(0,0)到(p,q)的恰好使用r个对角步的下对角线HVD格路径</code>\pi的数量</p>
<p>在\pi中插入<code>r个对角步的方案数</code> 等于 <code>下述方程的非负整数解的个数</code></p>
<p>而<code>解的个数</code>是</p>
<p>综上，我们得到</p>
<p>Q.E.D</p>
<h2 id="Schroder-Number"><a href="#Schroder-Number" class="headerlink" title="Schroder Number"></a>Schroder Number</h2><h3 id="Large-Schroder-Numebr"><a href="#Large-Schroder-Numebr" class="headerlink" title="Large Schroder Numebr"></a>Large Schroder Numebr</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p>假设p &#x3D; q &#x3D; n，则<code>从(0,0)到(n,n)的下对角线HVD格路径</code>即为<code>Schroder路径</code></p>
<p><code>大Schroder数</code>R_n表示<code>从(0,0)到(n,n)的Schroder路径的数目（即下对角线的HVD格路径的数目）</code></p>
<h3 id="Small-Schroder-Number"><a href="#Small-Schroder-Number" class="headerlink" title="Small Schroder Number"></a>Small Schroder Number</h3><h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h4><p>设n \ge 1 ，且a_1,a_2,\cdots\,a_n是<code>n个符号的序列</code>。<code>小Schroder数</code>s_n表示<code>对n个符号的序列加括号的方案数</code></p>
<blockquote>
<p>每个括号内的符号不一定只能是2个，可以任意多个。换句话说，不一定只是<code>二元加括号方式</code></p>
</blockquote>
<p>给序列a_1,a_2,\cdots,a_n加括号的递归定义为：</p>
<ol>
<li>对于每一个符号a_i，它本身就是一种加括号的方案。</li>
<li>任意<code>两个或多个加括号序列</code>被<code>一对括号</code>括起来，则也是一种加括号的方案。</li>
</ol>
<h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Theorem-1-1"><a href="#Theorem-1-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h5><h6 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h6><p><code>小Schroder数</code>的<code>生成函数</code>为</p>
<h6 id="Proof-5"><a href="#Proof-5" class="headerlink" title="Proof"></a>Proof</h6><p>设g(x) &#x3D; \sum_{n&#x3D;1}^{\infty}{s_nx^n}为<code>小Schroder数的生成函数</code>。</p>
<p>则根据<code>小Schroder数的递归定义</code>得</p>
<p>g(x) &#x3D; x + g(x)^2 + g(x)^3 + g(x)^4 + \cdots &#x3D; x + g(x)^2(1+ g(x) + g(x)^2 + \cdots)&#x3D; x + \frac{g(x)^2}{1-g(x)}</p>
<p>化简得</p>
<p>2g(x)^2-(1+x)g(x)+x &#x3D; 0</p>
<p>使用<code>y</code>代替<code>g(x)</code>得</p>
<p>2y^2 - (1+x)y + x &#x3D; 0</p>
<blockquote>
<p>此处x被当做常数处理</p>
</blockquote>
<p>解方程得出</p>
<p>代入<code>递推关系的初始条件</code>g(0)&#x3D;0进行<code>检验根</code>得知应舍去y_1(x)。故</p>
<p>Q.E.D</p>
<blockquote>
<p>根据<code>小Schroder数的递推关系的生成函数</code>，我们可以通过<code>求解微分方程</code>来得到<code>小Schroder数的递推关系</code>。</p>
<p><code>求解生成函数的过程</code>不在这里详细展开。</p>
</blockquote>
<h5 id="Theorem-2-1"><a href="#Theorem-2-1" class="headerlink" title="Theorem 2"></a>Theorem 2</h5><h6 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h6><p><code>大Schroder数的生成函数</code>为</p>
<h6 id="Proof-6"><a href="#Proof-6" class="headerlink" title="Proof"></a>Proof</h6><p><code>从(0,0)到(n,n)的下对角线的格路径</code>可以被分为3类：</p>
<ol>
<li>空路径（当n&#x3D;0时）</li>
<li>该路径从一个 对角步 D 开始</li>
<li>该路径从一个 水平步 H 开始</li>
</ol>
<blockquote>
<p><code>Sychroder路径</code>不会从一个<code>垂直步</code>开始，否则将会<code>立即越过对角线</code>，从而<code>违反定义</code></p>
</blockquote>
<ul>
<li>对于类型1：因为根本不存在方案，故不需要计数。（或者计数为<code>+0个方案</code>）</li>
<li>对于类型2：<code>原问题</code>相当于求<code>从(1,1)到(n,n)的下对角线的格路径</code>的数目</li>
</ul>
<p>即R_{n-1} （相当于把<code>原问题</code>的规模从<code>n</code>缩小到<code>n-1</code>）</p>
<ul>
<li>对于类型3：<code>原问题</code>相当于求<code>从（1,0)到(n,n)的下对角线的格路径</code> 数目。</li>
</ul>
<p>设\gamma表示该路径，且\gamma起始于(1,0)，终止于(n,n)。</p>
<p>设(k,k) \quad 1 \le k \le n 为路径\gamma<code>所接触的第一个对角线上的点</code></p>
<p>考察<code>路径</code>\gamma（<code>从(1,0)到(n,n)的路径</code>）到达所接触的第一个对角线上的点(k,k)的方式：</p>
<ol>
<li><p>如果\gamma通过<code>1个垂直步</code>从(k, k-1)步进到(k,k)：则分解\gamma&#x3D;\gamma_1 +\gamma_2，设\gamma_1是<code>从(1,0)到(k,k-1)的部分上是一条格路径</code>。\gamma_1不会<code>接触到对角线上的点</code>，所以\gamma_1存在R_{k-1}种选择。</p>
<blockquote>
<p>即基于<code>求从(1,0)到(k,k-1)的下对角线的格路径数目</code>中选取一个子问题规模：(k)-(1) &#x3D; (k-1) - (0) &#x3D; k - 1）。</p>
</blockquote>
<p>而\gamma_2是<code>从(k,k)到(n,n)的下对角线的格路径数目</code>，因而存在R_{n-k}个选择。</p>
</li>
<li><p>\gamma不可能通过<code>1个水平步</code>从(k -1, k)步进到(k,k)，否则这将意味着<code>这条路径早已越过了对角线</code></p>
</li>
</ol>
<hr>
<p>综上</p>
<p>或等价地</p>
<p>故</p>
<blockquote>
<p>整合上面两个式子</p>
</blockquote>
<p>代入R_0 &#x3D; 1得出</p>
<p>同理解<code>一元二次方程</code>得出</p>
<h5 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h5><h6 id="Content-7"><a href="#Content-7" class="headerlink" title="Content"></a>Content</h6><p><code>大Schroder数</code>和<code>小Schroder数</code>之间存在关系</p>
<h5 id="Theorem-3-1"><a href="#Theorem-3-1" class="headerlink" title="Theorem 3"></a>Theorem 3</h5><h6 id="Content-8"><a href="#Content-8" class="headerlink" title="Content"></a>Content</h6><p>设n为正整数，<code>有n+1条边的凸多边形区域</code>的<code>剖分数</code>（即\Pi_{n+1}）等于 <code>小Schroder数</code>s_n</p>
<blockquote>
<p>相类似的：对于<code>有n+1条边的凸多边形区域</code>的<code>三角剖分数</code> 等于<code>第n-1个Catalan数</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/27/combinatorics-partition-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/27/combinatorics-partition-number/" class="post-title-link" itemprop="url">Combinatorics - Partition Number</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-27 16:39:51" itemprop="dateCreated datePublished" datetime="2022-03-27T16:39:51+00:00">2022-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Counting-Partition-Number"><a href="#Counting-Partition-Number" class="headerlink" title="[Counting] Partition Number"></a>[Counting] Partition Number</h1><h2 id="Partition-Number"><a href="#Partition-Number" class="headerlink" title="Partition Number"></a>Partition Number</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><code>正整数n的一个分拆</code>是<code>把n表示成称为部分 (Part) 的一个或多个正整数的无序和</code>的一种表示。</p>
<p>例如，<code>5的分拆</code>可以有</p>
<h3 id="Partition-Diagram-Ferrers-Diagram"><a href="#Partition-Diagram-Ferrers-Diagram" class="headerlink" title="Partition Diagram (Ferrers Diagram)"></a>Partition Diagram (Ferrers Diagram)</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p>例如<code>数字10的一个分拆 10 = 4 + 2 + 2 + 1 +1 的Ferrers图</code></p>
<h3 id="Partition-Sequence"><a href="#Partition-Sequence" class="headerlink" title="Partition Sequence"></a>Partition Sequence</h3><h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h4><p>令p_n表示<code>正整数n的不同分拆的数目</code>，则<code>分拆序列 (Partition Sequence)</code>的为</p>
<p>其中，p_n的值&#x3D;<code>下列方程解的个数</code></p>
<h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h5><h6 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h6><p>设n和r是正整数且r\le n。设p_n(r)是<code>最大部分为r的n的分拆数量</code>，并设q_n(r)是<code>满足分拆各部分不大于r的n-r的分拆数量。则</code></p>
<h6 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h6><p>我们证明<code>该等式</code>的思路是，为<code>等式的两边</code>建立起<code>一一对应关系</code>。</p>
<p>也就是说，对于<code>每一个 最大部分为r的n的分拆</code>，我们要建立<code>与之唯一对应的</code> <code>各部分不大于r的n-r的分拆</code></p>
<p>我们可以从<code>Ferrers图</code>来理解，举例 <code>10的一个分拆 10 = 4 + 2 + 2 + 1 +</code>。</p>
<p>故每一个 <code>最大部分为4的10分拆</code>与每一个<code>各部分不大于4的6分拆</code>之间<code>一一对应</code></p>
<p>对此，我们可以简单地通过<code>删除掉Ferrers图中最大部分为4的那些行</code>来得到<code>删除后的Ferrers图</code>。</p>
<p>而<code>这个删除后的Ferrers图</code>就是与<code>原Ferrers图</code>相对应的<code>唯一的一个分拆</code></p>
<p>Q.E.D</p>
<h5 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem 2"></a>Theorem 2</h5><h6 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h6><p><code>数字n的共轭分拆 (Conjugate Partition)</code>为\lambda^*，它的<code>Ferrers图</code>是通过把\lambda的Ferrers图的行和列进行交换而得到。</p>
<blockquote>
<p>共轭分拆类似于矩阵转置</p>
</blockquote>
<h6 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h6><p>设n是正整数。设p_n^s等于<code>n的自共轭分拆数</code>，而p_n^t等于<code>n的分拆成互不相同的奇数个部分的分拆数</code>，则</p>
<h6 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h6><p>证明该<code>等式成立</code>的思路是，为<code>等式两边</code>建立起<code>一一对应关系</code></p>
<p>即考虑：如何为<code>每一个n的自共轭分拆</code>建立起<code>唯一对应的</code> <code>n的分拆成互不相同的奇数个部分的分拆数</code></p>
<p>考虑一个具体实例：</p>
<p>可以将<code>该Ferrers图的第一行和第一列弯曲起来</code>，形成<code>新Ferrers图的第一行</code>。</p>
<p>同理，将<code>该Ferrers图的第二行和第二列（在去除第一行和第一列的基础上）弯曲起来</code>，形成<code>新Ferrers图的第二行</code>。</p>
<p>即：</p>
<p>Q.E.D</p>
<h5 id="Theorem-3-Euler’s-Identity"><a href="#Theorem-3-Euler’s-Identity" class="headerlink" title="Theorem 3 (Euler’s Identity)"></a>Theorem 3 (Euler’s Identity)</h5><h6 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h6><p>设n是正整数。设p_n^{odd} 是<code>把n分成奇数个部分的分拆个数</code>，设p_n^{distinct} <code>把n分成不同部分的分拆个数</code>，则：</p>
<h6 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h6><p>我们的证明思路仍然是<code>建立等式两边的一一对应关系</code></p>
<p>考虑一个<code>数字10的一个分拆实例</code></p>
<p>请注意，如果<code>某个 把n分成奇数个部分的分拆</code>它<code>本身不存在相同部分</code>，那么<code>该分拆所对应的</code> <code>把n分成不同部分的分拆实例</code> 就是<code>它本身</code> （也就是<code>直接映射</code>）</p>
<p>所以，我们重点需要处理的是，<code>那些 把n分成奇数个部分，但存在相同部分的分拆</code>中的<code>那些相同部分</code></p>
<p>对此，由于<code>第1行表示的部分=4</code>与<code>第二行表示的部分=4</code>有重复，故<code>将这两部分进行合并</code>，得</p>
<p>若仍存在<code>重复部分</code>，则继续重复进行处理。最终得</p>
<blockquote>
<p>对于存在重复的两部分，为什么选择用合并两部分而不是分解其中一部分：如果选择分解其中一部分，则在某些重复比较严重的情况下，会出现不够继续分解的情况。（即存在多于1个<code>大小为1的部分</code>，这个部分无法再继续分解，因而无法避免重复）</p>
</blockquote>
<blockquote>
<p>为什么必须要求为<code>n的奇数个部分</code>：对于<code>n的偶数个部分的情况</code>，举一个实例。如4+4的情况，它最终合并后的结果为8.</p>
<p>但我们并不知道<code>最终得到的8</code>是<code>由4+4合并而得来的</code>还是<code>由本来的8直接映射得来的</code>。换句话说，如果<code>n的偶数个部分</code>，则我们无法保证<code>一一对应（双射）</code></p>
</blockquote>
<p>Q.E.D</p>
<h5 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="Theorem 4"></a>Theorem 4</h5><h6 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h6><p>证明<code>无限积形式的分拆序列</code>的<code>生成函数的表达式</code></p>
<h6 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h6><p>将<code>右边等式展开得到</code></p>
<p>上述式子的<code>x^n项的产生方式</code>：</p>
<ol>
<li>从<code>第一个因子</code>中选择x^{1a_1}项</li>
<li>从<code>第二个因子</code>中选择x^{2a_2}项</li>
<li>从<code>第三个因子</code>中选择x^{3a_3}项</li>
<li>…</li>
</ol>
<p>其中，1a_1 + 2a_2 + 3a_3 + \cdots &#x3D; n</p>
<blockquote>
<p>除了<code>有限数目的</code>a_i之外，其他的a_i&#x3D;0 （即我们对除了有限因子外的其他因子，选择<code>常数项1</code>）。</p>
<p>因此，<code>n的每一个分拆</code>使得x^n的系数+1，而x^n的系数p_n是<code>n的分拆个数p</code></p>
</blockquote>
<p>Q.E.D</p>
<h5 id="Theorem-5"><a href="#Theorem-5" class="headerlink" title="Theorem 5"></a>Theorem 5</h5><h6 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h6><p>设\mathcal{P}_n表示<code>正整数n的所有分拆的集合</code>。若有</p>
<p><code>分拆</code>\lambda:n &#x3D; n_1 + n_2 + \cdots + n_k \quad (n_1 \ge n_2 \ge \cdots \ge n_k \ge 0) 和</p>
<p><code>分拆</code>\mu: m &#x3D; m_1 + m_2 + \cdots + m_k \quad (m_1 \ge m_2 \ge \cdots \ge m_k \ge 0)</p>
<p>是<code>n的两个分拆</code>。</p>
<p>我们称\mu优越(majorize)\lambda即 \lambda \le \mu 当n_1 + n_2 + \cdots + n_i \le m_1 + m_2 + \cdots + m_i \quad (i &#x3D; 1,2,\cdots,k)</p>
<blockquote>
<p>因为优越关系是自反的，反对称的，传递的。故优越关系 是\mathcal{P}_n上的偏序关系</p>
</blockquote>
<h6 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h6><p><code>字典序</code>是<code>正整数n的分拆集</code>\mathcal{P}_n上<code>优越偏序的线性拓展</code></p>
<h6 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h6><p>令\lambda和\mu是<code>n的两个不同分拆</code>，且假设\mu \ge \lambda，则<code>选取</code> <code>第一个整数i</code>使得对于j \lt i, n_j &#x3D; m_j, n_i \ne m_i</p>
<p>即n_i \le m_i，因此，<code>在字典序之下</code>\lambda先于\mu</p>
<h5 id="Theorem-6-Euler’s-Pentagonal-Number-Theorem"><a href="#Theorem-6-Euler’s-Pentagonal-Number-Theorem" class="headerlink" title="Theorem 6 (Euler’s Pentagonal Number Theorem)"></a>Theorem 6 (Euler’s Pentagonal Number Theorem)</h5><h6 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h6><p>设n是正整数。设p_n^{\prime} 是<code>把n分成偶数个不同部分的分拆数量</code>，而p_n^{\prime\prime}是<code>把n分成奇数个不同部分的分拆数量</code>。则有</p>
<p>其中，e_n是<code>误差项</code>：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

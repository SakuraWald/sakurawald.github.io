<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sakurawald.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SakuraWald">
<meta property="og:url" content="https://sakurawald.github.io/page/6/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sakurawald.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>SakuraWald</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SakuraWald</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/08/07/electron-%E5%9F%BA%E4%BA%8Eelectron%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/07/electron-%E5%9F%BA%E4%BA%8Eelectron%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">Electron - 基于Electron开发桌面应用程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-07 21:04:00" itemprop="dateCreated datePublished" datetime="2021-08-07T21:04:00+00:00">2021-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Electron-简介"><a href="#Electron-简介" class="headerlink" title="Electron 简介"></a>Electron 简介</h1><p>Electron使用JavaScript, HTML和CSS来构建跨平台的桌面应用程序 (目前不支持移动端). 根据官网介绍，目前已经有不少著名的应用程序基于Electron开发. 如：Visual Studio Code, Atom, FaceBook Messageer, Twitch, Slack, Figma等   Electron基于B&#x2F;S架构，开发模式有些类似微信小程序. Electron &#x3D; Chromium + Node.js + Native API  </p>
<h1 id="创建-Electron项目"><a href="#创建-Electron项目" class="headerlink" title="创建 Electron项目"></a>创建 Electron项目</h1><h2 id="开发环境-Node-js"><a href="#开发环境-Node-js" class="headerlink" title="开发环境: Node.js"></a>开发环境: Node.js</h2><p>首先安装Electron的开发环境.</p>
<ol>
<li>Node.js (根据官网推荐，请使用LTS版本)</li>
<li>可用的文本编辑器或IDE</li>
</ol>
<p> </p>
<h2 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h2><ol>
<li>将Electron安装到Node.js项目的开发依赖中.</li>
</ol>
<p><code>npm install --save-dev electron</code>   注意: npm的服务器位于美国, 如果安装过程出现错误可以可以尝试科学上网.  </p>
<ol>
<li>在package.json中配置如下脚本, 用于Electron程序的启动.</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;electron .&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p> </p>
<ol>
<li>通过<code>npm start</code>来启动Electron程序</li>
</ol>
<p> </p>
<h1 id="使用Electron开发简单计算器"><a href="#使用Electron开发简单计算器" class="headerlink" title="使用Electron开发简单计算器"></a>使用Electron开发简单计算器</h1><ol>
<li>编写<code>index.html</code>作为程序界面</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input_expression&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;output_expression&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> </p>
<ol>
<li>编写<code>renderer.js</code>作为程序界面的渲染脚本</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bind Component Events. */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calcData</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> expression = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_expression&quot;</span>).<span class="property">value</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output_expression&quot;</span>).<span class="property">innerHTML</span> = <span class="built_in">eval</span>(expression)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output_expression&quot;</span>).<span class="property">innerHTML</span> = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_expression&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">calcData</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意: 如果你的Electron程序需要进行IPC通讯, 则可在Renderer使用 <code>const ipcRenderer = require(&#39;electron&#39;).ipcRenderer;</code> 注意: 对最新版本的Electron，需要额外配置<code>nodeIntegration</code>和<code>contextIsolation</code>才可以在Renderer中使用require()  </p>
<ol>
<li>编写<code>index.css</code>来作为程序界面的样式表</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#input_expression</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">1%</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#output_expression</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<ol>
<li>为<code>index.html</code>引入<code>renderer.js</code>来渲染界面</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// Include Renderer.js</span></span></span><br><span class="line"><span class="language-javascript"><span class="built_in">require</span>(<span class="string">&#x27;../js/renderer.js&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> </p>
<ol>
<li>为<code>index.html</code>引入<code>index.css</code>来美化界面</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/index.css&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p> </p>
<ol>
<li>编写<code>main.js</code>作为Electron程序的入口点</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span> () &#123;</span><br><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line"><span class="attr">height</span>: <span class="number">130</span>,</span><br><span class="line"><span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">webPreferences</span>: &#123;</span><br><span class="line"><span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">contextIsolation</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">win.<span class="title function_">loadFile</span>(<span class="string">&#x27;./pages/index.html&#x27;</span>)</span><br><span class="line">win.<span class="title function_">setMenu</span>(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">createWindow</span>()</span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">BrowserWindow</span>.<span class="title function_">getAllWindows</span>().<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="title function_">createWindow</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">platform</span> !== <span class="string">&#x27;darwin&#x27;</span>) &#123;</span><br><span class="line">app.<span class="title function_">quit</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>到此, 一个简单的计算器便完成了。 <img src="https://i.loli.net/2021/08/07/RJ6pS5q3mdQ1iwo.png" alt="image-20210807203718845">  </p>
<h1 id="打包Electron项目"><a href="#打包Electron项目" class="headerlink" title="打包Electron项目"></a>打包Electron项目</h1><p>Electron官网推荐使用的打包工具有3款</p>
<ol>
<li>Electron-Forge</li>
<li>Electron-Builder</li>
<li>Electron-React-Boilerplate</li>
</ol>
<p>  此处，选择使用Electron-Forge进行打包.  </p>
<ol>
<li>安装Electron-Forge模块</li>
</ol>
<p><code>npm install --save-dev @electron-forge/cli</code></p>
<ol>
<li>使用<code>import</code>命令设置Forge脚手架</li>
</ol>
<p><code>npx electron-forge import</code> 注意: 如果在运行该命令时提示<code>未找到Git错误</code>, 应在Electron项目文件夹中<code>Git Bash Here</code> 后输入该指令.</p>
<ol>
<li>运行Electron-Forge的<code>make</code>命令来编译Electron程序</li>
</ol>
<p><code>npm run make</code> <img src="https://i.loli.net/2021/08/07/6Uh3YCc8vjkSAPN.png" alt="image-20210807210128547"> 程序运行完成后，可以查看<code>out</code>目录下的文件。 <img src="https://i.loli.net/2021/08/07/wuMbdKHOX52qPhc.png" alt="image-20210807210248861"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/08/07/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/07/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CSharp - 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-07 05:56:19" itemprop="dateCreated datePublished" datetime="2021-08-07T05:56:19+00:00">2021-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Study-Note"><a href="#C-Study-Note" class="headerlink" title="C# Study Note"></a>C# Study Note</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在任何C#程序中的第一条语句都是这个</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C#的语法与Java高度相似, 同时引入C++的一些概念.</span></span><br><span class="line"><span class="comment">// 把C#当作Java来写似乎也没有问题.</span></span><br><span class="line"><span class="comment">// C#引入了C++中的名称空间namespace概念, 这和Java有点不同.</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpStudyDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C#的类模型与Java类似</span></span><br><span class="line">        <span class="comment">// C#也存在成员变量和成员函数的概念</span></span><br><span class="line">        <span class="comment">// C#的类中也存在访问修饰符的概念, 与Java类似</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> width;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C#的构造函数与Java类似</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">double</span> length, <span class="built_in">double</span> width</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">            <span class="keyword">this</span>.width = width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s start our C# Study.</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 数据类型 */</span></span><br><span class="line">            <span class="comment">// C#的数据类型分为: 值类型(ValueType), 引用类型(Reference Type) 和 指针类型(PointerType)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对象Object是C#的通用类型系统中所有数据类型的基类.</span></span><br><span class="line">            <span class="comment">// 对于某些值类型, C#和Java一样, 也支持 自动装箱(Auto-Boxing)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// C#额外支持 动态类型. 这些变量的类型检测在运行时发生</span></span><br><span class="line">            <span class="built_in">dynamic</span> dynamicVar = <span class="number">1</span>;</span><br><span class="line">            dynamicVar = <span class="string">&quot;hello dynamic&quot;</span>;</span><br><span class="line">            Console.WriteLine(dynamicVar);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// C#支持 原始字符串(Raw), 使用@符合来表示</span></span><br><span class="line">            <span class="built_in">string</span> rawStr = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br><span class="line">            Console.WriteLine(rawStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 与C++类似, C#保留了指针Pointer的概念, 并且支持使用 sizeof()来获取不同平台上的存储尺寸.</span></span><br><span class="line">            <span class="built_in">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span>* numPtr = &amp;num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// C#中要求对指针的操作必须在 不安全的代码块(Unsafe Block) 中执行.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 类型转换 */</span></span><br><span class="line">            <span class="comment">// 与Java类型, 同样分为隐式类型转换 和 显示类型转换</span></span><br><span class="line">            <span class="built_in">double</span> doubleNum = <span class="number">100.25</span>;</span><br><span class="line">            <span class="built_in">int</span> intNum = (<span class="built_in">int</span>)doubleNum;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 变量 */</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 常量 */</span></span><br><span class="line">            <span class="comment">// 与C++类似, C#支持const关键字</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 运算符 */</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line">            <span class="comment">// 但C#中额外支持 sizeof() 和 typeof()</span></span><br><span class="line">            <span class="comment">// 以及, C#中对于指针操作相关的: 取值运算符 *  和 取址运算符 &amp;</span></span><br><span class="line">            <span class="comment">// 此外, C#中使用is来判断对象类型(而不是instanceof), 使用as进行强制类型转换.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 条件控制 */</span></span><br><span class="line">            <span class="comment">// C#支持三目运算符. 支持if, switch等语句, 与Java类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 循环控制 */</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 面向对象 */</span></span><br><span class="line">            <span class="comment">// C#是面向对象的. </span></span><br><span class="line">            Rectangle rectangle = <span class="keyword">new</span> Rectangle(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">            <span class="comment">// C#同样存在 访问修饰符 的概念 (与Java类似)</span></span><br><span class="line">            <span class="comment">// 但C#存在2个独特的访问修饰符 internal(同一个程序集的对象可访问) 和 protected internal(访问限于当前程序集或派生自包含类的类型)</span></span><br><span class="line">            <span class="comment">// 访问修饰符的权限: public &gt; internal &gt; protected &gt; private</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 方法 */</span></span><br><span class="line">            <span class="comment">// 与Java类似</span></span><br><span class="line">            <span class="comment">// C#中函数的传参方式默认为 按值传递(与C语言类似)</span></span><br><span class="line">            <span class="comment">// C#同样支持 引用 概念(与C++类似), 可以使用 ref关键字 修饰来指明 按引用传递</span></span><br><span class="line">            <span class="comment">// C#独特地支持了 输出参数(使用out关键字修饰), 输出参数会将值赋值给自己, 原理类似引用参数.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 可空类型 */</span></span><br><span class="line">            <span class="comment">// C#中可以使用 单问号? 来修饰某些无法直接赋值为null的数据类型(如int,double,bool等)</span></span><br><span class="line">            <span class="built_in">int</span>? nullableInt = <span class="number">3</span>;</span><br><span class="line">            nullableInt = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 这将等价于</span></span><br><span class="line">            Nullable&lt;<span class="built_in">int</span>&gt; nullableInt2 = <span class="keyword">new</span> Nullable&lt;<span class="built_in">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 此外, 可以使用 双问号?? 在变量为null的时候返回默认值.</span></span><br><span class="line">            <span class="comment">// C#的 可空类型(Nullable) 对于处理 数据库操作时非常有用.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 数组 */</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line">            <span class="comment">// 此外, C#的 数组名 即为1个指向数组的指针 (与C类似, 但C#的数组是对象, 均继承自Array类)</span></span><br><span class="line">            <span class="built_in">double</span>[] balance = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">            Console.WriteLine(balance.Length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 字符串 */</span></span><br><span class="line">            <span class="comment">// 与Java类似, 同时支持使用&#123;0&#125;来格式化字符串</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 结构体 */</span></span><br><span class="line">            <span class="comment">// C#支持结构体struct (与C类似)</span></span><br><span class="line">            <span class="comment">// 但是, C#的结构体中可以定义方法.</span></span><br><span class="line">            <span class="comment">// 结构体h不支持构造函数(默认为结构体生成无参构造函数 且 无法被改变), 且不能定义 析构函数.</span></span><br><span class="line">            <span class="comment">// 结构体中的字段不允许赋予初值, 但类可以.</span></span><br><span class="line">            <span class="comment">// 结构体与类相比, 不支持 继承 和 多态, 但可以实现 接口.</span></span><br><span class="line">            <span class="comment">// 结构体的可以不使用new来创建, 转而使用一种C语言风格的创建方式.</span></span><br><span class="line">            <span class="comment">// 对于传参方式, 结构体是 值传递 (与C类似), 类 是 引用传递(与Java类似)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 枚举 */</span></span><br><span class="line">            <span class="comment">// 与 C++类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 类 */</span></span><br><span class="line">            <span class="comment">// 与Java类似. (但C#中支持 析构函数, 这与C++类似.)</span></span><br><span class="line">            <span class="comment">// C#支持密封类(Sealed Class), 与Kotlin类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 继承 */</span></span><br><span class="line">            <span class="comment">// 与Java类似 (不支持多重继承, 但接口支持多重实现.)</span></span><br><span class="line">            <span class="comment">// C#使用 冒号: 来代替 extends 和 implements</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 多态 */</span></span><br><span class="line">            <span class="comment">// C#支持静态多态 和 动态多态</span></span><br><span class="line">            <span class="comment">// 在C#中可以通过 函数重载 和 运算符重载 来实现 静态多态.</span></span><br><span class="line">            <span class="comment">// 通过 继承自抽象类(Abstract Class)来实现 动态多态.</span></span><br><span class="line">            <span class="comment">// C#中支持 抽象类 和 抽象方法 的概念, 同时提供override关键字来标识 重写方法.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此外, C#支持 虚方法</span></span><br><span class="line">            <span class="comment">// 虚方法(Virtual Method): 当有一个定义在类中的函数需要在 继承类 中实现时, 可使用虚方法.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 运算符重载 */</span></span><br><span class="line">            <span class="comment">// C#中支持 运算符重载(Operator Overroad), 与C++类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 接口 */</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 命令空间 */</span></span><br><span class="line">            <span class="comment">// 与C++类似.</span></span><br><span class="line">            <span class="comment">// 命名空间(Namespace): 命名空间的设计目的在于提供一种让 一组名称 与 其他名称 分隔开的方式.</span></span><br><span class="line">            <span class="comment">// C#支持 嵌套命名空间. 使用 点号运算符 访问嵌套的成员.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 预处理器指令 */</span></span><br><span class="line">            <span class="comment">// 与C++类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 正则表达式 */</span></span><br><span class="line">            <span class="comment">// 与Java类似</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 异常处理 */</span></span><br><span class="line">            <span class="comment">// 与Java类似</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 文件的输入与输出 */</span></span><br><span class="line">            <span class="comment">// 与Java类似</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 特性 */</span></span><br><span class="line">            <span class="comment">// C#的 特性(Attribute) 类似于Java中的 注解(Annotation)</span></span><br><span class="line">            <span class="comment">// 特性(Attribute): 用于在运行时传递 程序中的各种元素 的行为信息的 声明性标签.</span></span><br><span class="line">            <span class="comment">// 特性分为: 自定义特性  和 预定义特性</span></span><br><span class="line">            <span class="comment">// 预定义特性包含3种: AttributeUsage, Conditional, Obsolete</span></span><br><span class="line">            <span class="comment">// AttributeUsage特性: 描述如何使用一个自定义特性类. (规定了 特性 可应用到的项目的类型)</span></span><br><span class="line">            <span class="comment">// Conditional特性: 标记了一个条件方法, 其执行依赖于指定的预处理标识符.</span></span><br><span class="line">            <span class="comment">// Obsolete特性: 标记了不应被使用的程序实体.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 反射 */</span></span><br><span class="line">            <span class="comment">// 反射(Reflection): 指程序可以访问, 检测和修改它本身状态或行为的一种能力.</span></span><br><span class="line">            <span class="comment">// 与Java类似.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 属性 */</span></span><br><span class="line">            <span class="comment">// 属性(Property): 属性指类, 结构 和 接口的命名成员.</span></span><br><span class="line">            <span class="comment">// 类似Kotlin. 可以为1个属性(Property)定义 Get访问器 和 Set访问器. (C#中的幕后字段为value而不是field)</span></span><br><span class="line">            <span class="comment">// 此外, C#也支持 抽象属性(Abstract Property).</span></span><br><span class="line">            <span class="comment">// 抽象属性(Abstract Property): 这些属性在父类定义, 要求派生类实现. </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 索引器 */</span></span><br><span class="line">            <span class="comment">// 索引器(Indexer): 索引器允许一个对象可以像数组一样用下标的方式来访问.</span></span><br><span class="line">            <span class="comment">// C#中索引器的声明方式有点类似 属性(Property). </span></span><br><span class="line">            <span class="comment">// 实际上, 索引器 有些类似 C++的中括号运算符的重载.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 委托 */</span></span><br><span class="line">            <span class="comment">// 委托(Delegate): 类似C和C++中的函数指针. 委托是存有对某个方法的引用的一种引用类型变量.</span></span><br><span class="line">            <span class="comment">// 委托 可用于 实现事件 和 回调方法, 所有的委托继承自 System.Delegate</span></span><br><span class="line">            <span class="comment">// 声明 委托类型: delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span></span><br><span class="line">            <span class="comment">// 在声明完委托类型后, 可使用new关键字来创建 委托对象 (并将 委托函数 作为参数传入).</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 声明委托类型</span></span><br><span class="line"><span class="comment">            delegate int NumberChanger(int n);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 创建委托对象</span></span><br><span class="line"><span class="comment">            NumberChanger nc1 = new NumberChanger(AddNum);</span></span><br><span class="line"><span class="comment">            NumberChanger nc2 = new NumberChanger(MultNum);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 委托的多播(Multicasting of a Delegate): 相同类型的委托对象可以用 加号运算符 来合并. 一个合并委托会调用它所合并的2个委托.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 创建委托实例</span></span><br><span class="line"><span class="comment">            NumberChanger nc;</span></span><br><span class="line"><span class="comment">            NumberChanger nc1 = new NumberChanger(AddNum);</span></span><br><span class="line"><span class="comment">            NumberChanger nc2 = new NumberChanger(MultNum);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 创建多播</span></span><br><span class="line"><span class="comment">            nc = nc1;</span></span><br><span class="line"><span class="comment">            nc += nc2;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 事件 */</span></span><br><span class="line">            <span class="comment">// C#中使用 事件机制 来实现 线程间的通信</span></span><br><span class="line">            <span class="comment">// 类似观察者模式, 使用 发布-订阅模型(Publisher-Subscriber Model)</span></span><br><span class="line">            <span class="comment">// 发布器(Publisher): 一个包含 事件 和 委托类型 的对象</span></span><br><span class="line">            <span class="comment">// 订阅器(Subscriber): 一个 接受事件 并提供 事件处理程序 的对象</span></span><br><span class="line">            <span class="comment">// 发布器类中的 委托 调用订阅器类中的方法(即 事件处理程序)</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             // 定义 委托类型</span></span><br><span class="line"><span class="comment">             public delegate void NumberChangeHandler();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             // 基于 委托类型 定义 事件</span></span><br><span class="line"><span class="comment">             public event NumberChangeHandler NumberChangeEvent;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             // 注册 事件的监听器</span></span><br><span class="line"><span class="comment">             numberChangeEvent += new NumberChangeHandler(委托方法);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             // 触发 事件</span></span><br><span class="line"><span class="comment">             NumberChangeEvent();</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 集合 (Collection) */</span></span><br><span class="line">            <span class="comment">// 与Java类似</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 泛型  */</span></span><br><span class="line">            <span class="comment">// 泛型(Generic): 泛型允许 延迟编写类或方法中的编程元素的数据类型, 直到运行时. (泛化 数据类型)</span></span><br><span class="line">            <span class="comment">// 虽然C#的泛型格式与Java类似, 但C#的泛型属于真泛型, 不存在类似Java的泛型擦除现象.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 匿名方法 */</span></span><br><span class="line">            <span class="comment">// 匿名方法(Anonymous Method): 提供了一种传递 代码块 作为 委托参数 的技术.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 不安全代码 */</span></span><br><span class="line">            <span class="comment">// 处于安全考虑, C#中有关指针的操作必须在 不安全代码块(Unsafe Block) 中执行.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 多线程 */</span></span><br><span class="line">            <span class="comment">// 在C#中, 没有Runnable接口, 而是通过 ThreadStart代理来代替.</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/07/31/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-javafx%E5%92%8Ckotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/31/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-javafx%E5%92%8Ckotlin/" class="post-title-link" itemprop="url">JavaFX和Kotlin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-31 00:53:22" itemprop="dateCreated datePublished" datetime="2021-07-31T00:53:22+00:00">2021-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kotlin-amp-JavaFX"><a href="#Kotlin-amp-JavaFX" class="headerlink" title="Kotlin &amp; JavaFX"></a>Kotlin &amp; JavaFX</h1><p>Java项目转化成Kotlin项目后，和JavaFX之间兼容遇到了一些问题。</p>
<h2 id="JavaFX支持库无法被导入"><a href="#JavaFX支持库无法被导入" class="headerlink" title="JavaFX支持库无法被导入"></a>JavaFX支持库无法被导入</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>之前Java项目使用的是OpenJDK-16，在高版本的JDK中，JavaFX被当成外置模块而独立出了JDK。 因此，在之前Java项目中是通过导入Jar包的方式来使用JavaFX。 但是在Kotlin项目中，JavaFX的jar包无法被导入。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用较低版本的JDK，如JDK-8。</p>
<h2 id="JavaFX无法注入Kotlin中被val修饰的变量"><a href="#JavaFX无法注入Kotlin中被val修饰的变量" class="headerlink" title="JavaFX无法注入Kotlin中被val修饰的变量"></a>JavaFX无法注入Kotlin中被val修饰的变量</h2><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>在Kotlin中，由于IDEA的代码分析存在一些问题，原本Java项目中某些字段会被解析为val变量。 而在Kotlin中，被val修饰的变量无法被后续修改，这将导致了JavaFX无法成功注入这些字段。 但更严重的是，当出现这个问题时，程序直到运行时都不会有任何报错。 错误表现为这些字段的值为null</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用var修饰需要被JavaFX注入的变量。</p>
<h2 id="某些FXML文件在load时出现报错"><a href="#某些FXML文件在load时出现报错" class="headerlink" title="某些FXML文件在load时出现报错"></a>某些FXML文件在load时出现报错</h2><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>当FXMLLoader在load()某些*.FXML文件时，会出现报错。 这是因为IDEA在代码转化的时候，根据Kotlin的get&#x2F;set规则修改了部分字段的名称，导致代码文件与FXML文件无法匹配。</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>将这些无法匹配的字段修改为与FXML文件一致</p>
<h2 id="Kotlin文件的Controller与FXML文件绑定"><a href="#Kotlin文件的Controller与FXML文件绑定" class="headerlink" title="Kotlin文件的Controller与FXML文件绑定"></a>Kotlin文件的Controller与FXML文件绑定</h2><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>原先在FXML文件中指定Controller的方式为 Controller的全类名。 这是对于Java项目的。但对于Kotlin项目，在绑定Controller这一步也一样。（FXML文件指定Controller时并没有要求写后缀名，并且经过实际测试，在不改动FXML文件的情况下即可正确绑定Controller）</p>
<h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p>与Java写法一样即可。</p>
<h2 id="部分FXML文件报出控件解析错误"><a href="#部分FXML文件报出控件解析错误" class="headerlink" title="部分FXML文件报出控件解析错误"></a>部分FXML文件报出控件解析错误</h2><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>原先FXML文件出现控件无法解析。</p>
<h4 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h4><p>根据IDEA的提示，使用Alt + Enter来导入这些控件即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/07/27/kotlin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/kotlin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Kotlin - 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-27 22:57:28" itemprop="dateCreated datePublished" datetime="2021-07-27T22:57:28+00:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kotlin-Study-Note"><a href="#Kotlin-Study-Note" class="headerlink" title="Kotlin Study Note"></a>Kotlin Study Note</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin源文件 不需要放在 相匹配的目录或包下, 源文件可以放在任何文件目录</span></span><br><span class="line"><span class="keyword">package</span> basics</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseAdapter</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent</span><br><span class="line"><span class="keyword">import</span> javax.swing.JComponent</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">object</span> AnObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin的main函数的参数列表可空, 也可写入参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 函数 **/</span></span><br><span class="line">    <span class="comment">// Kotlin的函数定义风格类似Rust, 但使用:符号来引出返回类型</span></span><br><span class="line">    <span class="comment">// 在Kotlin中, 函数属于 第一等公民(First Class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin支持对函数的返回类型 进行 自动类型推断</span></span><br><span class="line">    <span class="comment">// 例外: public方法要求必须手动指明返回值类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sum2</span><span class="params">(a:<span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中的Unit类型代表 无返回值, 相当于Java中的void</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin支持 可变长参数, 使用 vararg关键字进行标识.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (value <span class="keyword">in</span> values) &#123;</span><br><span class="line">            print(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin支持lambda表达式</span></span><br><span class="line">    <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x + y&#125;</span><br><span class="line">    println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中的变量和常量的定义</span></span><br><span class="line">    <span class="comment">// var: 可变变量</span></span><br><span class="line">    <span class="comment">// val: 不可变变量</span></span><br><span class="line">    <span class="comment">// 可以在定义变量或常量时指定类型, 也可以利用 自动类型推断 来省略类型书写</span></span><br><span class="line">    <span class="keyword">var</span> aVar: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> aVal: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 行注释 和 块注释 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin的块注释支持嵌套</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="comment">    It&#x27;s ok.</span></span></span><br><span class="line"><span class="comment"><span class="comment">     */</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字符串模板 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin支持字符串模板</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    println(<span class="string">&quot;a is <span class="variable">$a</span>&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;1 + 2 = <span class="subst">$&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 空安全 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin采用 空安全设计</span></span><br><span class="line">    <span class="comment">// 空安全设计: 对于可能为空的参数, 在使用前要进行判空.</span></span><br><span class="line">    <span class="comment">// Kotlin提供2种处理方式:</span></span><br><span class="line">    <span class="comment">// 方式1: 字段后天就 !!, 则行为与Java相同, 抛出空异常</span></span><br><span class="line">    <span class="comment">// 方式2: 字段后加 ?, 可不做处理返回值为 null 或 配合?: 做空判断处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段类型后加?表示可空</span></span><br><span class="line">    <span class="keyword">var</span> field1: String? = <span class="string">&quot;23&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加!!表示行为与Java一样, 抛出NPE</span></span><br><span class="line">    <span class="keyword">var</span> field2 = field1!!.toInt()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加 ? 表示不作处理, 直接返回null</span></span><br><span class="line">    <span class="keyword">var</span> field3 = field1?.toInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此外, 可以采用 ?: 来为 空值 提供默认值</span></span><br><span class="line">    <span class="comment">// 下面语句在 field1 为空时, 返回-1</span></span><br><span class="line">    <span class="keyword">var</span> field4 = field1?.toInt() ?: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个引用可能为空时, 对应的类型声明必须使用 ? 进行标记</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span> :<span class="built_in">Int</span>? &#123;</span><br><span class="line">        <span class="comment">// do something.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类型检测 和 自动类型转换 */</span></span><br><span class="line">    <span class="comment">// Kotlin提供 is运算符 来判断 表达式是否属于某个类型的实例, 这类似于Jva中的instanceof</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">            <span class="comment">// 在配合if使用过is运算符后, Kotlin会自动对obj进行类型转换</span></span><br><span class="line">            <span class="keyword">return</span> obj.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里的obj仍然属于 Any类型的引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理, if和!is搭配使用 也会让Kotlin自动对obj进行类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 区间 **/</span></span><br><span class="line">    <span class="comment">// 输出1234 (注意: 在Kotlin中, 区间是闭区间, 而不是左闭右开区间)</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间可以配合 step 来指定步长</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">2</span>) print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然, 如果需要使用更为常见的区间形式: 左闭右开区间, 则可以使用until</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">4</span>) print(i) <span class="comment">// 输出123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 基本数据类型 **/</span></span><br><span class="line">    <span class="comment">// 与Java不同, 在Kotlin中, 字符不属于数值类型.</span></span><br><span class="line">    <span class="comment">// 在Kotlin中, 不存在 基础数据类型, 只有 封装的数字类型.</span></span><br><span class="line">    <span class="comment">// 你每定义的一个变量, Kotlin都会帮你封装一个对象. (这样可以保证不会出现空指针)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于数字类型的对象, 在比较时要注意区分: 比较数字大小 和 比较对象相等</span></span><br><span class="line">    <span class="comment">// 在Kotlin中, === 代表比较对象的地址, == 代表比较对象的数值的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用已有的数字对象来赋值时, Kotlin会进行 自动装箱, 将 数字的值拷贝过去, 封装为新对象.</span></span><br><span class="line">    println()</span><br><span class="line">    <span class="keyword">var</span> existNum: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> anotherNum: <span class="built_in">Int</span> = existNum <span class="comment">// 此处发生了 自动装箱, 并不是传递对象引用.</span></span><br><span class="line">    println(<span class="string">&quot;existNum == anotherNum: <span class="subst">$&#123;existNum == anotherNum&#125;</span>&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在高版本的Kotlin中, 对于Int的===比较将被废除. (此处表现的行为和 == 相同)</span></span><br><span class="line">    <span class="comment">// 虽然此处 === 结果为true, 但实际上, existNum 和 anotherNum 的地址是不同的</span></span><br><span class="line">    println(<span class="string">&quot;existNum === anotherNum: <span class="subst">$&#123;existNum === anotherNum&#125;</span>&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下面的例子可以看出, 通过修改existNum, 并不会影响到 anotherNum</span></span><br><span class="line">    <span class="comment">// 由此也可证明, 数字类型对象 在赋值时会经过 自动装箱, 构造新的数字对象, 而不是直接传递原有的引用.</span></span><br><span class="line">    existNum = <span class="number">200</span></span><br><span class="line">    println(<span class="string">&quot;after modify existNum, existNum = <span class="variable">$existNum</span>&quot;</span>) <span class="comment">// 200</span></span><br><span class="line">    println(<span class="string">&quot;after modify existNum, anotherNum = <span class="variable">$anotherNum</span>&quot;</span>) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Kotlin中, 较小的类型 并不是 较大的类型 的子类</span></span><br><span class="line">    <span class="comment">// 也就是说, 类似的 Byte 不能被隐式转换为 Int</span></span><br><span class="line">    <span class="keyword">var</span> byteVar: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//    var intVar: Int = byteVar 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是, 在参与 运算表达式 的时候, Kotlin会自动进行 类型的转化.</span></span><br><span class="line">    <span class="keyword">var</span> longResult = <span class="number">1L</span> + <span class="number">3</span> <span class="comment">// Long + Int = Long</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin和Java一样, 也支持 位操作符</span></span><br><span class="line">    <span class="comment">//    shl(bits) – 左移位 (Java’s &lt;&lt;)</span></span><br><span class="line">    <span class="comment">//    shr(bits) – 右移位 (Java’s &gt;&gt;)</span></span><br><span class="line">    <span class="comment">//    ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span></span><br><span class="line">    <span class="comment">//    and(bits) – 与</span></span><br><span class="line">    <span class="comment">//    or(bits) – 或</span></span><br><span class="line">    <span class="comment">//    xor(bits) – 异或</span></span><br><span class="line">    <span class="comment">//    inv() – 反向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中的 字符Char 不能直接与 数字进行操作, 需要进行转化.</span></span><br><span class="line">    <span class="keyword">var</span> numChar: <span class="built_in">Char</span> = <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> numIntFromChar: <span class="built_in">Int</span> = numChar.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin的数组采用 Array类 来实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建方法1: arrayOf()函数</span></span><br><span class="line">    <span class="keyword">var</span> arr1 = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建方法2: 工厂函数</span></span><br><span class="line">    <span class="keyword">var</span> arr2 = Array(<span class="number">3</span>) &#123; i -&gt; (i * <span class="number">2</span>) &#125; <span class="comment">// [0, 2, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意: 与Java不同的是, Kotlin中的数组是 不可协变的 (Invariant)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 字符串 方面, Kotlin提供了 String类</span></span><br><span class="line">    <span class="comment">// 此外, Kotlin提供 多行字符串 支持, 使用3个引号 括起来的字符串 即为多行字符串</span></span><br><span class="line">    <span class="keyword">var</span> multiLineText = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 条件控制 **/</span></span><br><span class="line">    <span class="comment">// Kotlin的If语句和Java相同</span></span><br><span class="line">    <span class="comment">// Kotlin本身不支持 三目运算符, 但我们可以模拟实现一个:</span></span><br><span class="line">    <span class="comment">// var c = if (condition) a else b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 if in语句来判断 某个值 是否属于 某个区间</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.24</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;x 属于区间&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中的 When表达式 类似于Java中的 Switch语句</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; println(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">        <span class="number">2</span> -&gt; println(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;x belongs to other num&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 多个分支 的处理方式相同, 则可用 逗号 来分隔这些分支.</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span> -&gt; println(<span class="string">&quot;x is 1 or 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此外, Kotlin的 when语句 可以配合 区间in 和 !in 使用</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; println(<span class="string">&quot;x is in the range&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 循环控制 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Kotlin中支持Foreach语句, 使用 for in 即可</span></span><br><span class="line">    <span class="comment">// Kotlin支持 while 和 do while</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中支持 Break标签 和 Continue标签</span></span><br><span class="line">    <span class="comment">// break标签: 跳转到 该标签指定的循环的后面的执行点</span></span><br><span class="line">    <span class="comment">// continue标签: 继续 该标签指定的循环的下一次迭代</span></span><br><span class="line">    <span class="comment">// 实际上, Kotlin中的任何表达 都可以使用 标签 (@符号) 来标记</span></span><br><span class="line">    <span class="symbol">sayHello@</span> println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中存在 函数字面量, 局部函数 和 对象表达式, 因此, Kotlin的函数是可以被嵌套的 (函数是第一等公民)</span></span><br><span class="line">    <span class="comment">// 通过使用 标签限制的return, 我们可以直接从 外层函数返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    fun foo() &#123;</span></span><br><span class="line"><span class="comment">        ints.forEach &#123;</span></span><br><span class="line"><span class="comment">            // 通过 抱歉限制的return, 使得 该lambda表达式中的return从lambda表达式中返回</span></span><br><span class="line"><span class="comment">            if (it == 0) return@forEach</span></span><br><span class="line"><span class="comment">            print(it)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此外, 也可以使用1个匿名函数 来代替 lambda表达式. (匿名函数内部的return语句 将从 该匿名函数自身 返回)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    fun foo() &#123;</span></span><br><span class="line"><span class="comment">    ints.forEach(fun(value: Int) &#123;</span></span><br><span class="line"><span class="comment">        // 使用匿名函数</span></span><br><span class="line"><span class="comment">        if (value == 0) return</span></span><br><span class="line"><span class="comment">        print(value)</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 类和对象 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中提供对 类Class 的比较完善的支持</span></span><br><span class="line">    <span class="comment">// Kotlin的类Class声明方式与Java相同</span></span><br><span class="line">    <span class="comment">// 但请注意, Kotlin中没有 new关键字, 在创建类实例对象时, 与C++更类似</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> name: String = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj1 = AClass()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中的类可以拥有 1个主构造器(写在类的头部) 和 多个次构造器</span></span><br><span class="line">    <span class="comment">// 注意: 当主构造器 没有 任何注解 或 可见修饰符 时, 可省略constructor关键字</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BClass</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj2 = BClass(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中支持为 类属性 绑定getter和setter (类似于 操作符重载)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CClass</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> name: String = <span class="string">&quot;default&quot;</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> field <span class="comment">// 后端字段(Backing Field)机制</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>(value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                println(<span class="string">&quot;I know you set the field to: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj3 = CClass()</span><br><span class="line">    obj3.name = <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Kotlin的类中, 非空属性 必须在定义的时候进行初始化. (但是可以通过 lateinit关键字 来延迟初始化)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DClass</span> &#123;</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin提供 初始化代码块支持, 使用init关键字作为前缀. (这类似于Java中的构造代码块)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EClass</span>&#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Hi, init()&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj4 = EClass()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin的类中允许多个 次构造器, 使用 constructor关键字</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FClass</span> &#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            println(<span class="string">&quot;Hi, constructor()&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj5 = FClass()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器之间的方法与Java一样, 使用this关键字</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 在JVM虚拟机中, 如果 主构造函数的所有参数都有默认值, 则编译器会生成一个 附加的无惨构造函数, 该构造函数会直接使用默认值</span></span><br><span class="line"><span class="comment">// 上述特性使得Kotlin更容易通过 无惨构造函数 来创建类的实例</span></span><br><span class="line"><span class="comment">// Kotlin中同样也支持抽象类, 在class前加入abstract关键字即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中也支持 嵌套类, 用法和Java一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中也支持 内部类, 用法和Java一样</span></span><br><span class="line"><span class="comment">// 1. 内部类会带有1个对外部类的对象的引用</span></span><br><span class="line"><span class="comment">// 2. 所有的内部类 都可以访问 外部类的成员属性和成员函数</span></span><br><span class="line"><span class="comment">// 在 内部类 可以通过 this@Outer 来获取 该内部类的外部类的对象实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中, 可以使用 对象表达式 来创建 匿名内部类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Kotlin的 类属性修饰符</span></span><br><span class="line"><span class="comment">    abstract    // 抽象类</span></span><br><span class="line"><span class="comment">    final       // 类不可继承 (类的默认属性)</span></span><br><span class="line"><span class="comment">    enum        // 枚举类</span></span><br><span class="line"><span class="comment">    open        // 类可继承</span></span><br><span class="line"><span class="comment">    annotation  // 注解类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Kotlin的访问权限修饰符 (与Java类似)</span></span><br><span class="line"><span class="comment">    private    // 仅同文件可见</span></span><br><span class="line"><span class="comment">    protected  // 同文件 或 子类 可见</span></span><br><span class="line"><span class="comment">    public     // 所有调用的地方可见</span></span><br><span class="line"><span class="comment">    internal   // 同模块可见</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 继承 **/</span></span><br><span class="line"><span class="comment">// Kotlin中所有类都继承自Any类 (类似Java的Object类)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果子类没有构造函数, 则必须在 次构造函数 中通过 super来初始化基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中的重写(Override)要求:</span></span><br><span class="line"><span class="comment">// 1. 基类被open修饰</span></span><br><span class="line"><span class="comment">// 2. 子类的重写方法被override修饰</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中是支持 多继承 的, 如果通过多继承, 子类得到多个相同的方法, 则子类必须要对这些方法进行重写.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin支持 属性重写, 但属性必须具有兼容类型.</span></span><br><span class="line"><span class="comment">// 父类中每个声明的属性 都可以通过 初始化程序 或 getter方法 进行重写.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 接口 **/</span></span><br><span class="line"><span class="comment">// Kotlin的接口与Java类似, 使用interface关键字定义, 允许接口的方法有默认实现</span></span><br><span class="line"><span class="comment">// 注意: 接口中的属性只能是抽象的, 不允许 初始化值. (接口不会保存属性值, 实现接口时必须 重写属性)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 拓展 **/</span></span><br><span class="line"><span class="comment">// Kotlin支持为 类的属性和方法 进行静态拓展 (不需要使用 装饰着模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对类进行 拓展函数 可以在 已有类中添加新的方法, 但不会对 原类 做出修改. (类似 Go语言的接收者对象Receiver Object)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book = Book()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对类进行拓展之后</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Book.<span class="title">getCost</span><span class="params">()</span></span> : <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">80.0</span></span><br><span class="line">&#125;</span><br><span class="line">book.getCost();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中的拓展是静态拓展, 在调用拓展函数时, 具体被调用的函数 取决于 调用函数的对象表达式 (而不是动态类型)</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">SuperClass</span>()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> SuperClass.<span class="title">say</span><span class="params">()</span></span> = <span class="string">&quot;I&#x27;m super class.&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> SubClass.<span class="title">say</span><span class="params">()</span></span> = <span class="string">&quot;I&#x27;m sub class.&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">(superClass: <span class="type">SuperClass</span>)</span></span> &#123;</span><br><span class="line">    println(superClass.say()) <span class="comment">// 在继承情况下, 调用拓展函数时, 具体被调用的函数 取决于 调用函数的对象表达式</span></span><br><span class="line">&#125;</span><br><span class="line">saySomething(SubClass()) <span class="comment">// I&#x27;m super class.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 一个类的拓展含 和 类的成员函数 相同时, Kotlin会优先使用 成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 拓展函数 中, 可以通过 this 来判断 接收者对象 是否为null</span></span><br><span class="line"><span class="comment">// 即使 接收者 为null, 也可以调用 拓展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">doSomeStuff</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;do some stuff.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">null</span>.doSomeStuff() <span class="comment">// It&#x27;s OK.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了 拓展函数, Kotlin也支持 拓展属性</span></span><br><span class="line"><span class="comment">// 拓展属性 必须定义在 类 或 Kotlin文件 中, 不允许定义在函数内.</span></span><br><span class="line"><span class="comment">// 拓展属性 不允许带有 初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理, 如果 某个类拥有伴生对象, 则你也可以通过 类名.Companion 的方式来为 伴生对象 进行拓展.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展的作用域: 通常来说, 拓展 会定义在 顶级包 中. 可以通过import导入包的方式来使用拓展.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin支持在 一个类 中为 另一个类 进行拓展.</span></span><br><span class="line"><span class="comment">// 在这样的拓展中, 如果存在 多个隐含的接收者: 则 拓展方法定义所在的类的实例 为 分发接收者, 拓展方法的目标类型的实例 为 拓展接收者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin规定: 在调用某个函数时, 如果该函数在 分发接收者 和 拓展接收者 中均存在, 则优先使用 拓展接收者. (如果要使用 分发接收者 可以通过 this语法)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpandA</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;println(<span class="string">&quot;ExpandA bar&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpandB</span> &#123;</span><br><span class="line">    <span class="comment">// 分发接收者 ExpandB 中 存在 与 拓展接收者 ExpandA 相同的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;println(<span class="string">&quot;ExpandB bar&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> ExpandA.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar() <span class="comment">// 优先调用 拓展接收者ExpandA 中的函数</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@ExpandB</span>.bar() <span class="comment">// 通过 this语句 来调用 分发接收者ExpandB 中的函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(expandA: <span class="type">ExpandA</span>)</span></span> &#123;</span><br><span class="line">        expandA.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expandA = ExpandA()</span><br><span class="line"><span class="keyword">var</span> expandB = ExpandB()</span><br><span class="line">expandB.caller(expandA) <span class="comment">// Output: ExpandA bar \n ExpandB bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中, 以成员形式定义的拓展函数 可以声明为open, 且在子类中可以被覆盖.</span></span><br><span class="line"><span class="comment">// 也就是说, 这类拓展函数的派发过程中: 对于 分发接收者 是虚拟解析, 对于 拓展接收者 是静态解析.</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SubOfD</span> : <span class="type">D</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">        <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;D.foo in C&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> SubOfD.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;SubOfD.foo in C&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">            d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SubOfC</span> : <span class="type">C</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;D.foo in SubOfC&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> SubOfD.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;SubOfD.foo in SubOfC&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">C().caller(D())   <span class="comment">// 输出 &quot;D.foo in C&quot;</span></span><br><span class="line">SubOfC().caller(D())  <span class="comment">// 输出 &quot;D.foo in SubOfC&quot; —— 分发接收者虚拟解析</span></span><br><span class="line">C().caller(SubOfD())  <span class="comment">// 输出 &quot;D.foo in C&quot; —— 扩展接收者静态解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 数据类与密封类 **/</span></span><br><span class="line"><span class="comment">// Kotlin中支持快速创建数据类型, 只需要使用 data class 关键字即可</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">var</span> user = User(<span class="string">&quot;Alive&quot;</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会自动机构根据 Data类 中的 主构造函数 声明的属性. 自动生成(若未定义): equals(), toString(), componentN(), copy()</span></span><br><span class="line"><span class="comment">// 数据类 不可以声明为 abstract, open, sealed 或 inner</span></span><br><span class="line"><span class="comment">// 数据类 也不能 继承其他类, 但可以实现接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密封类: 用于表示 受限的类继承结构, 当一个值为 有限几种类型, 且不能有其他类型时.</span></span><br><span class="line"><span class="comment">// 密封类有点类似于枚举类, 但是米鞥类的子类可以有 多个可包含状态的实例.</span></span><br><span class="line"><span class="comment">// 使用 sealed class 即可声明 密封类</span></span><br><span class="line"><span class="comment">// 密封类可以有子类, 但所有的子类 必须要内嵌在密封类中</span></span><br><span class="line"><span class="comment">// 与枚举类类似, 密封类可以与 when表达式 搭配进行使用.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 泛型 **/</span></span><br><span class="line"><span class="comment">// 与Java一样, Kotlin也支持泛型.</span></span><br><span class="line"><span class="comment">// 泛型: 即 参数化类型, 泛型可以用在 类, 接口 和 方法上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与Java一样, Kotlin也支持 泛型约束 (Kotlin使用 上界约束条件)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认情况下, Kotlin的 泛型约束 为 Any?</span></span><br><span class="line"><span class="comment">// 对于多个 上界约束条件, 可以使用 where子句</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">        <span class="keyword">where</span> T : CharSequence,</span><br><span class="line">              T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin中没有 通配符类型, 但是有类似想2个东西: 声明处型变 和 类型投影</span></span><br><span class="line"><span class="comment">// 1. 声明处型变 (Declaration-Site Variance): 声明处的类型变异使用 协变注解修饰符 (消费者 in, 生产者 out)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 out 使得 一个类型参数协变, 协变类型参数 只能用于输出. (可以用于 返回值类型, 但无法作为 入参的类型)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QClass</span>&lt;<span class="type">out A</span>&gt;(<span class="keyword">val</span> q: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: A &#123;</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 in 使得 一个类型参数逆变, 逆变类型参数 只能用于输入. (可以作为 入参的类型, 但无法作为返回值的类型)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WClass</span>&lt;<span class="type">in A</span>&gt;(w: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(w: <span class="type">A</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 类型投影 (Type Projections):</span></span><br><span class="line"><span class="comment">// Kotlin的类型投影提供星号影射 (*代表所有类型, 相当于 Any?), 这与Java的 原生类型 (Raw Type)非常类似.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 枚举类 **/</span></span><br><span class="line"><span class="comment">// Kotlin支持枚举类, 用法和Java一样.</span></span><br><span class="line"><span class="comment">// 但Kotlin中的枚举类支持声明自己的匿名类, 方法 以及覆盖基类的方法.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enum class ProtocolState &#123;</span></span><br><span class="line"><span class="comment">    WAITING &#123;</span></span><br><span class="line"><span class="comment">        override fun signal() = TALKING</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    TALKING &#123;</span></span><br><span class="line"><span class="comment">        override fun signal() = WAITING</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    abstract fun signal(): ProtocolState</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对象表达式 和 对象声明 **/</span></span><br><span class="line"><span class="comment">// Kotlin中使用对象表达式 和 对象声明 来创建一个对某个类做了轻微改动的类的对象, 且不需要声明新的子类.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 object关键字 来完成 对象声明</span></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中, 我们可以通过使用 object关键字 来声明一个对象, 并获得1个单例</span></span><br><span class="line"><span class="keyword">var</span> anObject1 = AnObject</span><br><span class="line"><span class="keyword">var</span> anObject2 = AnObject</span><br><span class="line">println(<span class="string">&quot;anObject1 === anObject2: <span class="subst">$&#123;anObject1 === anObject2&#125;</span>&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 与 对象表达式 不同, 当对象声明在另一个类的内部时, 该对象不能通过 外部类的实例 访问到 该对象.</span></span><br><span class="line"><span class="comment">// 而只能通过该类名来访问. 同样地, 该对象也不能直接访问到 外部类的方法和变量.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伴生对象: 类内部的对象声明 可以使用 companion关键字 进行标记, 这样它就可以与 外部类 关联在一起. (我们就可以直接通过外部类来访问 对象的内部元素)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class MyClass &#123;</span></span><br><span class="line"><span class="comment">    companion object Factory &#123;</span></span><br><span class="line"><span class="comment">        fun create(): MyClass = MyClass()</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">val instance = MyClass.create()   // 访问到对象的内部元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 一个类里面只能声明1个 内部关联对象.</span></span><br><span class="line"><span class="comment">// 注意: 伴生对象的成员看起来有点像其他语言的静态成员, 但在运行时, 他们仍然是真实对象的实例成员.</span></span><br><span class="line"><span class="comment">// 注意: 伴生对象的初始化是 在相应的类被加载(解析)时进行, 与 Java 静态初始化器的语义相匹配.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 委托 **/</span></span><br><span class="line"><span class="comment">// 委托模式: 当有2个对象参与处理同一个请求时, 接受请求的对象 将请求 委托给 另一个对象来处理. (即: 1个类中定义的方法实际上是调用另一个类的对象的方法来实现的)</span></span><br><span class="line"><span class="comment">// Kotlin直接支持委托模式, 通过关键字by来实现委托</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="comment">interface Base &#123;</span></span><br><span class="line"><span class="comment">    fun print()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 实现此接口的 被委托的类</span></span><br><span class="line"><span class="comment">class BaseImpl(val x: Int) : Base &#123;</span></span><br><span class="line"><span class="comment">    override fun print() &#123; print(x) &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 通过关键字 by 建立委托类: 编译器会将b保存在Derived的对象实例内部, 且自动生成继承自Base接口的所有方法, 并转发给b.</span></span><br><span class="line"><span class="comment">class Derived(b: Base) : Base by b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fun main(args: Array&lt;String&gt;) &#123;</span></span><br><span class="line"><span class="comment">    val b = BaseImpl(10)</span></span><br><span class="line"><span class="comment">    Derived(b).print() // 输出 10</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin也支持 属性委托.</span></span><br><span class="line"><span class="comment">// 属性委托: 1个类的某个属性值 不是在类中直接进行定义, 而是将其 委托 给1个代理类, 从而实现对该类的属性的统一管理.</span></span><br><span class="line"><span class="comment">// 属性委托语法格式: var/val &lt;属性名&gt;: &lt;类型&gt; by &lt;委托代理类&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">import kotlin.reflect.KProperty</span></span><br><span class="line"><span class="comment">// 定义包含属性委托的类</span></span><br><span class="line"><span class="comment">class Example &#123;</span></span><br><span class="line"><span class="comment">    var p: String by Delegate()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 委托的类</span></span><br><span class="line"><span class="comment">class Delegate &#123;</span></span><br><span class="line"><span class="comment">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</span></span><br><span class="line"><span class="comment">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fun main(args: Array&lt;String&gt;) &#123;</span></span><br><span class="line"><span class="comment">    val e = Example()</span></span><br><span class="line"><span class="comment">    println(e.p)     // 访问该属性，调用 getValue() 函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    e.p = &quot;Hello&quot;   // 调用 setValue() 函数</span></span><br><span class="line"><span class="comment">    println(e.p)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin的标准库中已经内置了很多的工厂方法来实现属性的委托: 常见的委托属性如 Lazy (只在第一次调用执行某些代码), Observable, Not Null等.</span></span><br><span class="line"><span class="comment">// 当然, Kotlin也支持为 局部变量 声明委托属性.</span></span><br><span class="line"><span class="comment">// 翻译规则: 对于各个 属性委托, Kotlin在背后会自动生成相应的代码 (通过Getter和Setter原理)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供委托: 通过定义 provideDelegate操作符, 可以拓展 创建属性实现所委托对象的逻辑.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</span></span><br><span class="line"><span class="comment">operator fun provideDelegate(</span></span><br><span class="line"><span class="comment">        thisRef: MyUI,</span></span><br><span class="line"><span class="comment">        prop: KProperty&lt;*&gt;</span></span><br><span class="line"><span class="comment">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span></span><br><span class="line"><span class="comment">    checkProperty(thisRef, prop.name)</span></span><br><span class="line"><span class="comment">    // 创建委托</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class MyUI &#123;</span></span><br><span class="line"><span class="comment">    val image by bindResource(ResourceID.image_id)</span></span><br><span class="line"><span class="comment">    val text by bindResource(ResourceID.text_id)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: provideDelegate方法只影响 辅助属性 的创建, 并不会影响为Getter/Setter生成的代码.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/07/27/rust-rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/rust-rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Rust - 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-27 01:05:00" itemprop="dateCreated datePublished" datetime="2021-07-27T01:05:00+00:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rust-Study-Note"><a href="#Rust-Study-Note" class="headerlink" title="Rust Study Note"></a>Rust Study Note</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用use关键字能将 模块标识符 引入 当前作用域</span></span><br><span class="line"><span class="keyword">use</span> crate::saygoodbye_mod::sayGoodbye;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::&#123;io, fs, thread&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, stdin&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> saygoodbye_mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述 mod 的树状结构</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="comment">// Rust语言的函数书写格式非常常规</span></span><br><span class="line">    <span class="comment">// 同时Rust支持在任何地方书写函数</span></span><br><span class="line">    <span class="comment">// Rust要求函数的参数列表必须声明 参数名称 和 参数类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">innerFoo</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value of x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The println isn&#x27;t a function.</span></span><br><span class="line">    <span class="comment">// So, we should add &#x27;!&#x27; to use it.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量: 我们可以使用let来定义变量, Rust会进行自动类型推断</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 但是, 默认情况下let创建的是 不可变变量</span></span><br><span class="line">    <span class="comment">// 我们无法修改这个变量的值</span></span><br><span class="line">    <span class="comment">// a = 200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要创建可变变量, 则需要使用 let mut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="number">100</span>;</span><br><span class="line">    b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变变量 与 常量 不同</span></span><br><span class="line">    <span class="comment">// 在Rust中, 不可变变量可以被重新绑定, 但常量不可以.</span></span><br><span class="line">    <span class="comment">// 我们把这种 重新绑定 称为 重影(Shadowing)</span></span><br><span class="line">    <span class="comment">// 即: 变量的名称可以被重新使用的机制 为 重影, 重影时变量的类型, 可变属性和值都可以变化</span></span><br><span class="line">    <span class="keyword">let</span>  <span class="variable">c</span> = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然Rust可以自动类型推断, 但是也可以手动指定变量的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span>: <span class="type">i32</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重影时并不会重置变量的旧值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = e + <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of e = &#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rust中, 没有 自增运算符/自减运算符, 但可以改变写法.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="number">3</span>;</span><br><span class="line">    f += <span class="number">1</span>;</span><br><span class="line">    f -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了基本变量之外, Rust中可以使用 复合类型 元组.</span></span><br><span class="line">    <span class="comment">// 在Rust中, 元组属于基本类型, 使用 值传递</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中同样也支持数组.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在创建数组时使用指定值来填充</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 数组包含5个元素3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此外, 数组也受mut影响, 如果后续要修改数组, 则数组要用mut修饰.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rust中, 使用3个斜杠作为 文档注释 的开头.</span></span><br><span class="line">    <span class="comment">// 在文档注释中, 支持使用Markdown语法</span></span><br><span class="line">    <span class="comment">/// This is a documentation comment.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 支持使用 大括号 编写 复杂的表达式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">m</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 函数体表达式: 由大括号引出的块中, 复杂表达式返回的值 即为 最后一个表达式的返回值</span></span><br><span class="line">        m + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;&#125;&quot;</span>, m);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;n = &#123;&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust的函数使用 -&gt; 来声明返回值</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust的 If语句 与 Go语言相似.</span></span><br><span class="line">    <span class="comment">// Rust不支持 bool 和 整数 的自动转换</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">95</span>;</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">90</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;成绩优秀&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三目运算符: 在Rust中可以使用 函数体表达式 来模拟 三目运算符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;<span class="number">1</span>&#125; <span class="keyword">else</span> &#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中支持 while语句 和for语句</span></span><br><span class="line">    <span class="comment">// 同时, for语句也支持foreach. 只需要使用 for in即可</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用下标来访问数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;&#125;] = &#123;&#125;&quot;</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust语言额外提供了 无限循环语句 loop语句</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// Endless loop will break here.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop语句可以通过 break语句来 返回值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="number">200</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中引入了 所有权机制</span></span><br><span class="line">    <span class="comment">// 所有权规则:</span></span><br><span class="line">    <span class="comment">// 1. Rust中的每一个值 都有一个变量, 称为该值的 所有者</span></span><br><span class="line">    <span class="comment">// 2. 每个值一次只能有1个 所有者</span></span><br><span class="line">    <span class="comment">// 3. 当值的所有者不在程序运行范围时, 该值会被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中, 变量与数据的交互方式有2种: 移动Move 和 克隆Clone</span></span><br><span class="line">    <span class="comment">// 当s1被赋值给s2时, 此时s1将立即失效. (s1 移动给了 s2)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">    <span class="comment">// println!(&quot;s1 = &#123;&#125;&quot;, s1);</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line">    <span class="comment">// 如果需要让s1和s2各在堆内存中持有1份数据, 则需要使用克隆</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s2.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于非基本类型: 当变量被当做参数传给函数时, 也会发生 移动Move</span></span><br><span class="line">    <span class="comment">// 被当做函数返回值的变量的所有权 会被 移动出函数, 并将 所有权 返回到调用函数的地方 (而不是直接被无效而释放内存)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 &amp;运算符 来获取 变量的引用, 使用引用 不会导致 移动Move.</span></span><br><span class="line">    <span class="comment">// 引用: 不会获得值的所有权, 但是能 租借(Borrow)值的所有权. (引用不具有 所指向的值的所有权, 但是具有 使用权)</span></span><br><span class="line">    <span class="comment">// 引用本身也是一个类型, 并且引用具有一个值 (该值即为 别的值所在的位置), 但引用不具有 所指向的值的所有权.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 1个引用 在租借所有权的期间, 该引用所指向的值的所有权发生了移动, 则该引用应当重新进行租借.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="comment">// s1的所有权 移动到 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line">    <span class="comment">// 此时, s2引用 需要重新租借所有权</span></span><br><span class="line">    s2 = &amp;s3;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of s2: &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用无法修改所有者的值. (除非 所有者的值 允许引用修改)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;<span class="keyword">mut</span> s1;</span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of s2: &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变引用 不允许 多重引用(即所有者的值 可以被多次引用), 但 不可变引用 允许.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切片: 指对 数据值的部分引用.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;broadcat&quot;</span>);</span><br><span class="line">    <span class="comment">// 0..5 其实相当于其他语言的 0:5</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, part);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rust中, 字符串切片 的类型为 &amp;str.</span></span><br><span class="line">    <span class="comment">// Rust中的字符串常量的类型也为 &amp;str</span></span><br><span class="line">    <span class="comment">// Rust中存在2种字符串类型: str 和 String</span></span><br><span class="line">    <span class="comment">// 切片不仅仅适用于字符串, 还适用于某些 线性数据结构, 如数组.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust语言支持结构体struct, 通过如下方式 定义结构体类型</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">i32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Key-Value方式来创建 结构体实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zhangsan</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;张三&quot;</span>),</span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 与 结构体属性名 同名的 变量名 来快速给结构体赋值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zhangsan</span> = Person &#123;</span><br><span class="line">        name, <span class="comment">// 相当于 name = &quot;name&quot;</span></span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 现有的结构体 来快速对新建的结构体 进行赋值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lisi</span> = Person&#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">        ..zhangsan</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出于方便考虑, 你也可以使用 元组结构体</span></span><br><span class="line">    <span class="comment">// 元组结构体: 具有固定的名称 和 固定的类型格式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于结构体struct, 它必须同时掌握 所有字段的所有权</span></span><br><span class="line">    <span class="comment">// 因此, 对于结构体, 更推荐使用 String类型来代替 &amp;str</span></span><br><span class="line">    <span class="comment">// 如果要在结构体中定义 引用型字段, 则需要通过&quot;生命周期&quot;机制来实现.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust提供了对 结构体输出的快捷方法</span></span><br><span class="line">    <span class="comment">// 需要导入 #[derive(Debug)]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, lisi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust不是面向对象语言, 但是可以采用面向对象思想来编程</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构体方法 (Struct Method): Rust支持给结构体struct绑定方法, 同时Rust强制要求该方法的第一个参数为&amp;self</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构体函数 (Struct Function): 结构体函数与具体的结构体实例没关联, 不需要&amp;self参数, 但需要声明属于哪一个结构体</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">say_hi</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时, 必须使用Person::say_hi();来调用, 不可以使用具体的结构体实例来调用.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the name of person: &#123;&#125;&quot;</span>, lisi.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust也支持枚举类</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        Papery, Electronic</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Book::Papery);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust也支持为 枚举元素 绑定 元组属性描述.</span></span><br><span class="line">    <span class="comment">// 当然, 也可以使用 结构体语法 来绑定属性描述</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        Dog &#123;age: <span class="type">i32</span>&#125;, Cat &#123;name: <span class="type">String</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 match语法 可以处理枚举类</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span> = Animal::Cat &#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;花花&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">match</span> animal &#123;</span><br><span class="line">        Animal::Dog &#123;age&#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Dog: age = &#123;&#125;&quot;</span>, age);</span><br><span class="line">        &#125;,</span><br><span class="line">        Animal::Cat &#123;name&#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cat: name = &#123;&#125;&quot;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// match语法除了可以处理 枚举类外, 还可以处理整数, 浮点数, 字符和字符串切片引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust语言不支持null, 但可以使用Option枚举类 (配合match来进行判空)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span> = <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 当使用Option::None的时候, 必须帮助编译器手动指出 空值所关联的类型.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="type">Option</span>::<span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option还是一个特殊的枚举类, 它可以在match中进行 含值的分支选择</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="title function_ invoke__">Some</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">64</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 只有2种情况的match语法, 可以使用 if let语法 来简化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">0</span> = i &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust的组织管理中存在3个重要概念: 箱, 包, 模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箱 (Crate) 是二进制程序文件 或 库文件, 存放在 包 中</span></span><br><span class="line">    <span class="comment">// &quot;箱&quot;是树状结构的, 树根是 编译器开始运行时 编译的源文件所编译的程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包 (Package) 是 工程是实质, 包必须由Cargo.toml文件来管理</span></span><br><span class="line">    <span class="comment">// Cargo.toml文件描述了 包的基本信息 以及 依赖项</span></span><br><span class="line">    <span class="comment">// 1个包 最多包含1个 库&quot;箱&quot;, 但可以包含任意数量的 二进制&quot;箱&quot;, 且至少包含1个箱</span></span><br><span class="line">    <span class="comment">// Cargo默认将 main.rs文件 作为 二进制箱的跟, 编译之后的二进制箱 与 包名相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块 (Module) 是 Rust中的组织单位</span></span><br><span class="line">    <span class="comment">// Rust中使用的路径分隔符是::</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中的绝对路径从 crate关键字开始描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust的访问权限分为 公开public 和 私有private</span></span><br><span class="line">    <span class="comment">// 默认情况下, 模块中的成员访问权 是 私有的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模块中定义了结构体struct, 则结构体本身 和 结构体内的字段 均是私有的.</span></span><br><span class="line">    <span class="comment">// Rust中的模块Module有点类似Java中的类包装</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过mod方式来引入其他文件的函数</span></span><br><span class="line">    saygoodbye_mod::<span class="title function_ invoke__">sayGoodbye</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中的 导入语句 为 use</span></span><br><span class="line">    <span class="comment">// 使用use关键字能将 模块标识符 引入 当前作用域</span></span><br><span class="line">    <span class="title function_ invoke__">sayGoodbye</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然, 如果出现2个相同名称的冲突情况, 则需要使用 use .. as ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中的错误处理不使用try机制.</span></span><br><span class="line">    <span class="comment">// Rust中的错误分为: 不可恢复错误 和 可恢复错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可恢复错误: panic!宏</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可恢复错误: Rust中可能产生异常的函数的返回值均为Result类型.</span></span><br><span class="line">    <span class="comment">// 在这点上与Go语言处理异常有点类似.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    enum Result&lt;T, E&gt; &#123;</span></span><br><span class="line"><span class="comment">    Ok(T),</span></span><br><span class="line"><span class="comment">    Err(E),</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;file open successfully.&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;failed to open the file.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   我们可以使用 if let语法 来简化 只有2种情况的match语法</span></span><br><span class="line"><span class="comment">   if let Ok(file) = f &#123;</span></span><br><span class="line"><span class="comment">        println!(&quot;File opened successfully.&quot;);</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        println!(&quot;Failed to open the file.&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 unwrap()和expect()均可以将 可恢复错误 当做 不可恢复错误 来处理</span></span><br><span class="line">    <span class="comment">// 调用这2个方法均会调用 panic!宏</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中可以通过在 Result对象后添加 ?操作符 来将 同类的Err直接传递出去</span></span><br><span class="line">    <span class="comment">// ?操作符: 将Result类 非异常的值取出, 如果有异常则将 异常的Result返回出去(故 ?操作符 仅适用于 返回值类型为Result&lt;T, E&gt;的函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过 Err.kind()方法来获取 错误的具体类型, 搭配match语句 来实现错误处理.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_text_from_file</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_file</span> = <span class="title function_ invoke__">read_text_from_file</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> str_file &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> e.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">                io::ErrorKind::NotFound =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;No such file&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                _ =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Cannot read the file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中支持泛型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">        x: T,</span><br><span class="line">        y: T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中存在 特性trait, 这有点类似Java中的interface</span></span><br><span class="line">    <span class="comment">// 可以使用 trait 来表示 类中有哪些方法</span></span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Eater</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">eat</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的实现中使用 for 来使用接口</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Eater</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">eat</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;person eat something.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Person::<span class="title function_ invoke__">eat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特性trait 可以作为函数的参数</span></span><br><span class="line">    <span class="comment">// 下面是通过 trait 来实现 Comparable功能的取最大值函数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            trait Comparable &#123;</span></span><br><span class="line"><span class="comment">            fn compare(&amp;self, object: &amp;Self) -&gt; i8;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        fn max&lt;T: Comparable&gt;(array: &amp;[T]) -&gt; &amp;T &#123;</span></span><br><span class="line"><span class="comment">            let mut max_index = 0;</span></span><br><span class="line"><span class="comment">            let mut i = 1;</span></span><br><span class="line"><span class="comment">            while i &lt; array.len() &#123;</span></span><br><span class="line"><span class="comment">                if array[i].compare(&amp;array[max_index]) &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">                    max_index = i;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                i += 1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &amp;array[max_index]</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        impl Comparable for f64 &#123;</span></span><br><span class="line"><span class="comment">            fn compare(&amp;self, object: &amp;f64) -&gt; i8 &#123;</span></span><br><span class="line"><span class="comment">                if &amp;self &gt; &amp;object &#123; 1 &#125;</span></span><br><span class="line"><span class="comment">                else if &amp;self == &amp;object &#123; 0 &#125;</span></span><br><span class="line"><span class="comment">                else &#123; -1 &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        fn main() &#123;</span></span><br><span class="line"><span class="comment">            let arr = [1.0, 3.0, 5.0, 4.0, 2.0];</span></span><br><span class="line"><span class="comment">            println!(&quot;maximum of arr is &#123;&#125;&quot;, max(&amp;arr));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特性trait可以作函数的返回值, 但是要求函数中 所有可能的返回值类型 必须完全一样.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// impl可以限制 实现方法的条件, 比如要求 T在已经实现B和C特性的情况下, 才可以实现该impl块</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct A&lt;T&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    impl&lt;T: B + C&gt; A&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        fn d(&amp;self) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中存在 生命周期 的概念, 同时支持 生命周期注释</span></span><br><span class="line">    <span class="comment">// 生命周期注释: 用于描述 引用的生命周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过该使用 泛型声明 来规范 生命周期的名称</span></span><br><span class="line">    <span class="comment">// 通过生命周期注释, 将返回值str的生命周期 声明为 与 传入参数的生命周期一致</span></span><br><span class="line">    <span class="comment">// 注意: 所有用双引号包括的字符串常量所代表的精确数据类型都是 &amp;&#x27;static str</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">longer_number</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s2.<span class="title function_ invoke__">len</span>() &gt; s1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            s2</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rust支持基本的 命令行操作 和 IO操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令行操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str_buf</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> str_buf).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to read line.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;your input line is: &#123;&#125;&quot;</span>, str_buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;D:\\ImportantData\\text.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中关于文件操作并没有配套的close()操作, 因为Rust会在文件不再被使用的时候自动关闭.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rust中提供集合和字符串 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量容器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 也可以通过已有数组来创建vector</span></span><br><span class="line">    <span class="comment">// let mut v = vec![100, 200];</span></span><br><span class="line"></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">100</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">// get方法无法保证一定取到值, 故返回值为Option类</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串String的每个字符采用UTF-8编码, 每个char占用3个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 面向对象 */</span></span><br><span class="line">    <span class="comment">// Rust不属于面向对象语言, 但是可以采用面向对象思想.</span></span><br><span class="line">    <span class="comment">// 通过impl来为struct绑定方法 (self关键字)</span></span><br><span class="line">    <span class="comment">// 通过手动编写new方法来模拟构造函数</span></span><br><span class="line">    <span class="comment">// Rust中可以通过 trait 来实现&quot;多态&quot;</span></span><br><span class="line">    <span class="comment">// Rust没有提供与&quot;继承&quot;相关的语法糖.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 并发编程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中可以通过spawn()来创建新线程</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">spawn_function</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;spawned thread print &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(spawn_function);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;main thread print &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust也支持 闭包 Closures</span></span><br><span class="line">    <span class="comment">// 闭包相当于Rust中的lambda表达式</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>( &#123;</span><br><span class="line">       <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">           <span class="built_in">println!</span>(<span class="string">&quot;current value: &#123;&#125;&quot;</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用move关键字来 强制所有权迁移, 避免在 当前子线程使用当前函数的资源</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust中的消息传递可以通过 管道Channel 来完成.</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>  &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/07/25/socket-%E9%80%9A%E8%BF%87go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84tcp%E9%80%9A%E8%AE%AF%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/socket-%E9%80%9A%E8%BF%87go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84tcp%E9%80%9A%E8%AE%AF%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">Go - Socket编程 - 简单的TCP通讯工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-25 23:03:30" itemprop="dateCreated datePublished" datetime="2021-07-25T23:03:30+00:00">2021-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过Go语言强大的net库和协程能力来构建TCP通讯实例。</p>
<h1 id="TCP-Server"><a href="#TCP-Server" class="headerlink" title="TCP Server"></a>TCP Server</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reader := bufio.NewReader(conn)</span><br><span class="line">        <span class="keyword">var</span> buf [<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        n, err := reader.Read(buf[:])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;read from client failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recvStr := <span class="type">string</span>(buf[:n])</span><br><span class="line">        fmt.Println(<span class="string">&quot;收到来自Client的数据:&quot;</span>, recvStr)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        conn.Write([]<span class="type">byte</span>(recvStr))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:20000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;listen failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;listen successfully.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        conn, err := listen.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;server accept failed, err:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动1个goroutine来处理TCP连接</span></span><br><span class="line">        <span class="keyword">go</span> process(conn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="TCP-Client"><a href="#TCP-Client" class="headerlink" title="TCP Client"></a>TCP Client</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建立TCP连接</span></span><br><span class="line">   conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:20000&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;dial failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭连接资源</span></span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">   inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取用户输入</span></span><br><span class="line">      input, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      inputInfo := strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 输入Q退出</span></span><br><span class="line">      <span class="keyword">if</span> strings.ToUpper(inputInfo) == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Client向Server发送数据</span></span><br><span class="line">      _, err = conn.Write([]<span class="type">byte</span>(inputInfo))</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;client send data failed, err:&quot;</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buf := [<span class="number">512</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">      n, err := conn.Read(buf[:])</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;recv failed, err:&quot;</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fmt.Println(<span class="type">string</span>(buf[:n]))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/07/24/%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F%E5%A4%B9-%E5%90%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BC%98%E7%A7%80%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/24/%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F%E5%A4%B9-%E5%90%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BC%98%E7%A7%80%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Tools - Magic Tools</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-24 22:52:19" itemprop="dateCreated datePublished" datetime="2021-07-24T22:52:19+00:00">2021-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>各类操作系统中优质的应用程序收集。</p>
<ul>
<li>Windows<ul>
<li>Electron QQ：第三方QQ软件，提供朴素的聊天功能。</li>
<li>火绒：杀毒软件，带常用功能工具箱。</li>
<li>Google Chrome：世界上最好的浏览器。</li>
<li>360极速浏览器：与Google浏览器内核相同，带兼容模式可作备用浏览器。（部分网页在Google Chrome下无法正常使用）</li>
<li>搜狗输入法：国内用户量巨大的输入法。可全平台账号同步数据。</li>
<li>百度网盘：国内最大的网盘存储提供商。免费存储额度充足。</li>
<li>酷狗音乐：正版音乐源较多的音乐播放器。</li>
<li>网易云音乐：多平台可用的音乐播放器，特色为云音乐。</li>
<li>Listen 1音乐播放器：聚合音乐播放器，支持国内多个主流音乐平台。</li>
<li>Pomotodo：全平台的朴素GTD软件。</li>
<li>Bandizip：世界上最好的解压缩软件。</li>
<li>Rolan：Windows上可用的高颜值启动板。</li>
<li>Evernote：全平台可用的笔记软件。</li>
<li>OneNote：微软系下的笔记软件，功能比Evernote强。</li>
<li>MindManager：思维导图软件（Windows + Android可用）</li>
<li>Notepad++：比Notepad更强的编辑器，简单强大。</li>
<li>Edraw：流程图绘制软件。</li>
<li>Bandicam：强大的高质量视频录制软件。</li>
<li>RegexBuddy：强大的Regex测试工具。</li>
<li>Cheat Engine：强大的内存修改&#x2F;汇编工具。</li>
<li>OD：反汇编工具</li>
<li>Ffmpeg：强大的音频&#x2F;视频处理软件。</li>
<li>Navicat：强大的数据库可视化操作软件。</li>
<li>FlashFXP：简单易用的FTP连接软件。</li>
<li>JSONEdit：复杂JSON操作软件。</li>
<li>Charles：简单易用的HTTP&#x2F;HTTPS抓包软件</li>
<li>WireShark：强大的网络包抓取软件。</li>
<li>Fiddler：强大的HTTP&#x2F;HTTPS协议抓包软件</li>
<li>IDEA：Java&#x2F;Kotlin语言的强大IDE</li>
<li>PyCharm：Python语言的强大IDE</li>
<li>Visual Studio：C&#x2F;C++语言的强大IDE</li>
<li>GoLand：Go语言的强大IDE</li>
<li>Clion：C&#x2F;C++语言的强大IDE</li>
<li>Scene Builder：高效的JavaFX FXML绘制器</li>
<li>Sublime Text：强大的编辑器。</li>
<li>VS Code：全平台的强大编辑器。（Langs：Lua）</li>
<li>Atom：由Github推出的高颜值编辑器。</li>
<li>Git：版本控制工具。</li>
<li>Vim：全平台的强大编辑器。</li>
<li>Emacs：奇怪的编辑器。</li>
<li>VMWare：强大的虚拟机软件。</li>
<li>Postman：强大的接口测试软件。</li>
<li>Everything：文件快速搜索软件。</li>
<li>Listry：文件快速搜索软件。</li>
<li>XueTr：Windows下的手动杀毒软件。</li>
<li>Quick Hider：窗口&#x2F;进程隐藏软件。</li>
<li>TeamViewer：全平台的远程控制软件。</li>
<li>MobaXterm: 强大的终端软件。</li>
<li>Exe4j：Java打包软件。</li>
<li>EasyConnect：简易的VPN软件。</li>
<li>YouDao Dict：有道词典，支持快速翻译，划字查询。</li>
<li>Snipaste：强大的截图软件。</li>
<li>ScreenToGif：强大的Gif截取软件。</li>
<li>Packers：简易加壳软件。</li>
<li>WallPaper Engine：资源丰富的壁纸软件。</li>
<li>Discuss：国外IM软件。</li>
</ul>
</li>
<li>Android<ul>
<li>MT管理器：文件浏览器 + APK操作</li>
<li>RE管理器：文件管理器</li>
<li>Ti备份：文件备份&#x2F;应用数据备份</li>
<li>AIDE：Android上的Java IDE</li>
<li>QQ影音：腾讯系已挂的软件，支持多格式高倍速播放。</li>
<li>豌豆荚：优质Android App下载（支持历史版本下载）</li>
<li>酷安：Android 玩机必备。</li>
<li>快图浏览：比系统相册更高速的相册软件。</li>
<li>LongShot：智能的长图合成软件。</li>
<li>SQLite Editor：SQLite数据库编辑器。</li>
<li>App Settings：模拟虚拟App运行环境。</li>
<li>Dual Space：沙盒软件。</li>
<li>Game Guardian：强大的内存修改软件。</li>
<li>iMark：简单强大的图片标注软件。</li>
<li>Google服务框架：Google系服务必备。</li>
<li>Xposed框架：Android玩机必备。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/03/31/soj1107-%E7%89%B2%E5%8F%A3%E6%A3%9A%E7%9A%84%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/soj1107-%E7%89%B2%E5%8F%A3%E6%A3%9A%E7%9A%84%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">SOJ 1107 -  牲口棚的安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-31 16:51:55" itemprop="dateCreated datePublished" datetime="2021-03-31T16:51:55+00:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/" itemprop="url" rel="index"><span itemprop="name">oj</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OJ/" itemprop="url" rel="index"><span itemprop="name">OJ</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/SOJ/" itemprop="url" rel="index"><span itemprop="name">SOJ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="了解-C-STL的全排列函数"><a href="#了解-C-STL的全排列函数" class="headerlink" title="了解 C++ STL的全排列函数"></a>了解 C++ STL的全排列函数</h1><p>首先, 对于<code>全排列算法</code>, C++ STL提供了next_permutation(begin, end)函数, 使用该函数可以按<code>字典序</code>来获得<code>全排列中的下一个排列</code>. 只需要循环调用该函数, 即可获得<code>所有的全排列情况</code> 注意: next_permutation()函数对支持迭代器的容器均使用, 可以直接用于string类, 也可以用于 数组(需传入指针).</p>
<h1 id="读读题目-了解需求"><a href="#读读题目-了解需求" class="headerlink" title="读读题目, 了解需求"></a>读读题目, 了解需求</h1><p>根据题目要求, 需要我们用<code>一组字母</code>按组成<code>符合条件的密码</code> 可以得出以下信息：</p>
<blockquote>
<p>(条件1) 有效的密码 均由 小写字母组成 (条件2) 有效的密码 至少包含1个元音字母 + 至少包含2个辅音字母 (条件3) 有效的密码 必须符合 字典序 (条件4) 一组字母 里的字母不可以被重复使用. (条件5) 最终的输出结果列表, 也要求按字典序输出. (条件6) 密码要求L位数</p>
</blockquote>
<p>考虑到<code>最终的输出结果也必须要按字典序输出</code>这个条件, 我们不妨直接在 算法阶段 就按字典序来进行<code>密码构造</code>，这样就方便很多了。（其实这个 按字典序输出 有些<code>暗示</code>的意义了, 大概知道这里需要进行全排列.）</p>
<h1 id="放宽条件-获得”全部的密码列表”"><a href="#放宽条件-获得”全部的密码列表”" class="headerlink" title="放宽条件: 获得”全部的密码列表”"></a>放宽条件: 获得”全部的密码列表”</h1><p>对于<code>条件1</code>，很容易进行满足，我们只需要保证输入和算法处理时，都使用小写字母即可（不要用大写字母和小写字母混杂，否则字典序处理会引入新的麻烦） 对于<code>条件3</code>，我们可以在<code>构造密码</code>阶段就按字典序来构造，也就是使用我们上面所说的<code>next_permutation()函数</code>, 因为这个<code>全排列算法</code>是按<code>字典序</code>来进行排列的。在构造密码时就满足<code>条件3</code>的话，自然<code>条件5</code>也就满足了。 结合<code>条件3</code>和<code>条件4</code>，我们将使用<code>一串字母</code>来构造字符串，然后对这个字符串进行<code>按字典序排列</code>得到<code>基础字符串</code> 如: <code>一串字母&quot;a t c i s w&quot;</code>可以构造<code>字符串&quot;atcisw&quot;</code>，然后对该字符串进行按字典序排列可得到<code>基础字符串acistw</code>，接下来，我们只需要对<code>基础字符串</code>运行<code>next_permutation()函数</code>即可得到由<code>这一串字母按字典序排列的所有可能的密码</code> 据此，到这一步，我们获得的密码列表中，并非所有的密码都是<code>有效的密码</code>。 但是，我们可以肯定，<code>有效的密码列表</code>是<code>全部的密码列表</code>的1个子集，且由于<code>全部的密码列表</code>里的<code>密码</code>是按<code>字典序</code>列出的，所以，我们只需要对<code>全部的密码列表</code>过滤掉<code>一些无效的密码</code>，即可获得<code>有效的密码列表</code>。 这个<code>有效的密码列表</code>也就是<code>最终的答案</code>了。</p>
<h1 id="限制条件-过滤”全部的密码列表”得”有效的密码列表”"><a href="#限制条件-过滤”全部的密码列表”得”有效的密码列表”" class="headerlink" title="限制条件: 过滤”全部的密码列表”得”有效的密码列表”"></a>限制条件: 过滤”全部的密码列表”得”有效的密码列表”</h1><p>根据<code>条件6</code>, 要求密码的长度为指定的L位, 我们只需要对<code>密码</code>进行<code>截短</code>即可得到<code>L位长度的密码</code> 然后再根据<code>条件2</code>，我们可以编写1个简单的 判断函数，在<code>全部的密码列表</code>中剔除掉这些 元音和辅音字母不满足的<code>密码</code> 到这一步，我们已经得到了<code>有效的密码列表</code>了， 只需要<code>按顺序输出该列表里的所有密码</code>即可 注意：在输出<code>有效的密码列表</code>时，要注意<code>重复的字符串</code>的问题，因为我们之前进行<code>截短字符串</code>，导致可能的<code>字符串重复</code>，对于<code>重复字符串</code>，只需要输出1次即可。（需要稍微记录下，哪些字符串重复过，以便在输出时进行判断。）</p>
<h1 id="回顾流程"><a href="#回顾流程" class="headerlink" title="回顾流程"></a>回顾流程</h1><p>在整个题目中，虽然要求我们构造 满足多个条件限制的密码。 但是，我们人为地放宽了<code>条件</code>，以此来得到<code>最终答案</code>的<code>超集</code>。 紧接着，我们再<code>引入条件</code>，来获得<code>最终答案</code> 总体流程： 根据<code>一组字母</code> -&gt; 构造<code>基础字符串</code> -&gt; 对<code>基础字符串</code>运行next_permutation()获得<code>全部的密码列表</code>(已按字典序排列) -&gt; 在<code>全部的密码列表</code>里<code>截短</code>密码 -&gt; 在<code>全部的密码列表</code>中过滤掉不符合元音辅音字母要求的<code>密码</code> -&gt; 按顺序输出<code>全部的密码列表</code>里的密码 (去重输出)</p>
<h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><p>需include stdio.h, stdlib.h, algorithm, vector, set, map, string, iostream<br>#pragma warning (disable:4996)</p>
<p>using namespace std;</p>
<p>bool limitC(string psw) {<br>    int vowelCnt &#x3D; 0;<br>    int consonantCnt &#x3D; 0;</p>
<pre><code>for (int i = 0; i &lt; psw.size(); i++) &#123;

    if (psw\[i\] == &#39;a&#39;  psw\[i\] == &#39;e&#39;  psw\[i\] == &#39;i&#39;  psw\[i\] == &#39;o&#39;
         psw\[i\] == &#39;u&#39;) &#123;
        vowelCnt++;
    &#125;
    else &#123;
        consonantCnt++;
    &#125;

&#125;

return vowelCnt &gt;= 1 &amp;&amp; consonantCnt &gt;= 2 ? true : false;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>int L, C;
scanf(&quot;%d %d&quot;, &amp;L, &amp;C);

/\* 构造字母表 \*/
set letters;
for (int i = 0; i &lt; C; ) &#123;
    char ch;
    cin &gt;&gt; ch;
    letters.insert(ch);
    i++;
&#125;

/\* 构造BasePsw. \*/
string basePsw;
for (set::iterator iter = letters.begin(); iter != letters.end(); iter++) &#123;
    basePsw += \*iter;
&#125;
sort(basePsw.begin(), basePsw.end());
//printf(&quot;获得基础字符串: %s\\n&quot;, basePsw.c\_str());

/\* 获取按字典序全排列的密码列表. \*/
// 去重记录
map used;
while (next\_permutation(basePsw.begin(), basePsw.end())) &#123;

    // 截取: 将密码截取为指定L位.
    string temp = string(basePsw, 0, L);

    // 过滤: 元音和辅音字母不满足条件的密码.
    if (!limitC(temp)) continue;

    // 字典序: 对密码进行字典序排列.
    sort(temp.begin(), temp.end());

    // 去重记录: 以便输出时进行判断.
    if (used\[temp\] == false) &#123;
        puts(temp.c\_str());
    &#125;
    used\[temp\] = true;
&#125;
</code></pre>
<p>} </p>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2021/03/31/Mqp35bmK1ElPyTL.jpg"><img src="https://i.loli.net/2021/03/31/Mqp35bmK1ElPyTL.jpg"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/03/31/soj-1521-%E5%90%83%E9%B8%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/soj-1521-%E5%90%83%E9%B8%A1/" class="post-title-link" itemprop="url">SOJ 1521 - 吃鸡 - Cases</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-31 15:58:34" itemprop="dateCreated datePublished" datetime="2021-03-31T15:58:34+00:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/" itemprop="url" rel="index"><span itemprop="name">oj</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OJ/" itemprop="url" rel="index"><span itemprop="name">OJ</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/SOJ/" itemprop="url" rel="index"><span itemprop="name">SOJ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Input-And-Output"><a href="#Input-And-Output" class="headerlink" title="Input And Output"></a>Input And Output</h1><p>“吃鸡”这道题目在许多地方没有说明清楚, 而且给的Sample并不具有代表性. 导致起初在写代码的时候未能准确定义情况. 比如: 初始状态即满足的情况下, 该输出0还是输出1? 处于状态临界的人, 到底该归属于”学习”还是”游戏”? 还是说根本不进行归属? 对状态的检测应该在哪一个时机? 是每个人都进行检测? 还是对全体进行检测? 综上许多问题并未能在样例中得出, 导致踩了很多坑. 下面给出吃鸡的测试数据, 仅供参考.</p>
<p>#Case 1<br>3 3 3<br>1 3 4<br>3 1 3<br>3 2 4<br>3 1 1<br>5 2 4<br>2 3 4<br>2 3 4<br>Output: 3</p>
<p>#Case 2<br>3 5 7<br>5 3 4<br>1 4 2<br>3 1 2<br>4 3 1<br>Output: 5</p>
<p>#Case 3<br>1 6 2<br>Output: NO</p>
<p>#Case 4<br>1 5 6<br>4 2 5<br>4 3 5<br>Output: NO</p>
<p>#Case 5<br>5 1 6<br>5 4 6<br>Output: 5</p>
<p>#Case6<br>5 1 1<br>2 4 5<br>3 5 3<br>Output: 3</p>
<p>#Case 7<br>2 4 3<br>5 5 5<br>2 1 2<br>3 5 2<br>3 5 5<br>1 1 2<br>3 5 5<br>3 2 5<br>Output: NO</p>
<p>#Case 8<br>5 5 3<br>4 2 1<br>3 4 6<br>Output: 3</p>
<p>#Case 9<br>3 2 3<br>Output: 1</p>
<p>#Case 10<br>1 4 2<br>1 5 5<br>5 5 1<br>4 5 3<br>5 4 6<br>4 1 1<br>5 3 4<br>1 1 1<br>4 3 2<br>2 4 6<br>Output: 5</p>
<p>#Case 11<br>1 4 5<br>2 2 3<br>3 4 2<br>1 5 3<br>1 4 2<br>3 2 5<br>2 1 2<br>1 5 1<br>2 2 3<br>Output: NO</p>
<p>#Case 12<br>1 3 2<br>5 5 5<br>3 2 2<br>2 4 2<br>3 4 6<br>4 2 1<br>3 4 1<br>Output: 4</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2021/02/15/soj-1003-1377-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%86%85%E7%9A%84%E9%AB%98%E9%80%9F%E8%AE%A1%E6%95%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/15/soj-1003-1377-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%86%85%E7%9A%84%E9%AB%98%E9%80%9F%E8%AE%A1%E6%95%B0%E5%99%A8/" class="post-title-link" itemprop="url">SOJ 1377 - 字符串统计(时间限制：3秒)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-15 16:20:33" itemprop="dateCreated datePublished" datetime="2021-02-15T16:20:33+00:00">2021-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/" itemprop="url" rel="index"><span itemprop="name">oj</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OJ/" itemprop="url" rel="index"><span itemprop="name">OJ</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oj/SOJ/" itemprop="url" rel="index"><span itemprop="name">SOJ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引题：求出现次数最多的数字"><a href="#引题：求出现次数最多的数字" class="headerlink" title="引题：求出现次数最多的数字"></a>引题：求出现次数最多的数字</h1><p>假设：给出N个<code>数字</code>, 需要求<code>出现次数最多的数字</code>. 则我们可以使用1个计数器数组来记录每一个数字的出现次数, 然后进行统计即可. <code>int count[数字] = 出现次数;</code> <code>int count[数字] += 1;</code> 只需在每次输入时, 利用 数组高效的随机访问 特性, 即可在O(1)时间内完成计数统计. (注意: 这里仅需对输入进行判断即可, 不需要将输入的数字存储下来.)</p>
<h1 id="转化：求出现次数最多的字符串"><a href="#转化：求出现次数最多的字符串" class="headerlink" title="转化：求出现次数最多的字符串"></a>转化：求出现次数最多的字符串</h1><p>假设: 给出N个<code>字符串</code>, 需要求 <code>出现次数最多的字符串</code>. 思路1: 我们可以用一个 二维的技术数组 将所有的字符串存储下来, 然后再统计出现次数最多的字符串. <code>缺点: 1. 该思路会将所有输入的字符串存储下来，占据大量的内存空间</code> <code>缺点: 2. 如果输入的字符串数量巨大, 如有10万个字符串, 而后续的统计操作是线性操作, 每次统计需要遍历10万个字符串, 需要耗费大量时间.</code> 思路2: 不妨延续我们之前处理“求出现次数最多的数字”的思路, 也适用一个<code>一维的计数数组</code>来解决问题. 因此： <code>int count[字符串] = 出现次数;</code> <code>int count[字符串] += 1;</code> 但是！数组的下标要求是一个<code>整数</code>，我们没法用<code>字符串</code>作数组的下标！！ 嗯，如果有办法将<code>字符串</code>映射到<code>数字</code>的话，问题就解决了。 我们称完成这种映射的函数为<code>哈希函数</code>。 <code>注意：哈希 = 散列, 哈希表(Map/HashTable/HashMap等意思相同) = 散列表. 这2个词语是同一个意思, 有些地方称 哈希表 为 散列表, 也有称为 字典(Dict)的, 但都是同一个东西.</code> 我们现在就来设计一个这样的<code>哈希函数</code>，并保证<code>哈希函数</code>满足这2个要求. 1. 对<code>相同的字符串</code>，每次映射出<code>相同的数字</code> 2. 对<code>不同的字符串</code>，每次映射出<code>不同的独一无二的字符串</code> 换句话说，如果我们第一次将<code>字符串“abc”</code>映射到<code>数字233</code>的话，那么第二次映射<code>字符串“abc”</code>的话，结果应该也是<code>数字233</code>. 而且，我们要保证<code>字符串“abcd”</code>不能映射到<code>数字233</code>，因为这个数字已经被<code>字符串“abc”</code>给占据掉了！（若无法保证<code>映射结果的独一无二</code>的话，便会发生<code>哈希冲突</code>） 注意：尽管<code>哈希冲突</code>是无法避免的, 但是我们应当尽可能降低发生的概率.</p>
<h3 id="1个简单的哈希函数-将字符串映射到数字"><a href="#1个简单的哈希函数-将字符串映射到数字" class="headerlink" title="1个简单的哈希函数 (将字符串映射到数字):"></a>1个简单的哈希函数 (将字符串映射到数字):</h3><p>该哈希函数的映射方式: 逐个累加字符的ASCII码值 并同时乘上 该字符所在的位置. 注意: 最后计算出的<code>哈希值</code>需要%MAXN(即哈希表数组的长度)来保证所求出的<code>哈希值</code>(即<code>哈希表数组的下标</code>是合法下标，也就是<code>避免数组越界</code>)</p>
<p>#define MAXN 1000<br>&#x2F;* 哈希函数 *&#x2F;<br>int Hash(const char * str) {<br>    int index &#x3D; 0;<br>    int at &#x3D; -1;<br>    while (str[at++]) {<br>        index +&#x3D; ((at + 1) * (str[at] % ‘a’)) % MAXN;<br>    }<br>    return index;<br>}</p>
<h1 id="动手实现自己的哈希表！"><a href="#动手实现自己的哈希表！" class="headerlink" title="动手实现自己的哈希表！"></a>动手实现自己的哈希表！</h1><p>注意：我们将上文所提到的<code>计数数组</code>称为<code>哈希表</code>，而我们自己写的<code>将字符串映射到数字的函数</code>称为<code>哈希函数</code> 结合上面的知识, 我们可以来解决问题了。</p>
<h6 id="SOJ1377-字符串统计-时间限制：3秒"><a href="#SOJ1377-字符串统计-时间限制：3秒" class="headerlink" title="SOJ1377 字符串统计(时间限制：3秒)"></a>SOJ1377 字符串统计(时间限制：3秒)</h6><p>需include: stdlib.h, stdio.h, string.h<br>#pragma warning (disable:4996)</p>
<p>&#x2F;&#x2F; 单词长度<br>#define MAX_LEN 105</p>
<p>&#x2F;* 哈希表 *&#x2F;<br>#define MAXN 1000<br>int map[MAXN];</p>
<p>&#x2F;* 哈希函数 *&#x2F;<br>int Hash(const char * str) {<br>    int index &#x3D; 0;<br>    int at &#x3D; -1;<br>    while (str[++at]) {<br>        index +&#x3D; ((at + 1) * (str[at] % ‘a’)) % MAXN;<br>    }<br>    return index;<br>}</p>
<p>int main() {<br>    int N; scanf(“%d”, &amp;N);</p>
<pre><code>char ans\_str\[MAX\_LEN\];
int ans\_count = 0;

while (N--) &#123;
    // WARNING: 输入使用gets()会Wrong Answer.
    char tempStr\[MAX\_LEN\]; scanf(&quot;%s&quot;, &amp;tempStr);
    int curCount = map\[Hash(tempStr)\] += 1;

    // Update Ans.
    if (curCount &gt; ans\_count) &#123;
        ans\_count = curCount;
        strcpy(ans\_str, tempStr);
    &#125;
&#125;

puts(ans\_str);
</code></pre>
<p>}</p>
<h6 id="SOJ1003-第三届程序设计大赛-让气球飞起来"><a href="#SOJ1003-第三届程序设计大赛-让气球飞起来" class="headerlink" title="SOJ1003 第三届程序设计大赛 让气球飞起来"></a>SOJ1003 第三届程序设计大赛 让气球飞起来</h6><p>代码与SOJ1377完全相同.</p>
<h1 id="不妨直接使用C-STL提供的map结构"><a href="#不妨直接使用C-STL提供的map结构" class="headerlink" title="不妨直接使用C++ STL提供的map结构"></a>不妨直接使用C++ STL提供的map结构</h1><p>延续上面的思路，我们也可以不必自己动手实现map. <a target="_blank" rel="noopener" href="https://i.loli.net/2021/02/15/3PMbwrn4BkA6O1X.jpg"><img src="https://i.loli.net/2021/02/15/3PMbwrn4BkA6O1X.jpg"></a> 注意: 使用C++ STL的map时, 若key为字符串, 则需要使用C++的string类. 但是, C的<code>scanf()</code>和<code>gets()</code>并不支持输入 string类, 所以只能使用<code>cin</code>来输入string. 注意: <code>cin</code>的输入效率比<code>scanf()</code>差很多, 如果字符串的输入量非常大, 需要重新设置<code>cin</code>的一些属性, 以加速<code>cin</code>的输入速度. 在使用cin输入string时, 请加上下面2句代码, 否则将会面临<code>Time Limit Exceed</code>的问题.</p>
<p>ios::sync_with_stdio(0);<br>cin.tie(0);</p>
<h1 id="来做题目叭"><a href="#来做题目叭" class="headerlink" title="来做题目叭"></a>来做题目叭</h1><h6 id="SOJ1003-第三届程序设计大赛-让气球飞起来-1"><a href="#SOJ1003-第三届程序设计大赛-让气球飞起来-1" class="headerlink" title="SOJ1003 第三届程序设计大赛 让气球飞起来"></a>SOJ1003 第三届程序设计大赛 让气球飞起来</h6><h6 id="SOJ1377-字符串统计-时间限制：3秒-1"><a href="#SOJ1377-字符串统计-时间限制：3秒-1" class="headerlink" title="SOJ1377 字符串统计(时间限制：3秒)"></a>SOJ1377 字符串统计(时间限制：3秒)</h6><p>通解代码 <a target="_blank" rel="noopener" href="https://i.loli.net/2021/02/15/8XOZd6kWVMy3nFi.jpg"><img src="https://i.loli.net/2021/02/15/8XOZd6kWVMy3nFi.jpg"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

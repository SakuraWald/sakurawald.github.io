<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sakurawald.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Inclusion-Exclusion Principle[TOC] Inclusion-Exclusion PrincipleDefinition设P_1, P_2, \cdots, P_m为集合S的对象所涉及的性质，则集合S中不具有性质P_1, P_2, \cdots, Pm的对象个数，A_i &#x3D; \{x: x\in S \quad and \quad x\ has\ propert">
<meta property="og:type" content="article">
<meta property="og:title" content="Combinatorics - In-Exclusion Principle &amp; Mobius Inversion">
<meta property="og:url" content="https://sakurawald.github.io/2022/03/31/counting-in-exclusion-principle-mobius-inversion/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:description" content="Inclusion-Exclusion Principle[TOC] Inclusion-Exclusion PrincipleDefinition设P_1, P_2, \cdots, P_m为集合S的对象所涉及的性质，则集合S中不具有性质P_1, P_2, \cdots, Pm的对象个数，A_i &#x3D; \{x: x\in S \quad and \quad x\ has\ propert">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/04/03/78Bds6FNvDUTYbq.png">
<meta property="article:published_time" content="2022-03-31T21:20:01.000Z">
<meta property="article:modified_time" content="2023-01-01T23:38:44.215Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/04/03/78Bds6FNvDUTYbq.png">

<link rel="canonical" href="https://sakurawald.github.io/2022/03/31/counting-in-exclusion-principle-mobius-inversion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Combinatorics - In-Exclusion Principle & Mobius Inversion | SakuraWald</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SakuraWald</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/03/31/counting-in-exclusion-principle-mobius-inversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Combinatorics - In-Exclusion Principle & Mobius Inversion
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-31 21:20:01" itemprop="dateCreated datePublished" datetime="2022-03-31T21:20:01+00:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Inclusion-Exclusion-Principle"><a href="#Inclusion-Exclusion-Principle" class="headerlink" title="Inclusion-Exclusion Principle"></a>Inclusion-Exclusion Principle</h1><p>[TOC]</p>
<h2 id="Inclusion-Exclusion-Principle-1"><a href="#Inclusion-Exclusion-Principle-1" class="headerlink" title="Inclusion-Exclusion Principle"></a>Inclusion-Exclusion Principle</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>设P_1, P_2, \cdots, P_m为<code>集合S</code>的<code>对象所涉及的性质</code>，则<code>集合S</code>中<code>不具有性质</code>P_1, P_2, \cdots, Pm<code>的对象个数</code>，A_i &#x3D; \{x: x\in S \quad and \quad x\ has\ property\ P_i\}，可以由下面的交错表达式求出：</p>
<p>其中，<code>第1个和</code>对<code>&#123;1,2, ... , m&#125;的所有1子集&#123;i&#125;</code>进行求和，<code>第2个和</code>对<code>&#123;1,2, ..., m&#125;的所有2子集&#123;i, j&#125;</code>进行求和，<code>第3个和</code>对<code>&#123;1,2, ..., m&#125;的所有3子集&#123;i, j, k&#125;</code>进行求和，…，<code>第m个和对&#123;1,2, ..., m&#125;的所有m子集</code>进行求和。</p>
<blockquote>
<p>注意：</p>
<p><code>上述式子所描述的对象</code> <code>恰好不包含m条性质中的任何一条性质</code></p>
<p><code>m</code>表示的是<code>集合S的所有对象所涉及的性质的总数</code>，也就是说<code>总共有m条性质</code>。</p>
<p>而<code>k</code>表示的是<code>集合S的某个对象所具有的k条性质</code>，也就是说<code>0 ≤ k ≤ m</code>。</p>
<p>上述的<code>容斥原理公式</code>中，如果<code>某个对象并没有具有全部的m条性质，而仅仅具有m条性质中的k条性质</code>，则<code>左式为 该对象所具有的k条性质的交集</code>，<code>右式可以保持不变，但应清楚:</code> <code>所有的集合S中的具有k+1条性质的集合的交集 = 0</code>。从而可以直接<code>去除这些零项</code></p>
<p>原因是：对于<code>只具有k条性质的某个对象x</code>，则意味着<code>对象x 不具有 第k+1条性质</code>，那么A_{k+1} &#x3D; \varnothing，则A_{k+1}与<code>任何其他集合的交集，最终都为空集</code>。</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p><code>等式左侧</code>表示的是<code>不具有任何性质的对象的个数</code>，我们证明的思路是：</p>
<ol>
<li>证明<code>不具有</code>P_1, P_2, \cdots, P_m<code>中任何性质的对象</code>对于这个<code>等式的右边</code>的<code>净贡献 = 1</code></li>
<li>证明<code>至少具有</code>P_1, P_2, \cdots, P_m<code>中任何性质的对象</code>对于这个<code>等式的右边</code>的<code>净贡献 = 0</code></li>
</ol>
<hr>
<p>假设<code>对象x</code> <code>不具有任何一条性质</code>，则它对等式右边的净贡献对等式右边的净贡献 &#x3D; 1。</p>
<blockquote>
<p>因为x \in S，所以等式右边的S &#x3D; 1</p>
<p>而因为x \notin A_i，所以等式右边的其他项均 &#x3D; 0</p>
</blockquote>
<hr>
<p>假设<code>对象y</code> <code>恰好具有n ≥ 1条性质</code>，则它对的净贡献对S的净贡献 &#x3D; 1</p>
<p><code>对象y</code>对\sum A_i的<code>净贡献 =</code>\binom{n}{1} &#x3D; n</p>
<blockquote>
<p>因为<code>对象y</code> <code>恰好具有n条性质</code>，因此它是A_1, A_2, \cdots, A_m中<code>恰好n个集合的成员</code>。</p>
</blockquote>
<p><code>对象y</code>对\sum A_i \cap A_j的<code>净贡献 =</code>\binom{n}{2}</p>
<blockquote>
<p>因为我们可以从<code>包含对象y的n个集合</code>中<code>任意地选取对象y所含的2条性质</code></p>
</blockquote>
<p><code>对象y</code>对\sumA_i \cap A_j \cap A_k的<code>净贡献 =</code>\binom{n}{3}</p>
<blockquote>
<p>因为我们可以从<code>包含对象y的n个集合</code>中<code>任意地选取对象y所含的3条性质</code></p>
</blockquote>
<p>依此进行，可以得出<code>y对等式右边的净贡献</code> &#x3D; \binom{n}{0} - \binom{n}{1} + \binom{n}{2} - \binom{n}{3} + \cdots + (-1)^m \binom{n}{m} &#x3D; 0</p>
<blockquote>
<p>注：因为<code>n元素集合的包含奇数个元素的子集 的数量</code>=<code>n元素集合的包含偶数个元素的子集 的数量</code>，故该等式为0</p>
<p>注：实际上<code>有效的项</code>仅到(-1)^n \binom{n}{n}，因为当m &gt; n, \binom{n}{m} &#x3D; 0，这些项都可以被去除。</p>
</blockquote>
<hr>
<p>Q.E.D</p>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h4><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p><code>集合S</code>中<code>至少具有性质</code>P_1, P_2,\cdots,P_m<code>之一的对象的个数</code>，可以由下面的式子得出：</p>
<h3 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h3><h4 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h4><p>如果<code>容斥原理</code>中A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k}<code>仅依赖于k</code>而<code>不依赖于交集中到底使用了哪k个集合</code>，则<code>所有的k子集的大小均相同</code>：</p>
<blockquote>
<p>也就是说，<code>包含任意k条性质的集合</code>的<code>大小均相同</code></p>
</blockquote>
<p>则得到<code>简化版容斥原理</code>：</p>
<blockquote>
<p>即：在<code>容斥原理</code>中<code>出现的第k个求和</code>包含\binom{m}{k}个<code>被加数</code>，而<code>每个被加数</code>均等于\alpha_k</p>
</blockquote>
<blockquote>
<p>当k &gt; m时，\binom{m}{k} &#x3D; 0</p>
</blockquote>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1"><a href="#Application-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-2"><a href="#Content-2" class="headerlink" title="Content"></a>Content</h5><p>求<code>从1到1000之间</code> <code>不能被5，6,8整除的整数的个数</code></p>
<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>通过<code>观察</code>给出<code>能被n整除的解释</code>：<code>从1开始的每连续的第n个整数</code>可以<code>被n整除</code>。则</p>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5整除的整数个数</code>：\lfloor\frac{1000}{5}\rfloor &#x3D; 200</p>
<p><code>从1到1000之间能被6整除的整数个数</code>：\lfloor\frac{1000}{6}\rfloor &#x3D; 166</p>
<p><code>从1到1000之间能被8整除的整数个数</code>：\lfloor\frac{1000}{8}\rfloor &#x3D; 125</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5和6整除的整数个数</code>：\lfloor\frac{1000}{30}\rfloor &#x3D; 33</p>
<p><code>从1到1000之间能被5和8整除的整数个数</code>：\lfloor\frac{1000}{40}\rfloor &#x3D; 25</p>
<p><code>从1到1000之间能被6和8整除的整数个数</code>：\lfloor\frac{1000}{24}\rfloor &#x3D; 41</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p><code>从1到1000之间能被5和6和8整除的整数个数</code>：\lfloor\frac{1000}{120}\rfloor &#x3D; 8</p>
<blockquote>
<p>注意：求能被某些数整除，应该求的是<code>最小公倍数</code>，而该值不一定是<code>直接将这些数相乘起来</code>。</p>
<p>如lcm\{5,6,8\}&#x3D;120 \ne 5*6*8 &#x3D; 240</p>
</blockquote>
<p>综上，运用<code>容斥原理</code>得：answer &#x3D; 1000 - (200+166+125) + (33 + 25 + 41) - (8) &#x3D; 600</p>
<h4 id="Application-2"><a href="#Application-2" class="headerlink" title="Application 2"></a>Application 2</h4><h5 id="Content-3"><a href="#Content-3" class="headerlink" title="Content"></a>Content</h5><p><code>字母集&#123;M, A, T, H, I, S, F, U, N&#125;</code>的<code>排列中</code>，有多少排列使得<code>MATH</code>，<code>IS</code>，<code>FUN</code>不作为<code>连续字符</code>出现在排列中？</p>
<h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h5><p>在运用<code>容斥原理</code>时，首先考虑如何定义P_i。</p>
<p>由于题干需要求出<code>使得MATH，IS，FUN不作为连续字符出现在排列中的个数</code></p>
<p>因此可以考虑<code>分别设这3个单词作为连续字符出现为性质</code>再<code>从全集S中去除满足这3个性质中任何性质的哪些元素</code></p>
<p>故，不妨设</p>
<p>P_{math}为<code>排列中math作为连续字符出现的排列</code></p>
<p>P_{is}为<code>排列中is作为连续字符出现的排列</code></p>
<p>P_{fun}为<code>排列中fun作为连续字符出现的排列</code></p>
<p>同时，设A_i为<code>集合S中满足性质i的集合</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的所有子集</code></li>
</ul>
<p>S &#x3D; 9!</p>
<blockquote>
<p>也就是说，我们可以将<code>全集S</code>特别地看作<code>具有0条性质的所有子集</code>。</p>
<p>这么做的原因是为了表达式的规整统一。</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p>A_{math} &#x3D; (9 - 4 + 1)! &#x3D; 6!</p>
<p>A_{is} &#x3D; (9 - 2 + 1)! &#x3D; 8!</p>
<p>A_{fun} &#x3D; (9-3+1)! &#x3D; 7!</p>
<blockquote>
<p>因为这些<code>单词中的字母</code>需要<code>按一定顺序连续出现</code>，所以可以将他们视为一个<code>整体</code>来看待。</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p>A_{math} \cap A_{is} &#x3D; (9 - 4 + 1 - 2 + 1)! &#x3D; 5!</p>
<p>A_{math} \cap A_{fun} &#x3D; (9 - 4 + 1 - 3 + 1)! &#x3D; 4!</p>
<p>A_{is} \cap A_{fun} &#x3D; (9 - 2 + 1 - 3 + 1)! &#x3D; 6!</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p>A_{math} \cap A_{is} \cap A_{fun} &#x3D; (9 - 4 + 1 - 2 + 1 - 3 + 1)! &#x3D; 3!</p>
<hr>
<p>综上，运用<code>容斥原理</code>得：answer &#x3D; (9!) - (6! + 8! + 7!) + (5! + 4! + 6!) - (3!) &#x3D; 317658</p>
<h4 id="Application-3"><a href="#Application-3" class="headerlink" title="Application 3"></a>Application 3</h4><h5 id="Content-4"><a href="#Content-4" class="headerlink" title="Content"></a>Content</h5><p>在<code>0到99999之间</code>有多少<code>含有数字2,5和8的整数</code>？</p>
<h5 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h5><p>不妨设：</p>
<p>P_{1}为<code>不含数字2的整数的性质</code></p>
<p>P_{2}为<code>不含数字5的整数的性质</code></p>
<p>P_{3}为<code>不含数字8的整数的性质</code></p>
<p>且设A_i为<code>具有性质i的所有元素的集合</code></p>
<p>我们可以构造<code>多重集合</code>\{5 \cdot 0, 5 \cdot 1, 5 \cdot 2, \cdots, 5 \cdot 9 \}</p>
<p>按这种表示方法，则得出</p>
<blockquote>
<p>也就是说，这里运用了<code>简化版的容斥原理：</code>所有的包含k条性质的集合<code>的</code>大小都相同`</p>
<p>\alpha_0表示：<code>不包含任何性质</code>，也就是本题中<code>不限制对数字的使用</code>。则大小为<code>0~99999之间有多少个数字 = 10^5 = 100000</code></p>
<p>\alpha_1表示：<code>具有性质</code>P_1，也就是<code>不含数字2的整数的性质</code>。等价地，我们要从<code>多重集合</code>里<code>去除掉</code>5 \cdot 2<code>这个多重元素</code>。所以<code>合法整数的数量 = 9^5</code></p>
</blockquote>
<p>综上，</p>
<h4 id="Application-4"><a href="#Application-4" class="headerlink" title="Application 4"></a>Application 4</h4><h5 id="Content-5"><a href="#Content-5" class="headerlink" title="Content"></a>Content</h5><p>确定<code>多重集合</code>T &#x3D; \{3 \cdot a, 4 \cdot b, 5 \cdot c\}的<code>10组合的数目</code></p>
<h5 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h5><p>设<code>多重集合</code>T^* &#x3D; \{\infty \cdot a, \infty \cdot b, \infty \cdot c\}的所有10组合的<code>集合S</code>。</p>
<p>设P_1是T^*<code>的10组合中a出现多于3次的性质</code></p>
<p>设P_2是T^*<code>的10组合中b出现多于4次的性质</code></p>
<p>设P_3是T^*<code>的10组合中c出现多于5次的性质</code></p>
<p>且设A_i是T^*<code>的10组合中不具有性质i的哪些10组合的集合</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的所有子集</code></li>
</ul>
<p>S &#x3D; \binom{10 + 3 - 1}{10} &#x3D; 66</p>
<blockquote>
<p>根据<code>每个元素的重数为无限的多重集合</code>的<code>r组合公式</code>：\binom{r+k-1}{r}</p>
</blockquote>
<ul>
<li>求<code>所有的集合S中具有1条性质的所有子集</code></li>
</ul>
<p>A_1 &#x3D; \binom{(10-4) + 3 - 1}{6} &#x3D; 28</p>
<blockquote>
<p>由于P_1是的组合中出现多于次的性质T^*的10组合中a出现多于3次的性质，故A_1是的组合中至少出现次T^*的10组合中a至少出现4次。</p>
<p>所以，等价地，我们可以从T_*中<code>取走4个a</code>。这样即可将问题转化为求取走个后的的组合求取走4个a后的T^*的6组合 （也就是说，相当于这4个a先<code>固定地取走了</code>）</p>
</blockquote>
<blockquote>
<p>这类似于<code>处理仅有2个集合的情况</code>，但我们用<code>容斥原理</code>将这个问题拓展到了<code>3个集合的情况</code></p>
</blockquote>
<p>A_2 &#x3D; \binom{(10-5) + 3 - 1}{5} &#x3D; 21</p>
<p>A_3 &#x3D; \binom{(10-6)+3-1}{4} &#x3D; 15</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的所有子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; \binom{(10- 4 - 5) + 3 - 1}{1} &#x3D; 3</p>
<p>A_1 \cap A_3 &#x3D; \binom{(10-4-6)+3-1}{0} &#x3D; 1</p>
<p>A_2 \cap A_3 &#x3D; \binom{(10-5-6)+3-1}{1} &#x3D; \binom{1}{-1} &#x3D; 0</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的所有子集</code></li>
</ul>
<p>A_1 \cap A_2 \cap A_3 &#x3D; \binom{(10-4-5-6)+3-1}{-5} &#x3D; \binom{-3}{-5}&#x3D; 0</p>
<hr>
<p>综上，answer &#x3D; (66) - (28+21+15) + (3+1+0) - (0) &#x3D; 6</p>
<h4 id="Application-5"><a href="#Application-5" class="headerlink" title="Application 5"></a>Application 5</h4><h5 id="Content-6"><a href="#Content-6" class="headerlink" title="Content"></a>Content</h5><p>求该方程的<code>非负整数解</code>个数？</p>
<h5 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h5><p>首先使用<code>变量替换</code>，以便将<code>变量的下界提升到0</code>。则</p>
<p>设<code>集合S</code>是<code>新方程的所有非负整数解的集合</code>，则</p>
<p>设</p>
<p>P_1是y_1 \ge 5<code>的性质</code></p>
<p>P_2是y_2 \ge 7<code>的性质</code></p>
<p>P_3是y_3 \ge 6<code>的性质</code></p>
<p>P_4是y_4 \ge 7<code>的性质</code></p>
<p>并设A_i是<code>集合S中满足性质</code>P_i<code>的解 组成的子集</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; 969</p>
<ul>
<li>求<code>所有的集合S中具有1条性质的子集</code></li>
</ul>
<p>假设欲求A_1：也就是y_1 \ge 5，那也就是等价地，我们<code>提前固定地从</code>y_1<code>中选取5个</code>。即</p>
<p>A_1 &#x3D; \binom{(16 - 5) + 4 - 1}{11} &#x3D; 364</p>
<blockquote>
<p>对于<code>要求至少选取集合中某个元素k个</code>的<code>约束条件</code>，我们可以<code>等价地转化为：事前提前取走这k个元素</code>，从而<code>规约为一个新的等价问题</code></p>
</blockquote>
<p>同理地，可求得：</p>
<p>A_2 &#x3D; \binom{(16 - 7) + 4 - 1}{9}</p>
<p>A_3 &#x3D; \binom{(16-6)+4-1}{10}</p>
<p>A_4 &#x3D; \binom{(16-7)+4-1}{9}</p>
<ul>
<li>求<code>所有的集合S中具有2条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; \binom{(16-5-7)+4-1}{4}</p>
<p>A_1 \cap A_3 &#x3D; \binom{(16-5-6)+4-1}{5}</p>
<p>A_1 \cap A_4 &#x3D; \binom{(16-5-7)+4-1}{4}</p>
<p>A_2 \cap A_3 &#x3D; \binom{(16-7-6)+4-1}{3}</p>
<p>A_2 \cap A_4 &#x3D; \binom{(16-7-7)+4-1}{2}</p>
<p>A_3 \cap A_4 &#x3D; \binom{(16-6-7)+4-1}{3}</p>
<ul>
<li>求<code>所有的集合S中具有3条性质的子集</code></li>
</ul>
<p>这些<code>子集</code>均为空集</p>
<ul>
<li>求<code>所有的集合S中具有4条性质的子集</code></li>
</ul>
<p>这些<code>子集</code>均为空集</p>
<hr>
<p>综上，运用<code>容斥原理</code>得出answer &#x3D; 55</p>
<h2 id="Derangement-Formula"><a href="#Derangement-Formula" class="headerlink" title="Derangement Formula"></a>Derangement Formula</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>若<code>集合</code>S &#x3D; \{1, 2, \cdots, n\}，其中<code>每个整数的位置</code>由<code>一个排列</code>i_1i_2\cdots i_n <code>$$所确定</code>。</p>
<p>则<code>集合S</code>的<code>一个错位排列</code>是这样的<code>一个排列</code>，满足：i_1 \ne 1, i_2 \ne 2, \cdots, i_n \ne n</p>
<blockquote>
<p>换句话说，<code>错位排列</code>中<code>没有任何一个整数</code>位于<code>自然位置</code></p>
</blockquote>
<hr>
<h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>设<code>集合S</code>为<code>n个整数的所有排列方案组成的集合</code>：S &#x3D; n!</p>
<p>设P_i为<code>整数i位于自然位置的性质</code></p>
<p>设A_i为<code>集合S中的具有性质</code>P_i<code>的子集</code></p>
<p>我们需要求出<code>这样的一些排列</code>：<code>没有任何整数位于自然位置</code></p>
<hr>
<ul>
<li>求<code>所有的集合S中的具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; n!</p>
<ul>
<li>求<code>所有的集合S中的具有1条性质的子集</code></li>
</ul>
<p>A_1 &#x3D; (n-1)!</p>
<p>A_2 &#x3D; (n-1)!</p>
<p>\vdots</p>
<p>A_n &#x3D; (n-1)!</p>
<ul>
<li>求<code>所有的集合S中的具有2条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 &#x3D; (n-2)!</p>
<p>\vdots</p>
<p>A_{n-1} \cap A_n &#x3D; (n-2)!</p>
<p>……</p>
<ul>
<li>求<code>所有的集合S中的具有n条性质的子集</code></li>
</ul>
<p>A_1 \cap A_2 \cap \cdots \cap A_n &#x3D; 1</p>
<hr>
<p>根据<code>容斥原理</code>得出：</p>
<p>Q.E.D</p>
<h3 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-Approximation"><a href="#Theory-Approximation" class="headerlink" title="Theory: Approximation"></a>Theory: Approximation</h4><p>我们有e^{-1} &#x3D; 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \frac{1}{4!} - \dots</p>
<p>则e^{-1} &#x3D; \frac{D_n}{n!} \textcolor{red}{ + (-1)^{n+1}\frac{1}{(n+1)!} + (-1)^{n+2}\frac{1}{(n+2)!} + \dots}</p>
<p>所以，我们得出结论：e^{-1} - \frac{D_n}{n!} \le \frac{1}{(n+1)!}</p>
<blockquote>
<p>这个近似提供了一个非常简单的求D_n的方法：D_n &#x3D; \frac{n!}{e} &#x3D; \frac{n!}{2.7182818284\dots}</p>
</blockquote>
<h4 id="Theory-Recurrence-Formula"><a href="#Theory-Recurrence-Formula" class="headerlink" title="Theory: Recurrence Formula"></a>Theory: Recurrence Formula</h4><p>D_n &#x3D; (n-1)(D_{n-2} + D_{n-1}) \quad (n &#x3D; 3, 4,5,\dots)</p>
<hr>
<p>考虑\{1,2,\dots,n\}的D_n个错位排列。</p>
<p>可以按照<code>将2,3,...,n中的哪一个数字放置到第一位</code>而将D_n个错位排列<code>划分</code>为<code>n-1 个部分</code></p>
<blockquote>
<p>显然，这<code>n-1个部分</code>都包含<code>相同的错位排列个数</code></p>
</blockquote>
<p>这样，D_n &#x3D; (n-1)d_n，其中d_n是<code>数字2位于排列第一个位置上的错位排列的数目</code></p>
<p>在这d_n个错位排列中，可继续按照<code>数字1是否位于第二个位置</code>来<code>划分为2个部分</code>：</p>
<p>设d_n^\prime表示<code>数字1位于第二个位置的错位排列个数</code></p>
<p>设d_n^{\prime\prime}表示<code>数字1不位于第二个位置的错位排列个数</code></p>
<p>故d_n &#x3D; d_n^{\prime} + d_n^{\prime\prime}</p>
<blockquote>
<p>d_n是形式为2i_2i_3\dotsi_n,\quad i_2 \ne 2, i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
<p>d_n^\prime是形式为21i_3i_4\dotsi_n, \quad i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
<p>d_n^{\prime\prime}是形式为2i_2i_3\dotsi_n,\quad i_2 \ne 1, i_3 \ne 3,\dots, i_n \ne n的错位排列的数量</p>
</blockquote>
<p>所以 D_n &#x3D; (n-1)d_n &#x3D; (n-1)(d_n^{\prime} + d_n^{\prime\prime})</p>
<p>我们<code>观察</code>到，d_n^{\prime} &#x3D; D_{n-2}和d_n^{\prime\prime} &#x3D; D_{n-1}</p>
<blockquote>
<p>实际上，我们<code>并不关心</code> <code>数字是多少</code>和<code>位置是多少</code>。</p>
<p>我们<code>关心的仅仅是</code> <code>数字和位置所构成的二元组 的个数</code>。</p>
<p>换句话说，我们可以设<code>（数字num，位置pos）二元组</code> <code>表示当数字num不位于位置pos时，【视为】满足【错位排序】</code></p>
<p>正常情况下，我们称<code>错位排序</code>需要满足<code>形式如这样的二元组约束条件</code>：<code>(1,1)</code>，<code>(2,2)</code>，…，<code>(n,n)</code> 。</p>
<p>这样的<code>n个整数的错位排列的数量 =</code>D_n</p>
<p>但是，我们如果将<code>数字num</code>和<code>位置pos</code>进行重新映射，比如说<code>映射为如下的约束条件: (1,2), (2,1), (3,3), (4,4), ..., (n,n)</code></p>
<p>或者说，<code>映射为如下的约束条件：(1, 2), (2, 3), (3, 4), ..., (n - 1, n), (n, 1)</code>。</p>
<p>那么上述的<code>两个对约束条件的重新映射</code>，<code>并不会改变错位排列的数量</code>，<code>错位排列的数量仍然是</code>D_n</p>
<hr>
<p>总而言之，<code>错位排序问题的规模</code>并不是<code>数字是什么</code>或者<code>位置是什么</code>。而是<code>(数字，位置)的二元组约束条件的数量</code></p>
</blockquote>
<blockquote>
<p>d_n^\prime实际上<code>等价于</code>的排列中，共个约束条件\{3,4,…,n\}的排列i_3i_4\dotsi_n中，\textcolor{blue}{i_3 \ne 3, i_4 \ne 4,\dots, i_n \ne n \quad(共n-2个约束条件)}的排列个数，<code>等价地，我们的问题规模就从</code>D_n减少到了D_{n-2}</p>
<p>d_n^{\prime\prime}实际上<code>等价于</code>的排列中，共个约束条件\{1, 3,4,\dots,n\}的排列i_1i_3i_4\dots i_n中，\textcolor{blue}{i_1\ne 1, i_3 \ne 2, i_4 \ne 3, \dots, i_n \ne n-1 \quad (共n-1个约束条件)}，<code>等价地，我们的问题规模就从</code>D_n减少到了D_{n-1}</p>
</blockquote>
<p>综上，D_n &#x3D; (n-1)(D_{n-1} + D_{n-2})</p>
<p>Q.E.D</p>
<h4 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory"></a>Theory</h4><p>通过不断对Dn &#x3D; (n-1)(D_{n-1}+D_{n-2})运用<code>递推公式</code>，可以<code>降解得到</code></p>
<p>D_n &#x3D; nD_{n-1} + (-1)^n, \quad(n &#x3D; 2,3,4,…)</p>
<h2 id="Arrangement-Problems-with-Prohibited-Positions"><a href="#Arrangement-Problems-with-Prohibited-Positions" class="headerlink" title="Arrangement Problems with Prohibited Positions"></a>Arrangement Problems with Prohibited Positions</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>我们设P(X_1, X_2, \cdots, X_n)表示\{1,2,\cdots,n\}的<code>所有排列</code>i_1i_2\dots i_n的集合，使得i_1 \notin X_1, i_2 \notin X_2, \cdots, i_n \notin X_n</p>
<blockquote>
<p><code>错位排列</code>是一种<code>特化的带禁止位置的排列</code>：X_1&#x3D;\{1\}, X_2&#x3D;\{2\}, \cdots, X_n\{n\} \implies P(X_1, X_2, \cdots, X_n) &#x3D; D_n</p>
</blockquote>
<blockquote>
<p><code>带禁止方格的非攻击型车棋盘问题</code>是一种<code>特化的带禁止位置的排列</code>：<code>按逐行顺序放置车</code>，则<code>放置方案</code>即为一个<code>排列</code>i_1i_2\cdots i_n</p>
</blockquote>
<h3 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1-Non-Attack-Rook-Problem-with-Prohibited-Positions"><a href="#Application-1-Non-Attack-Rook-Problem-with-Prohibited-Positions" class="headerlink" title="Application 1: Non-Attack Rook Problem with Prohibited Positions"></a>Application 1: Non-Attack Rook Problem with Prohibited Positions</h4><h5 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h5><p>将<code>n个攻击型不可区分的车</code>放到<code>带有禁止位置的n行n列棋盘</code>上的<code>放置方法数</code>等于</p>
<h5 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h5><p>设<code>集合S</code>表示<code>n个非攻击型车在n行n列的棋盘上的所有n!种放置方案的集合</code>。</p>
<p>设P_j表示在行列的车，的性质在j行i列的车， i \in X_j \ 的性质</p>
<blockquote>
<p>也就是说，<code>逐行放置非攻击型车，且必须放置在当前行的禁止位置上的性质</code></p>
</blockquote>
<p>设A_i表示<code>满足</code>P_j \quad(j &#x3D; 1,2,\cdots,n)<code>的车的放置方案的集合</code></p>
<p>设P(X_1, X_2, \cdots, X_n)是<code>n个非攻击型车的所有放置方案</code>中<code>不满足性质</code>P_1, P_2, \cdots, P_n<code>的放置方案所组成的集合</code></p>
<hr>
<p>则P(X_1, X_2, \cdots, X_n) &#x3D; \overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n}</p>
<p>则A_i &#x3D; X_i (n-1)!,\quad(i &#x3D; 1,2,\cdots, n)</p>
<p>则\sum{A_i} &#x3D; (X_1 + X_2 + \cdots + X_n)(n-1)!</p>
<p>设r_k等于<code>把k个非攻击型车放到棋盘上的禁止位置的方法数</code></p>
<p>则对于<code>所有的集合S中的具有k条性质的子集</code>有\textcolor{blue}{\sumA_{i_1}\cap A_{i_2} \cap \cdots \cap A_{i_k} &#x3D; r_k(n-k)!,\quad(k&#x3D;1,2,\cdots,n)}</p>
<p>\sum{A_i} &#x3D; r_1(n-1)!</p>
<p>\sum{A_i \cap A_j} &#x3D; r_2(n-2)!</p>
<p>\sum{A_i \cap A_j \cap A_k} &#x3D; r_3(n-3)!</p>
<p>运用<code>容斥原理</code>，得出结论。</p>
<p>Q.E.D</p>
<h5 id="Content-7"><a href="#Content-7" class="headerlink" title="Content"></a>Content</h5><p>求<code>将2个非攻击型车放置到下列的6×6的带禁止位置的棋盘上的方案数</code></p>
<p><img src="https://s2.loli.net/2022/04/03/78Bds6FNvDUTYbq.png" alt="image-20220330173743577"></p>
<h5 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h5><p>r_1 &#x3D;7</p>
<blockquote>
<p>因为<code>在该棋盘上放置1个非攻击型车的方案数有7种</code></p>
</blockquote>
<p>r_2 &#x3D; (1) + (2) + (3 × 4) &#x3D; 15</p>
<blockquote>
<p>2个非攻击型车都放在左上角区域有1种方案。</p>
<p>2个非攻击型车都放在右下角区域有2种方案。</p>
<p>2个非攻击型车分别位于两个区域有3×4&#x3D;12种方案。</p>
</blockquote>
<blockquote>
<p>这里可以直接使用<code>乘法</code>来计算方案数，是因为<code>这两个红色区域</code>是<code>独立的</code>：</p>
<p>也就是说，<code>两个区域是独立的，则无论如何放置车</code>，<code>一个区域内的车</code>不会攻击到<code>另一个区域内的车</code>！</p>
</blockquote>
<p>r_3 &#x3D; (1 \times 4) + (3 \times 2) &#x3D; 10</p>
<p>r_4 &#x3D; (1 \times 2) &#x3D; 2</p>
<hr>
<p>综上，answer &#x3D; (6!) - 7\times(5)! + 15\times(4)! - 10\times(3)! + 2\times(2)! &#x3D; 184</p>
<h4 id="Application-2-Boys-Queuing-Problem"><a href="#Application-2-Boys-Queuing-Problem" class="headerlink" title="Application 2: Boys Queuing Problem"></a>Application 2: Boys Queuing Problem</h4><h5 id="Content-8"><a href="#Content-8" class="headerlink" title="Content"></a>Content</h5><p>若有<code>5个男孩</code>每天练习走步。这些男孩站成<code>一队纵列</code>前行，<code>除了第一个男孩外的每个男孩的前面都有另一个男孩</code>。</p>
<p>为了让<code>每个男孩不总是看到他前面的同一个人</code>，<code>第二天</code>，<code>他们决定交换位置</code>，<code>使得没有男孩的前面的男孩与他第一天在他前面的男孩是同一个人</code></p>
<h5 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h5><p>设Q_n表示\{1,2,\cdots,8\}的排列中，<code>不出现模式12,23,34，..., (n-1)n 的那些排列的个数</code></p>
<p>对于n \ge 1</p>
<blockquote>
<p>Q_n &#x3D; D_n + D_{n-1}, \quad (n \ge 2)</p>
</blockquote>
<h5 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h5><p>设S是\{1,2,\cdots,n\}的全部n!个排列所组成的集合</p>
<p>设P_j是<code>在一个排列中模式j(j+1)出现的性质 (j = 1, 2, ..., n-1)</code></p>
<p>设A_j是\{1,2,\cdots,n\}的满足P_j的排列所组成的集合。</p>
<blockquote>
<p>注：由于P_j共n-1个，故A_j的数量也为n-1个</p>
</blockquote>
<hr>
<ul>
<li>求<code>所有的集合S中的具有0条性质的子集</code></li>
</ul>
<p>S &#x3D; 5!</p>
<ul>
<li>求<code>所有的集合S中的具有1条性质的子集</code></li>
</ul>
<p>A_j &#x3D; (n-1)!, \quad(j &#x3D; 1,2,\cdots,n-1)</p>
<ul>
<li>求<code>所有的集合S中的具有2条性质的子集</code></li>
</ul>
<p>考虑A_i \cap A_j</p>
<p>那么需要考虑A_i和A_j的<code>模式</code>之间是否存在<code>共享元素</code></p>
<p>不存在：如<code>12</code>和<code>34</code>，则可视为<code>n-2个符号的集合&#123;12, 34, 5, 6, ..., n&#125;的一个排列</code></p>
<blockquote>
<p>元素个数差 &#x3D; -4 + 2 &#x3D; -2</p>
</blockquote>
<ol>
<li><p>存在：如<code>12</code>和<code>23</code>，则可视为<code>个符号的集合&#123;12, 23, 4, 5, 6, ..., n&#125;的一个排列</code></p>
<blockquote>
<p>元素个数差 &#x3D; -3 + 1 &#x3D; -2</p>
</blockquote>
</li>
</ol>
<p>也就是说，无论是<code>不同模式</code>之间<code>是否存在共享的元素</code>，都不会影响<code>参与排列的符号的个数</code></p>
<p>即A_i \cap A_j &#x3D; (n-2)!</p>
<ul>
<li>求<code>所有的集合S中的具有k条性质的子集</code></li>
</ul>
<p>A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_{k}} &#x3D; (n-k)! \qquad(k &#x3D; 1,2,\cdots,n-1)</p>
<hr>
<p>综上，根据<code>容斥原理</code>：answer &#x3D; 5! - \binom{4}{1}A_{i_1} + \binom{4}{2}A_{i_1} \cap A_{i_2} - \binom{4}{3}A_{i_1} \cap A_{i_2} \cap A_{i_3} \cap A_{i_4} + \binom{4}{4} A_{i_1} \cap A_{i_2} \cap A_{i_3} \cap A_{i_4}</p>
<h2 id="Mobius-Inversion"><a href="#Mobius-Inversion" class="headerlink" title="Mobius Inversion"></a>Mobius Inversion</h2><h3 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h3><p>设<code>n为正整数</code>，考虑<code>n元素集合</code>X_n &#x3D; \{1,2,\cdots,n\}，以及<code>由包含关系所定义的</code>X_n<code>的所有子集的集合上的偏序集</code>(\mathcal{P}, \subseteq)</p>
<p>设<code>函数</code>F:\mathcal{P}(X_n) \rightarrow \real 是<code>定义在</code>\mathcal{P}(X_n)<code>上的实值函数</code></p>
<p>设<code>函数</code>G: \mathcal{P}(X_n) \rightarrow \real，使得\textcolor{blue}{G(K) &#x3D; \sum_{L \subseteq K}{F(L)},\quad(K \subseteq X_n)}</p>
<p>则，<code>莫比乌斯反解</code>可从<code>函数G</code>恢复<code>函数F</code></p>
<blockquote>
<p>也就是说，给定G(K)可以得出F(K)</p>
</blockquote>
<p>我们有\textcolor{blue}{F(K) &#x3D; \sum_{L\subseteq K}{\textcolor{green}{(-1)^{K-L}}G(L)}, \quad (K \subseteq X_n)}</p>
<p>设<code>有限集S的子集</code>为 A_1, A_2,\cdots,A_n</p>
<p>对于<code>集合</code>K \subseteq \{1,2,\cdots,n\}，<code>定义</code>F(K)为<code>集合S中正好</code> <code>属于所有满足</code>i \notin K<code>的集合</code>A_i<code>的元素个数</code></p>
<blockquote>
<p>也就是说，对于<code>给定的F(K)中的K</code>：</p>
<p><code>对于</code>s \in S, F(K)<code>计数s</code> <code>当且仅当</code> s \notin A_i, \forall i \in K和s \in A_j, \forall j \notin K</p>
<hr>
<p>用<code>容斥原理</code>的角度看，<code>集合K</code>相当于是<code>1个给定的一些性质的集合</code>（只不过我们对<code>性质</code>做了<code>编号</code>，而<code>所有性质的编号组成了 集合</code>X_n）,</p>
<p>而<code>集合A</code>相当于<code>集合S中的 具有指定某个性质的所有元素 所组成的集合</code></p>
<hr>
<p>再换句话说，如果我们<code>给定了 1个包含了特定的某些性质的集合K</code>，并<code>将这个 集合K 作为参数 传递给函数F</code>，即<code>F(K)</code>，</p>
<p>则<code>函数F 的作用类似于</code> <code>过滤器</code>和<code>计数器</code>：<code>函数F(K)</code>会<code>循环检查 集合S的每一个元素</code>（假如我们设<code>循环变量</code>为<code>s</code>），并<code>对该元素（即临时的循环变量s）循环检查K中的每一条性质</code> ：如果<code>这个元素不具有K中的任何一条性质</code>或者<code>这个元素具有K中没有的性质</code>。那么我们<code>计数该元素</code></p>
<hr>
<p>实际上，(-1)^{K -L}就是<code>偏序集</code>(\mathcal{P}(X_n), \le)<code>的莫比乌斯函数</code></p>
<hr>
<p>从<code>编程</code>的角度看，如果实现一个<code>容斥原理</code>解法：<code>F(tempPropertySet)和G(tempPropertySet)</code>是<code>2个存在递归的函数</code>（<code>函数F</code>通过调用<code>函数G</code>来再次调用<code>函数F</code>自身，但<code>每次对函数F的调用 所传入的参数并不同，也就是 所传入的特定的某些性质的集合 不同</code>）我们可以从F(K)开始运行，<code>刚开始（也就是第一次）传递给G(tempPropertySet)的参数是 所有的给定的某些性质</code>，<code>但G(K)并没有立即开始计算，而是继续递归下降直到 递归的基本情况</code>（注意我们的<code>约束条件</code>：K \subseteq X_n），我们可以<code>编程</code>使得<code>G(tempPropertySet)在 所输入的参数为空集后，不再继续调用F(tempPropertySet)进行递归</code>（如果<code>如果输入参数为空集</code>，<code>意味着 给定的一些性质的集合大小为0，也就是 没有给定任何性质，即具有0条性质</code>，而这也就是<code>容斥原理里右式的第一项：S</code>）。</p>
<p>从<code>整个程序的实际计数顺序（递归下降过程仅保留帧栈，但不进行实际的计数）来看</code>，它与我们在<code>计算容斥原理时从左到右 计算的顺序一样：先计算具有0条性质的情形，再计算具有1条性质的情形...</code></p>
<p>TODO</p>
</blockquote>
<p>故\textcolor{blue}{G(K) &#x3D; \sum_{L \subseteq K}{F(L)}} \textcolor{red}{&#x3D; \bigcap_{i \notin K}A_i }</p>
<p>计数<code>S中属于 j不在K中的所有</code>A_j<code>的元素</code> 以及 <code>属于其他一些集合的元素</code> <code>的个数</code>。</p>
<blockquote>
<p><code>G(K)</code>等价于<code>对所有的 具有我们K中没有指定的其他性质中的某条性质的元素所组成集合 进行交集运算</code></p>
</blockquote>
<p>则F(K) &#x3D; \sum_{L \subseteq K}{(-1)^{K - L}G(L)}</p>
<p>取<code>集合K</code>为<code>集合</code>X_n，得\textcolor{red}{F(X_n)}&#x3D;\sum_{L \subseteq \textcolor{blue}{X_n}}{(-1)^{\textcolor{blue}{n}-L}G(L)} &#x3D; \textcolor{red}{\overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n}}，则此F(X_n)<code>计数的是</code> <code>S中 仅属于满足</code>i \notin X_n<code>的那些集合</code>A_i<code>的元素</code>。</p>
<blockquote>
<p>这也就是说，F(X_n)是<code>集合S中 不属于集合</code>A_1,A_2,\cdots,A_n<code>中任何一个集合的元素 的个数</code>。</p>
<hr>
<p>也就是说，我们将<code>所有性质的集合</code>X_n传参给F(tempPropertySet)，我们<code>计数</code> <code>不含</code>X_n<code>中的性质的对象个数</code></p>
</blockquote>
<p>因此，我们得到</p>
<p>F(X_n) &#x3D; \overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n} &#x3D; \sum_{L \subseteq X_n}{(-1)^{n - L} \textcolor{blue}{\Big\bigcap_{i\notin L}A_i\Big}}</p>
<blockquote>
<p>等价地，使用<code>L在</code>X_n<code>中的补集J</code>代替<code>L</code>得到</p>
<p>\overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n} &#x3D; \sum_{\textcolor{blue}{J} \subseteq X_n}{(-1)^{\textcolor{blue}{J}} \Big \bigcap_{i \textcolor{blue}{\in J}}{A_i} \Big }</p>
<p>根据该式子，<code>容斥原理</code>是<code>莫比乌斯反演</code>在<code>有限偏序集</code>上的一个实例。</p>
</blockquote>
<hr>
<p>我们在上面的基础上，使用<code>任意的有限偏序集</code>(X, \le) 代替<code>偏序集</code> (\mathcal{P}(X_n), \subseteq)</p>
<blockquote>
<p>对于<code>有限偏序集</code>，可以用<code>更弱的性质</code>来代替<code>有限的性质</code>，即<code>局部有限</code>：对于<code>所有</code>a \le b<code>的a和b</code>而言<code>区间</code>\{x: a \le x \le b\}是<code>局部有限</code></p>
</blockquote>
<p>首先考虑<code>二变量函数</code>：</p>
<p>设\mathcal{F}(X)是<code>满足只要</code>x \not{\le} y<code>就有</code>f(x,y) &#x3D; 0<code>的所有实值函数</code>f: X \times X\rightarrow \real<code>的集合</code></p>
<p>于是，f(x,y)<code>只在</code>x \le y<code>时有可能不等于0</code>，而一旦x \gt y<code>则必定等于0</code>。</p>
<p>我们<code>定义</code>\mathcal{F}(X)<code>中的两个函数f和g的卷积</code>h &#x3D; f * g如下</p>
<blockquote>
<p>也就是说，我们通过<code>关于z求积</code>f(x,z)g(z,y)<code>的和</code>，来计算x \le y<code>的h(x,y)</code></p>
</blockquote>
<hr>
<p>我们考虑\textcolor{green}{\mathcal{F}(X)}<code>中的三种特殊的函数</code>：</p>
<ul>
<li>克罗内克Delta函数（Kronecker Delta Function） \delta(x, y) &#x3D;\begin{cases}1,&amp; x&#x3D; y \\ 0,&amp;else\end{cases}</li>
</ul>
<blockquote>
<p>注：对所有的<code>函数</code>f \in \mathcal{F}(X), \delta * f &#x3D; f * \delta &#x3D; f</p>
<p>因此，对于<code>卷积</code>来说，\delta就是一个<code>恒等函数</code></p>
</blockquote>
<blockquote>
<p><code>函数</code>δ其实就是一个<code>相等谓词</code>。</p>
</blockquote>
<ul>
<li>\zeta函数（Zeta Function） \zeta &#x3D; \begin{cases}1, &amp; x \le y\\0 ,&amp; else\end{cases}</li>
</ul>
<blockquote>
<p>\zeta<code>函数</code>是<code>偏序集</code>(X, \le )的一种<code>表示</code>，该函数<code>包含了所有满足</code>x \le y<code>的元素</code>对<code>x，y的全部信息</code></p>
</blockquote>
<blockquote>
<p><code>函数</code>\zeta其实就是一个<code>偏序谓词</code>。</p>
</blockquote>
<ul>
<li>莫比乌斯函数（Mobius Function）\mu</li>
</ul>
<p>设f \in \mathcal{F} 对<code>X中的所有y满足</code>f(y,y) \ne 0，则我们可以<code>递归地</code>定义\mathcal{F}(X)<code>中的函数g</code>：</p>
<p>设\textcolor{blue}{g(y,y) &#x3D; \frac{1}{f(y,y)} \qquad, (y \in X, f(y,y) \ne 0)}</p>
<p>然后<code>令</code></p>
<p>于是，我们可以得到</p>
<p>因此，g * f &#x3D; \delta</p>
<blockquote>
<p>即：g是<code>f关于卷积*的左逆函数</code></p>
</blockquote>
<p>我们得出结论：</p>
<p><code>每个对X中的所有y满足</code>f(y,y) \ne 0<code>的函数</code>f \in \mathcal{F}，都有<code>函数f的逆函数g</code>满足\textcolor{green}{g * f &#x3D; f * g &#x3D; \delta}</p>
<blockquote>
<p>证明方式如上，设出g(y,y)和g(x,y)</p>
</blockquote>
<hr>
<p><code>因为</code>\zeta(y,y) &#x3D; 1, \forall y \in X</p>
<p><code>故</code>\zeta存在<code>逆函数</code>\mu满足</p>
<blockquote>
<p>也就是说：<code>莫比乌斯函数</code>\mu是\zeta<code>函数</code>的<code>逆函数</code></p>
<p>同理可得：\textcolor{green}{\mu * \zeta &#x3D; \zeta * \mu &#x3D; \delta}</p>
</blockquote>
<p>所以，我们令\textcolor{blue}{f &#x3D; \zeta, g &#x3D; \mu}得到</p>
<blockquote>
<p>由于<code>函数</code>\zeta是一个<code>偏序谓词</code>，而显然z \le y \implies \zeta(z,y) &#x3D; 1，故可直接消去\zeta(z,y)</p>
</blockquote>
<blockquote>
<p>注意：上式中我们所做的<code>代换</code>f &#x3D; \zeta, g &#x3D; \mu需要指定<code>约束条件</code>x \le y，否则，<code>作为f函数的</code>\zeta<code>函数无法保证 非0</code></p>
</blockquote>
<p>上述式子表明2个事实：</p>
<ol>
<li><p>\textcolor{green}{\mu(x,x) &#x3D; 1, \forall x}</p>
<blockquote>
<p>这意味着<code>求和的上界和下界相等，故 求和值 =</code>\mu(x,x) &#x3D; \delta(x,x) &#x3D; 1</p>
</blockquote>
</li>
<li><p>\textcolor{green}{\mu(x,y) &#x3D; -\sum_{\{z: x \le z \lt y\}}{\mu(x,z)} \quad,(x \lt y)}</p>
<blockquote>
<p>TODO</p>
</blockquote>
</li>
</ol>
<h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p>设(X, \le)是<code>偏序集</code>且<code>有最小元 0</code>，设<code>它的莫比乌斯函数</code>为\mu</p>
<p>设<code>函数</code>F: X \rightarrow \real是<code>定义在X上的实值函数</code></p>
<p>设<code>函数</code>G: X \rightarrow \real定义为\textcolor{blue}{G(x) &#x3D; \sum_{\{z: z \le x\}}{F(z)}, \quad(x \in X)}</p>
<p>则\textcolor{blue}{F(x) &#x3D; \sum_{\{y: y \le x\}} {G(y)\textcolor{green}{\mu(y,x)}}, \quad (x \in X)}</p>
<h3 id="Proof-3"><a href="#Proof-3" class="headerlink" title="Proof"></a>Proof</h3><p>设\zeta为(X, \le) 的\zeta<code>函数</code>，对于x \in X，有</p>
<p>ζδ</p>
<blockquote>
<p>注意：对于上式而言，<code>元素x</code>并不是<code>变量</code>，而应当被视为<code>常量</code></p>
</blockquote>
<blockquote>
<p>\sum_{\{z: z \le y\}}{F(z)} &#x3D; \sum_{\{z: z \in X\}}{\zeta(z, y) F(z)}</p>
<p>对于<code>左式</code>：直接<code>求和z &lt;= y的范围</code></p>
<p>而对于<code>右式</code>：我们是通过引入\zeta函数（它是一个<code>偏序过滤器</code>），进而我们可以转变<code>求和范围</code>为<code>集合X中的任何元素z</code>。</p>
<p>这是因为，对于<code>对于不满足条件的元素</code>，会被\zeta函数所<code>过滤掉</code>（也就是说，这个<code>项</code>的值为<code>0</code>）</p>
<p>这类似于我们在前面<code>容斥原理中第k条性质之后的零项</code>的情况。</p>
</blockquote>
<blockquote>
<p>同理，\delta(z,x)作为<code>相等过滤器</code>，故</p>
<p>\sum_{\{z: z \in X\}}{\delta(z, x)F(z)} &#x3D; F(x)</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h4><p>计算<code>偏序集</code>(\mathcal{P}(X_n), \subseteq)<code>的莫比乌斯函数</code>，其中X_n &#x3D; \{1,2,\cdots,n\}</p>
<p>设A \subseteq B \subseteq X_n，然后，我们对B - A作<code>归纳法</code>，以<code>证明</code>\mu(A,B) &#x3D; (-1)^{B - A}</p>
<hr>
<p>如果A &#x3D; B</p>
<p>我们注意到\mu(x,x) &#x3D; 1, \forall x</p>
<p>则<code>证明完成</code></p>
<hr>
<p>如果A \ne B</p>
<p>设\textcolor{blue}{p &#x3D; B \backslash A &#x3D; B - A}</p>
<p>我们有</p>
<hr>
<p>对于<code>满足</code>0 \le k \le p-1<code>的每个整数k</code>，<code>满足</code>A \subseteq C \subset B<code>且</code>C - A &#x3D; k<code>的集合C</code> 的个数 等于 <code>包含在基数为p的集合</code>B \backslash A<code>中且基数为k的子集</code> 的个数</p>
<p>根据<code>二项式定理</code>有 \textcolor{blue}{0 &#x3D; (1-1)^p &#x3D; \sum_{k&#x3D;0}^{p}{(-1)^k \binom{p}{k}}}</p>
<p>因此\textcolor{blue}{\sum_{k&#x3D;0}^{p-1}{(-1)^k \binom{p}{k}} &#x3D; -(-1)^p \binom{p}{p} &#x3D; -(-1)^p\binom{p}{p}}</p>
<p>因而，我们可以得到</p>
<p>Q.E.D</p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h4><p>计算<code>线性有序集的莫比乌斯函数</code>。</p>
<hr>
<p>设X_n &#x3D; \{1,2,\cdots, n\}, 考虑<code>线性有序集</code>(X_n, \le) \quad, (1 \lt 2 \lt \cdots \lt n)</p>
<p>因为\mu(k,k) &#x3D; 1, \forall k \in \{1,2,\cdots,n\} 且 \textcolor{blue}{\mu(k,l) &#x3D; 0,\quad(1 \le l \lt k \le n)}</p>
<p>假设l &#x3D; k + 1, \quad (1 \le k \le n - 1)，则\sum_{\{j: k \le j \le k+1\}}{\mu(k,j)} &#x3D; 0</p>
<p>因此\mu(k,k) + \mu(k,k+1) &#x3D; 0</p>
<p>而这意味着\textcolor{blue}{\mu(k, k+1) &#x3D; -\mu(k, k) &#x3D; -1}</p>
<p>若假设1 \le k \le n-2，则\mu(k,k) + \mu(k,k+1) + \mu(k, k+2) &#x3D; 0</p>
<p>故\mu(k,k+2) &#x3D; -(\mu(k,k) + \mu(k, k+1)) &#x3D; -(1+(-1)) &#x3D; 0</p>
<p>继续如此，我们可以<code>归纳法</code>得出</p>
<p>Q.E.D</p>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h4><p>设n为正整数，X_n &#x3D; \{1,2,\cdots,n\}，考虑<code>偏序集</code>D_n &#x3D; (X_n, )，计算<code>偏序集的</code>\mu(1,n)</p>
<blockquote>
<p>整除性：a b 当且仅当 a 是 b的因子</p>
</blockquote>
<hr>
<p><code>整数n</code>有<code>唯一素数因数分解</code>，设为 \textcolor{blue}{n &#x3D; p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}}</p>
<p>则\mu(1,n)可递归定义为\textcolor{blue}{\mu(1,n) &#x3D; -\sum_{\{m \ge 1: mn, m \ne n\}}{\mu(1,m)}}</p>
<blockquote>
<p>即令1 \le m \le n，这里m \le n<code>的信息 被隐藏在</code>m n<code>中</code>。</p>
<p>之后利用<code>莫比乌斯函数的公式</code>求和即可。</p>
</blockquote>
<p>因此，只需要考虑(X_n^*, )，其中\textcolor{blue}{X_n^*}<code>是</code>X_n<code>中所有满足的正整k n数k组成的子集</code></p>
<p>设\textcolor{blue}{r, s \in X_n^*}，我们有 r &#x3D; p_1^{\beta_1}p_2^{\beta_2}\cdots p_k^{\beta_k}和s &#x3D; p_1^{\gamma_1}p_2^{\gamma_2}\cdots p_k^{\gamma_k}</p>
<p>其中\textcolor{blue}{0 \le \beta_i,\gamma_i \le \alpha_i (i&#x3D;1,2,\cdots,k)}</p>
<p>则rs \iff \beta_i \le \gamma_i(i&#x3D;1,2,\cdots,k)</p>
<blockquote>
<p>因为我们对<code>整数r</code> 和<code>整数s</code>做了<code>素数因子分解</code>，从<code>形式上来看</code>，应该如此。</p>
<p>如：r &#x3D; 8 &#x3D; 2^3, s &#x3D; 32 &#x3D; 2^5 \implies r s</p>
</blockquote>
<p>因此，<code>偏序集</code>(X_n^*, )正是<code>大小分别为</code>\alpha_1 + 1, \alpha_2 + 2, \cdots, \alpha_k + 1<code>的k个线性序的直积</code></p>
<p>则\textcolor{blue}{\mu(1,n) &#x3D; \prod_{i&#x3D;1}^{k}{\mu(1,p_i^{\alpha_i})}}</p>
<blockquote>
<p>我们首先是对<code>整数n</code>进行<code>素数因子分解</code>，然后对于r,s \in X_n^*，我们再<code>逐个对应地比较</code>p_i<code>的大小</code>，</p>
<p>从而来确定<code>是否有</code>r s</p>
<p>因此，此处<code>乘积</code>含义为：对<code>所有的k个的</code>p_i<code>所相关的偏序关系</code>\mu(1,p_i)<code>进行了 直积运算</code></p>
</blockquote>
<p>则</p>
<p>因此</p>
<p>若是互不相同的素数的乘积</p>
<p>Q.E.D</p>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h4><p><code>欧拉φ函数</code>的定义是：\phi(n) &#x3D; S_n</p>
<p>其中，Sn &#x3D; \{k: 1\le k\le n, GCD(k,n) &#x3D; 1\}</p>
<blockquote>
<p>即\phi(n)为<code>不超过n且与n互素的正整数个数</code></p>
</blockquote>
<blockquote>
<p>提示：可以对X_n<code>中的任何整数a和b</code>计算出\mu(a,b)：\textcolor{green}{ab \implies \mu(a,b) &#x3D; \mu(1, \frac{b}{a})}</p>
</blockquote>
<p>求\phi(n)的<code>莫比乌斯函数</code></p>
<hr>
<p>设是的正因子\textcolor{blue}{S_n^d} &#x3D; \{k: 1\le k \le n, \textcolor{blue}{GCD(k,n) &#x3D; d}\}, \quad \text{(d是n的正因子)}</p>
<p>任何满足GCD(k,n) &#x3D; 1的 <code>整数k</code>都有且\textcolor{blue}{k &#x3D; dk’, \quad 1\le k’ \le n&#x2F;d且GCD(k’, n&#x2F;d) &#x3D; 1}的形式</p>
<p>因此S_n^d &#x3D; \phi(n&#x2F;d)</p>
<p>设F(X)为\phi(n)</p>
<p>并设G(n) &#x3D; \sum_{\{d: d n\}}{\phi(d)}</p>
<blockquote>
<p>\phi(d)等于满足GCD(k,n)&#x3D;1的1和n之间的整数k的个数。</p>
<p>而对于<code>每个这样的k</code>，对<code>某个满足dn的整数d</code>，<code>GCD(k,n) = d</code>成立。</p>
<p>则我们得到G(n) &#x3D; n</p>
</blockquote>
<p>故\textcolor{blue}{G(n) &#x3D; n &#x3D; \sum_{\{d:dn\}}{\phi(d)}}</p>
<p>则通过<code>莫比乌斯反解</code>得</p>
<blockquote>
<p>\mu(d)非0 当且仅当：</p>
<ol>
<li>d &#x3D; 1</li>
<li>d是<code>互不相同的素数</code>的乘积</li>
</ol>
<blockquote>
<p>则\mu(d) &#x3D; (-1)^r，其中<code>r 是d中互不相同的素数的个数</code>。设<code>这些互异素数除以n为</code>p_1,p_2,\cdots,p_r则</p>
<blockquote>
<p>其中的<code>乘积</code>对<code>所有整除n的互不相同的素数p</code>进行求积</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h4><p>计算<code>k个不同符号</code>a_1,a_2,\cdots,a_k<code>的循环n排列</code>的个数，其中的<code>每个符号</code>可以使用<code>任意多次</code>。</p>
<blockquote>
<p>即<code>计数多重集合</code>\{\infty \cdot a_1, \infty \cdot a_2, \cdots, \infty \cdot a_k\}<code>的循环n排列的个数</code></p>
</blockquote>
<p>定义<code>周期</code>：<code>移动后使得留下的循环字不变</code>的<code>顺时针循环移位</code>的最小整数d，且1 \le d \le n和d n</p>
<p>设h(n)是<code>可能使用符号</code>a_1,a_2,\cdots,a_k<code>的串</code>的个数</p>
<blockquote>
<p>注：h(n)依赖于k，但这里没有表示出来。</p>
<p>可以将<code>一个循环排列</code>一一对应到为<code>线性的字</code></p>
</blockquote>
<p>设f(m)是<code>长度为m且可能用到符号</code>a_1,a_2,\cdots,a_k<code>的串的个数</code></p>
<p>因为<code>每个串</code>有<code>1个周期d</code>，其中<code>d n</code></p>
<p>则\textcolor{blue}{h(n) &#x3D; \sum_{\{d: dn\}}{\frac{f(d)}{d}}}</p>
<p>若能够计算<code>周期为d长度为n的串的个数</code>，则<code>能够计算h(n)</code></p>
<p><code>设</code>\textcolor{blue}{g(m) &#x3D; \sum_{\{e:em\}}{f(e)}}</p>
<p><code>g(m)长度为m的串的总数</code>，故\textcolor{blue}{g(m) &#x3D; k^m}，因而</p>
<p>则</p>
<blockquote>
<p>和\because ed 和 dn \therefore d &#x3D; me</p>
<p>其中me n \implies m n&#x2F;e</p>
</blockquote>
<h3 id="Theory-3"><a href="#Theory-3" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Inference-1"><a href="#Inference-1" class="headerlink" title="Inference"></a>Inference</h4><h5 id="Content-9"><a href="#Content-9" class="headerlink" title="Content"></a>Content</h5><p>设X_n &#x3D; \{1,2,\cdots, n\}，且设F: \mathcal{P} \rightarrow \real为<code>定义在</code>X_n<code>的子集上的函数</code></p>
<p>设G: \mathcal{P} \rightarrow \real是<code>由定义如下的函数</code>G(K) &#x3D; \sum_{L \subseteq K}{F(L)}, \quad(K \subseteq X_n)</p>
<p>则F(K) &#x3D; \sum_{L \subseteq K}{(-1)^{K -L} G(L)}, \quad (K \subseteq X_n)</p>
<h5 id="Proof-4"><a href="#Proof-4" class="headerlink" title="Proof"></a>Proof</h5><p>由之前的例子可知， <code>偏序集</code>(\mathcal{P}(X_n),\le)<code>的莫比乌斯函数</code>为(-1)^{K - L}</p>
<p>Q.E.D</p>
<h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Background-2"><a href="#Background-2" class="headerlink" title="Background"></a>Background</h5><p>若(X, \le_1)和(Y, \le_2)是两个<code>有限偏序集</code>，则在<code>X和Y的笛卡尔乘积</code>上<code>定义的偏序关系</code>\le_3为</p>
<p>而我们将(X \times Y, \le_3)叫做(X, \le_1)和(Y, \le_2)的<code>直积</code></p>
<blockquote>
<p>这类似于<code>编程语言</code>中<code>对于UDT的boolean compare(another object)</code>的定义。</p>
<p>比如说，我们有<code>Person &#123;String name, int age&#125;</code>，则对<code>String类型的属性name</code>和<code>int类型的属性age</code>所<code>调用的比较函数</code>是<code>不同的</code>，</p>
<p>而且，我们可以用这种方式<code>组合任意多的不同类型的属性的比较函数</code>。</p>
</blockquote>
<h5 id="Content-10"><a href="#Content-10" class="headerlink" title="Content"></a>Content</h5><p>设(X, \le_1)和(Y, \le_2)为<code>两个有限偏序集</code>，且<code>他们的莫比乌斯函数</code>分别为\mu_1和\mu_2，</p>
<p>设\mu为(X, \le_1)和(Y, \mu_2)<code>的直积的莫比乌斯函数</code>。则：</p>
<h5 id="Proof-5"><a href="#Proof-5" class="headerlink" title="Proof"></a>Proof</h5><blockquote>
<p>换句话说，<code>有限个有限偏序集的直积的莫比乌斯函数</code>是<code>他们的莫比乌斯函数的乘积</code></p>
</blockquote>
<h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><h5 id="Conent"><a href="#Conent" class="headerlink" title="Conent"></a>Conent</h5><p>设<code>F为定义在正整数集上的实值函数</code>，则定义<code>正整数集上的实值函数</code>\textcolor{blue}{G(n) &#x3D; \sum_{k: kn}F(k)}</p>
<p>则，对于<code>每一个正整数n</code>，我们有F(n) &#x3D; \sum_{k:kn}{\textcolor{green}{\mu(1, n&#x2F;k)}G(k)}</p>
<h5 id="Proof-6"><a href="#Proof-6" class="headerlink" title="Proof"></a>Proof</h5><blockquote>
<p><code>G(n)的定义</code> 仅依赖于<code>F在集合</code>X_n&#x3D;\{1,2,\cdots,n\}<code>的值</code></p>
</blockquote>
<p>Q.E.D</p>
<h3 id="Application-2"><a href="#Application-2" class="headerlink" title="Application"></a>Application</h3><h4 id="Application-1-1"><a href="#Application-1-1" class="headerlink" title="Application 1"></a>Application 1</h4><h5 id="Content-11"><a href="#Content-11" class="headerlink" title="Content"></a>Content</h5><p>求<code>将n个非攻击型车</code>放置到<code>n × n棋盘</code>A &#x3D; [a_{ij}: 1 \le i, j \le n]的<code>方案数</code>：</p>
<h5 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h5><p>设X_n &#x3D; \{1,2,\cdots,n\}，设\mathcal{P}_n表示<code>全部n!个双射</code>f: X_n \rightarrow X_n</p>
<blockquote>
<p>1个f 就是 1个排列方案</p>
</blockquote>
<p>则，<code>将n个非攻击型车</code>放置到<code>n × n矩阵</code>A&#x3D;[a_{ij}]<code>的棋盘的方法数</code>为</p>
<blockquote>
<p>a_{if(i)}表示<code>第i行第f(i)列的值</code></p>
<p>上述式子的<code>乘积</code>用于<code>验证某个特定的放置方案</code>是否<code>合法</code>，若合法为1，否则为0</p>
<p>而<code>累加</code>用于<code>对所有可能的放置方案进行验证，并统计有几个合法方案</code></p>
</blockquote>
<hr>
<p>考虑<code>偏序集</code>(\mathcal{P}(X_n), \le)，X_n<code>的每个基数为k的子集S 从A挑选k个列的集合</code>，我们将<code>这些列组成的n × k的子矩阵 记为</code>\textcolor{blue}{A[S]}</p>
<p>设\mathcal{F}_n(S)表示<code>所有的函数</code>f: \{1,2,\cdots,n\} \rightarrow S<code>的集合</code></p>
<p>设\mathcal{G}_n(S)表示<code>满射函数的子集</code></p>
<p>则有\textcolor{blue}{\mathcal{F}_n(S) &#x3D; \cup_{T \subseteq S}{\mathcal{G}(T)}}</p>
<p><code>定义</code> <code>函数</code>F: \mathcal{P}(X_n) \rightarrow \real为\textcolor{blue}{F(S) &#x3D; \sum_{f \in \mathcal{G}(S)}{\prod_{i&#x3D;1}{a_{if(i)}}}, \quad (S \subseteq X_n)}</p>
<blockquote>
<p>F(X_n)即为plans：因为<code>函数f</code>不但是<code>满射函数</code>，而且是<code>双射函数</code></p>
</blockquote>
<p>设G(S) &#x3D; \sum_{T \subseteq S}{F(T)}, \quad (S \subseteq X_n)</p>
<p>则\textcolor{blue}{G(S) &#x3D; \sum_{g \in \mathcal{F}_n(S)}{\prod_{i&#x3D;1}{a_{ig(i)}}},\quad (S \subseteq X_n)}</p>
<p>根据<code>偏序集</code>(\mathcal{P}(X_n), \le)的<code>莫比乌斯函数</code>，得F(X_n) &#x3D; \sum_{S \subseteq X_n}{\textcolor{green}{(-1)^{n-S}}G(S)}</p>
<p>又G(S)<code>是关于所有的函数</code>g: X_n \rightarrow S<code>对</code>a_{1g(1)}, a_{2g(2), \cdots, a_{ng(n)}}<code>的求和</code>,故它的值为：</p>
<p>G(S) &#x3D; \prod_{i&#x3D;1}^n{(\sum_{j \in S}}{a_{ij})}</p>
<blockquote>
<p>也就是说，G(S)是对A[S]的<code>每行上的元素先求和，再乘积</code></p>
</blockquote>
<p>则</p>
<blockquote>
<p>上式表明了一种<code>把n个非攻击型车放置到n × n的棋盘上的方案数</code>的计算方法：</p>
<p>选出<code>列的一个子集</code>，计算<code>这些列上的所有元素的和</code>，<code>再把这些和相乘起来</code>，加上<code>适当的符号</code>，并对<code>所有列的选择求和</code>。（<code>被加数</code>的个数 &#x3D; <code>大小为n的集合的子集的个数</code>）</p>
</blockquote>
<blockquote>
<p>我们<code>常规的解法是：将棋盘矩阵A的每一行视为一个对象</code>，而<code>该解法是：将棋盘矩阵A的每一列视为一个对象</code></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/29/counting-the-pigeonhole-theorem-ramsey-theorem/" rel="prev" title="Combinatorics - The Pigeonhole Principle & Ramsey Theorem">
      <i class="fa fa-chevron-left"></i> Combinatorics - The Pigeonhole Principle & Ramsey Theorem
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/01/counting-system-of-distinct-representative/" rel="next" title="Combinatorics - System of Distinct Representative">
      Combinatorics - System of Distinct Representative <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Inclusion-Exclusion-Principle"><span class="nav-number">1.</span> <span class="nav-text">Inclusion-Exclusion Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Inclusion-Exclusion-Principle-1"><span class="nav-number">1.1.</span> <span class="nav-text">Inclusion-Exclusion Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition"><span class="nav-number">1.1.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proof"><span class="nav-number">1.1.2.</span> <span class="nav-text">Proof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory"><span class="nav-number">1.1.3.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inference"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">Content</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Specialization"><span class="nav-number">1.1.4.</span> <span class="nav-text">Specialization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Content-1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Content</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application"><span class="nav-number">1.1.5.</span> <span class="nav-text">Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-1"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Application 1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-2"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-2"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">Application 2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-3"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-1"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-3"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Application 3</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-4"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-2"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-4"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Application 4</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-5"><span class="nav-number">1.1.5.4.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-3"><span class="nav-number">1.1.5.4.2.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-5"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">Application 5</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-6"><span class="nav-number">1.1.5.5.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-4"><span class="nav-number">1.1.5.5.2.</span> <span class="nav-text">Solution</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Derangement-Formula"><span class="nav-number">1.2.</span> <span class="nav-text">Derangement Formula</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Background"><span class="nav-number">1.2.1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proof-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">Proof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-Approximation"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Theory: Approximation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-Recurrence-Formula"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Theory: Recurrence Formula</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">Theory</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrangement-Problems-with-Prohibited-Positions"><span class="nav-number">1.3.</span> <span class="nav-text">Arrangement Problems with Prohibited Positions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-1-Non-Attack-Rook-Problem-with-Prohibited-Positions"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Application 1: Non-Attack Rook Problem with Prohibited Positions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Theorem"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">Theorem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Proof-2"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">Proof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-7"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-5"><span class="nav-number">1.3.2.1.4.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-2-Boys-Queuing-Problem"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Application 2: Boys Queuing Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-8"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Theorem-1"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">Theorem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-6"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">Solution</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mobius-Inversion"><span class="nav-number">1.4.</span> <span class="nav-text">Mobius Inversion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Background-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proof-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">Proof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example"><span class="nav-number">1.4.4.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Example 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Example 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-3"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Example 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-4"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">Example 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-5"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">Example 5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-3"><span class="nav-number">1.4.5.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inference-1"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-9"><span class="nav-number">1.4.5.1.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Proof-4"><span class="nav-number">1.4.5.1.2.</span> <span class="nav-text">Proof</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theorem-2"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Theorem</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Background-2"><span class="nav-number">1.4.5.2.1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-10"><span class="nav-number">1.4.5.2.2.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Proof-5"><span class="nav-number">1.4.5.2.3.</span> <span class="nav-text">Proof</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theorem-3"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">Theorem</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Conent"><span class="nav-number">1.4.5.3.1.</span> <span class="nav-text">Conent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Proof-6"><span class="nav-number">1.4.5.3.2.</span> <span class="nav-text">Proof</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-2"><span class="nav-number">1.4.6.</span> <span class="nav-text">Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-1-1"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">Application 1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Content-11"><span class="nav-number">1.4.6.1.1.</span> <span class="nav-text">Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Solution-7"><span class="nav-number">1.4.6.1.2.</span> <span class="nav-text">Solution</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

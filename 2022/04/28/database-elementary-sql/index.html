<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sakurawald.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Elementary SQLPrimitive TypePrimitive Type Description char(n), character(n) 固定长度的字符串，固定长度 为 n varchar(n), character\ varying(n) 可变长度的字符串，最大长度 为 n int, integer 整数类型 smallint 小整数类型 numeric(p,d) 定点数类型：n">
<meta property="og:type" content="article">
<meta property="og:title" content="Database - Elementary SQL">
<meta property="og:url" content="https://sakurawald.github.io/2022/04/28/database-elementary-sql/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:description" content="Elementary SQLPrimitive TypePrimitive Type Description char(n), character(n) 固定长度的字符串，固定长度 为 n varchar(n), character\ varying(n) 可变长度的字符串，最大长度 为 n int, integer 整数类型 smallint 小整数类型 numeric(p,d) 定点数类型：n">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/04/28/UDCi95xnFNvL6GW.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/28/rmL13RFyhHCZdbW.png">
<meta property="article:published_time" content="2022-04-28T19:55:53.000Z">
<meta property="article:modified_time" content="2023-01-01T23:38:44.219Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/04/28/UDCi95xnFNvL6GW.png">

<link rel="canonical" href="https://sakurawald.github.io/2022/04/28/database-elementary-sql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Database - Elementary SQL | SakuraWald</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SakuraWald</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/28/database-elementary-sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Database - Elementary SQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 19:55:53" itemprop="dateCreated datePublished" datetime="2022-04-28T19:55:53+00:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Elementary-SQL"><a href="#Elementary-SQL" class="headerlink" title="Elementary SQL"></a>Elementary SQL</h1><h2 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h2><p>Primitive Type</p>
<p>Description</p>
<p>char(n), character(n)</p>
<p><code>固定长度的字符串</code>，<code>固定长度</code> 为 n</p>
<p>varchar(n), character\ varying(n)</p>
<p><code>可变长度的字符串</code>，<code>最大长度</code> 为 n</p>
<p>int, integer</p>
<p><code>整数类型</code></p>
<p>smallint</p>
<p><code>小整数类型</code></p>
<p>numeric(p,d)</p>
<p><code>定点数类型</code>：numeric(3,1) \to 44.5</p>
<p>real, double\ precision</p>
<p><code>浮点数</code> 和 <code>双精度浮点数</code></p>
<p>float(n)</p>
<p><code>精度至少为n位的浮点数</code></p>
<blockquote>
<p><code>空值 (null)</code>：任何 <code>数据类型</code> 都可能包含 <code>空值</code>。<code>空值</code> 表达语义 <code>缺失的值</code>。</p>
</blockquote>
<blockquote>
<p>对于使用 <code>char</code> 类型存放的 <code>字符串</code>，会自动执行 <code>末尾补空格</code> 策略。</p>
<p>但请注意，当我们使用 <code>char</code> 和 <code>varchar</code> 进行 <code>相等性测试</code>时，<code>行为</code> 将是 <code>未定义的</code>，某些实现可能会 <code>自动为varchar在末尾补空格</code>。</p>
<p>出于这点考虑，建议 <code>永远只使用varchar</code></p>
</blockquote>
<h2 id="Define-a-Database-Pattern"><a href="#Define-a-Database-Pattern" class="headerlink" title="Define a Database Pattern"></a>Define a Database Pattern</h2><h3 id="General-Form"><a href="#General-Form" class="headerlink" title="General Form"></a>General Form</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> r</span><br><span class="line">(Attribute1 Domain1,</span><br><span class="line"> Attribute2 Domain2,</span><br><span class="line"> ...,</span><br><span class="line"> Attributen Domainn,</span><br><span class="line"> <span class="operator">&lt;</span>Integrity <span class="keyword">Constraint</span><span class="operator">&gt;</span>,</span><br><span class="line"> ...,</span><br><span class="line"> <span class="operator">&lt;</span>Integrity <span class="keyword">Constraint</span><span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>域 (Domain)</code> ：用于指定 <code>与域相关联的属性</code> 的 <code>数据类型</code> 以及 <code>约束</code></p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teaches(</span><br><span class="line">id <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">course_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">section_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">semester <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line"><span class="keyword">year</span> <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id, course_id, section_id, semester, <span class="keyword">year</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (course_id, section_id, semester, <span class="keyword">year</span>) <span class="keyword">REFERENCES</span> section,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (id) <span class="keyword">REFERENCES</span> instructor    </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Basic-DML"><a href="#Basic-DML" class="headerlink" title="Basic DML"></a>Basic DML</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> instructor <span class="keyword">VALUES</span> (<span class="number">10211</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Biology&#x27;</span>, <span class="number">66000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li>Delete a <code>Relationship</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> r;</span><br></pre></td></tr></table></figure>

<ul>
<li>Delete <code>Tuple</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用 <code>DELETE FROM r</code>来删除 <code>关系中的所有元组</code>，但 <code>保留关系的模式定义</code></p>
</blockquote>
<h4 id="Alter"><a href="#Alter" class="headerlink" title="Alter"></a>Alter</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> r <span class="keyword">ADD</span> attribute domain;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> r <span class="keyword">DROP</span> attribute;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>某些 <code>数据库</code> 仅仅支持 <code>删除整个关系</code> ，而不支持 <code>删除关系中的某个属性</code>。</p>
</blockquote>
<h2 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h2><p><code>SQL</code> 的 <code>基本查询</code> 由 <code>SELECT</code>，<code>FROM</code>，<code>WHERE</code> 三大 <code>子句</code> 所构成。</p>
<h3 id="Single-Relation-query"><a href="#Single-Relation-query" class="headerlink" title="Single-Relation query"></a>Single-Relation query</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>数学</code> 上的 <code>关系</code> 本质是 <code>集合</code>，不允许 <code>重复元素</code>。</p>
<p>但 <code>维护元素的唯一性</code> 的 <code>代价</code> 非常大，在 <code>数据库</code> 中则是 <code>允许关系中的元素发生重复</code></p>
<blockquote>
<ul>
<li><code>all</code> 和 <code>distinct</code></li>
</ul>
<p>对于 <code>SELECT</code> 来说，<code>去重选项</code> 默认为 <code>ALL</code> 即表示 <code>不去重</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ALL</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure>

<p>也可以手动指定为 <code>distinct</code> 表示需要进行 <code>去重</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>使用 <code>WHERE子句</code> 可以从 <code>FROM子句的结果关系</code> 中 <code>筛选</code> 出 <code>使得谓词为True的元组</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> deptname  <span class="string">&#x27;Comp.Sci.&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">70000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Multi-Relation-query"><a href="#Multi-Relation-query" class="headerlink" title="Multi-Relation query"></a>Multi-Relation query</h3><h4 id="General-Form-1"><a href="#General-Form-1" class="headerlink" title="General Form"></a>General Form</h4><p><code>多表查询</code> 的 <code>通用格式</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attribute1, attribute2, ..., attributen</span><br><span class="line"><span class="keyword">FROM</span> r1, r2, ..., rn</span><br><span class="line"><span class="keyword">WHERE</span> P;</span><br></pre></td></tr></table></figure>

<p>其中，每种 <code>子句</code> 的作用如下：</p>
<ul>
<li><code>SELECT子句</code>：从 <code>WHERE子句给出的元组</code> 中 <code>投影</code> 指定的 <code>属性列表</code></li>
<li><code>FROM子句</code>：给出 <code>作为数据输入的</code> 的 <code>关系列表</code></li>
<li><code>WHERE子句</code>：<code>过滤出</code> 使得 <code>谓词</code> 为 <code>True</code> 的 <code>FROM子句中的元组</code></li>
</ul>
<blockquote>
<p><code>数据库</code> 执行 <code>查询</code> 的 <code>顺序</code> 与 <code>书写顺序</code> 不太一样：FROM \to WHERE \to SELECT</p>
<p>可以将 <code>SELECT子句</code> 看作是一种 <code>语言学方面的结构提前</code>，这种 <code>形式提前</code> 有利于我们 <code>快速地了解输出的结构是什么</code></p>
</blockquote>
<blockquote>
<p><code>WHERE子句</code> 的 <code>默认值</code> 为 <code>WHERE true</code></p>
</blockquote>
<blockquote>
<p><code>FROM子句</code> 会为 <code>关系列表</code> 中的 <code>所有关系</code> 都进行 <code>笛卡尔积运算</code>，通常会产生一个 <code>非常巨大的结果关系</code></p>
<blockquote>
<p>实际上，大部分情况下并不会真的 <code>生成</code> <code>关系列表中所有关系的笛卡尔积</code>。</p>
<p>因为 <code>查询优化器</code> 会 <code>事先过滤</code>掉 <code>大部分不可能满足WHERE子句的元组</code>，使得 <code>FROM子句</code> 输出的 <code>结果关系</code> 规模 <code>大幅度减小</code></p>
</blockquote>
<p>对于 <code>FROM instructor, department</code> 来说，就是对 <code>instructor关系</code> 和 <code>department关系</code> 进行 <code>笛卡尔积</code> 作为 <code>结果关系</code></p>
</blockquote>
<h4 id="Match-Condition-Specified-by-Where-Clause"><a href="#Match-Condition-Specified-by-Where-Clause" class="headerlink" title="Match Condition Specified by Where Clause"></a>Match Condition Specified by Where Clause</h4><p>通过 <code>Where子句</code> 指定 <code>匹配条件</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> instructor.ID <span class="operator">=</span> teaches.ID;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当 <code>属性名</code> 仅出现在 <code>FROM子句所指定的关系</code> 的 <code>一个关系</code> 中时，可以省略掉 <code>属性名的全限定前缀</code>。</p>
<p>当然，<code>总是为属性名写上关系名前缀</code> 是没有错的。</p>
</blockquote>
<blockquote>
<p>n.b. 上述的 <code>匹配条件</code> 并不会查询出 <code>没有教授任何课程的教师</code>。</p>
<p>如果期望显示出这些教师，则应当使用 <code>外连接</code></p>
</blockquote>
<h4 id="Match-Condition-Specified-by-Natural-Join"><a href="#Match-Condition-Specified-by-Natural-Join" class="headerlink" title="Match Condition Specified by Natural Join"></a>Match Condition Specified by Natural Join</h4><h5 id="Natural-Join-Compare-all-the-common-attributes"><a href="#Natural-Join-Compare-all-the-common-attributes" class="headerlink" title="Natural Join: Compare all the common attributes"></a>Natural Join: Compare all the common attributes</h5><p><code>自然连接 (Natural Join)</code>：将输入的 <code>2个关系</code> 中 <code>共有属性 (Common Condition) 的值</code> <code>均相等</code> <code>的元组</code> 作为 <code>输出结果</code></p>
<p>下列 <code>查询</code> 的 <code>等价形式</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> instructor.ID <span class="operator">=</span> teaches. ID</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> teaches</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，可以将 <code>NATURAL JOIN语句</code> 看作是一种形式的 <code>宏展开 (Macro Expansion)</code>。</p>
<p>先查找 <code>两个关系的共有属性</code>，然后 <code>改写</code> 成 <code>WHERE子句</code> 形式的 <code>谓词</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> S.common_attribute_1 <span class="operator">=</span> T.common_attribute_1</span><br><span class="line"><span class="keyword">AND</span> S.common_attribute_2 <span class="operator">=</span> T.common_attribute_2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">AND</span> S.common_attribute_n <span class="operator">=</span> T.common_attribute_n</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Natural-Join-Specify-specific-common-attributes"><a href="#Natural-Join-Specify-specific-common-attributes" class="headerlink" title="Natural Join: Specify specific common attributes"></a>Natural Join: Specify specific common attributes</h5><p>首先，考虑下面这个 <code>查询</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 1</span></span><br><span class="line"><span class="keyword">SELECT</span> name, title</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> teaches, course</span><br><span class="line"><span class="keyword">WHERE</span> teaches.course_id <span class="operator">=</span> course.course_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. <code>teaches.course_id</code> 追根溯源来自 <code>teaches</code>，我们是无法直接 <code>引用</code> <code>自然连接的结果关系</code> 的，但可以 <code>直接引用</code> <code>参与自然连接的属性</code>，因为 <code>自然连接的结果关系</code> 中的 <code>属性</code> 正来自这些 <code>单个关系的属性</code>。</p>
</blockquote>
<p>但是，该查询 <code>并不等价于</code> 下列这个 <code>查询</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 2</span></span><br><span class="line"><span class="keyword">SELECT</span> name, title</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> teaches <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> course</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>instructor关系</code>，<code>teaches关系</code>，<code>course关系</code> 均有 <code>dept_name属性</code>。</p>
<p>对于 <code>Query 1</code> ：则只需要考虑 <code>这两个关系的</code> <code>dept_name属性</code> 的 <code>相等</code>，而 <code>course关系的dept_name属性</code> 可以与他们不同。也就是说，该查询会显示出 <code>教师所讲授的课程</code> 不是 <code>教师所在系的课程</code></p>
<p>对于 <code>Query 2</code>：该查询 <code>只显示</code> <code>教师所教的课程</code> <code>就是该教师所在系的课程</code></p>
</blockquote>
<p>出现该问题的原因在于，在将 <code>instructor NATURAL JOIN teaches</code> 和 <code>course</code>进行 <code>自然连接</code> 时，<code>course</code> 中存在 <code>我们不希望使用的共同属性</code> 即 <code>dept_name</code></p>
<blockquote>
<p><code>course关系</code> 共有2个 <code>共同属性</code>：<code>course_id</code>，<code>dept_name</code></p>
</blockquote>
<p>对此，我们可以通过 <code>带指定属性列表的自然连接 (Natural Join with Specific Arrtibute List)</code> 来改写 <code>Query 2</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 3</span></span><br><span class="line"><span class="keyword">SELECT</span> name, title</span><br><span class="line"><span class="keyword">FROM</span> (instructor <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> teaches) <span class="keyword">JOIN</span> course <span class="keyword">USING</span> (course_id)</span><br></pre></td></tr></table></figure>

<p>这样，<code>Query 3</code> 等价于 <code>Query 1</code>。</p>
<blockquote>
<p>n.b. 同样的道理，可以再将 <code>NATURAL JOIN</code> 视为 <code>JOIN relation USING attribute_list</code> 的 <code>宏展开</code>。</p>
<p>默认情况下，<code>relation_1 NATURAL JOIN relation_2</code> 可以展开为 <code>relation_1 JOIN relation_2 USING (common_attribute_list)</code></p>
</blockquote>
<h2 id="Basic-Operation"><a href="#Basic-Operation" class="headerlink" title="Basic Operation"></a>Basic Operation</h2><h3 id="Rename-Operation"><a href="#Rename-Operation" class="headerlink" title="Rename Operation"></a>Rename Operation</h3><p><code>更名运算 (Rename Operation)</code> 用于为 <code>实体</code> 指定 <code>标识符</code>。</p>
<p>它主要有以下几种作用：</p>
<ul>
<li><p>修改 <code>输出关系</code>中的 <code>长属性名</code> 修改为 <code>短属性名</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> instructor_name <span class="keyword">AS</span> inst_name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br></pre></td></tr></table></figure>
</li>
<li><p>为 <code>运算中间结果</code> 指定 <code>标识符</code>，以便 <code>后续对它的引用</code></p>
</li>
<li><p>用于 <code>区分</code> <code>涉及自身关系的笛卡尔积运算</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> T.name</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">AS</span> T, instructor <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> T.salary <span class="operator">&gt;</span> S.salary <span class="keyword">AND</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 可以将 <code>T</code> 和 <code>S</code> 看作是 <code>instructor关系</code> 的 <code>2份拷贝</code></p>
<blockquote>
<p>实际上，并不会真的拷贝2份关系。<code>T</code> 和 <code>S</code> 只不过是对 <code>instructor</code> 的 <code>引用</code> 而已。</p>
</blockquote>
</blockquote>
<blockquote>
<p>像 <code>T</code> 和 <code>S</code> 这样 <code>用于重命名关系的标识符</code> 被称为 <code>相关名称 (Correlation Name)</code>，或 <code>表别名 (Table Alias)</code> 或 <code>相关变量 (Correlation Variable)</code> 或 <code>元组变量 (Tuple Variable)</code></p>
</blockquote>
</li>
</ul>
<h3 id="String-Operation"><a href="#String-Operation" class="headerlink" title="String Operation"></a>String Operation</h3><h4 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> building <span class="keyword">LIKE</span> <span class="string">&#x27;%Watson%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>LIKE操作符</code>可以实现 <code>模式匹配 (Pattern Matching)</code>，使用如下 <code>字符</code> 来 <code>定义模式</code>：</p>
<ul>
<li><code>百分号 (%)</code>：匹配 <code>任意子串</code></li>
<li><code>下划线 (_)</code>：匹配 <code>任意一个字符</code></li>
</ul>
<blockquote>
<p>n.b. 尽管 <code>SQL标准</code> 中要求 <code>字符串的相等运算</code> 是 <code>大小写敏感的</code>。</p>
<p>但 <code>某些数据库</code>，如 <code>MySQL</code> 和 <code>SQL Server</code> 却在 <code>匹配字符串</code> 时 <code>不区分大小写</code>！</p>
<p>关于 <code>字符串相等性测试</code> 的具体详情，应当查阅 <code>Manual</code></p>
</blockquote>
<h4 id="Escape-Character"><a href="#Escape-Character" class="headerlink" title="Escape Character"></a>Escape Character</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;ab\%cd%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>ESCAPE关键字</code> 定义 <code>转义字符</code> 为 <code>\</code></p>
<h3 id="Order-Operation"><a href="#Order-Operation" class="headerlink" title="Order Operation"></a>Order Operation</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ORDER BY子句</code> 的 <code>默认值</code> 为 <code>asc</code>，而 <code>desc</code> 需要手动指定。</p>
</blockquote>
<h4 id="Between-Operation"><a href="#Between-Operation" class="headerlink" title="Between Operation"></a>Between Operation</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 1</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">9000</span> <span class="keyword">AND</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 2</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">9000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p><code>Query 1</code> 等价于 <code>Query 2</code></p>
<blockquote>
<p>n.b. 可以将 <code>Between运算符</code> 和 <code>Not Between运算符</code> 视为 <code>基于不等式比较运算符写法</code> 的 <code>宏展开</code>。</p>
<p>但使用 <code>Between</code> 和 <code>Not Between</code> 使得 <code>查询</code> 更加 <code>清晰</code>，而且更不容易 <code>错写</code></p>
</blockquote>
<h4 id="Multi-Dimensional-Tuple"><a href="#Multi-Dimensional-Tuple" class="headerlink" title="Multi-Dimensional Tuple"></a>Multi-Dimensional Tuple</h4><p>考虑下列 <code>包含多个AND的相等性测试语句</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 1</span></span><br><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> instructor.ID <span class="operator">=</span> teaches.ID <span class="keyword">AND</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 2</span></span><br><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> (instructor.ID, dept_name) <span class="operator">=</span> (teaches.ID, <span class="string">&#x27;Biology&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Query 1</code> 等价于 <code>Query 2</code></p>
<blockquote>
<p>作为一种更为 <code>抽象</code> 的考虑。我们可以认为 <code>常规所书写的相等语句</code> 本质上就属于 <code>1维元组</code>。</p>
<p>而如果需要同时测试 <code>多个属性的某种比较关系</code>，可以使用 <code>向量/元组</code>。</p>
<p>上述仅仅是 <code>测试</code> <code>相等关系</code>。同理，也可以用于 <code>测试</code> <code>偏序关系</code>。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x1, y1) <span class="operator">&lt;</span> (x2, y2) </span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="Set-Operation"><a href="#Set-Operation" class="headerlink" title="Set Operation"></a>Set Operation</h3><p><code>SQL标准</code> 中所定义的 <code>集合运算</code> 都是基于 <code>数学的集合论语义</code> 的：<code>所有的集合运算</code> 会 <code>自动去重</code></p>
<blockquote>
<p>实际上，<code>SQL</code> 的 <code>集合运算</code> 有 <code>两套版本</code></p>
<ul>
<li><code>自动去重的默认的distinct版本</code>：<code>intersect (distinct)</code>，<code>union (distinct)</code> ，<code>except (distinct)</code></li>
<li><code>不带去重的all版本</code> ： <code>intersect all</code>，<code>union all</code>，<code>except all</code></li>
</ul>
</blockquote>
<h4 id="Intersect-Operation"><a href="#Intersect-Operation" class="headerlink" title="Intersect Operation"></a>Intersect Operation</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"> <span class="keyword">FROM</span> section</span><br><span class="line"> <span class="keyword">WHERE</span> semester<span class="operator">=</span><span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">) <span class="keyword">INTERSECT</span></span><br><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester<span class="operator">=</span><span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="Union-Operation"><a href="#Union-Operation" class="headerlink" title="Union Operation"></a>Union Operation</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"> <span class="keyword">FROM</span> section</span><br><span class="line"> <span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">) <span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="Except-Operation"><a href="#Except-Operation" class="headerlink" title="Except Operation"></a>Except Operation</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"> <span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">) <span class="keyword">EXCEPT</span></span><br><span class="line">(<span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span>   </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><h3 id="The-type-of-operation-involved"><a href="#The-type-of-operation-involved" class="headerlink" title="The type of operation involved"></a>The type of operation involved</h3><p>The type of operation involved</p>
<p>Rule</p>
<p><code>算术表达式</code></p>
<p>任何 <code>算术表达式</code> 的 <code>输入为空</code>，则 <code>输出为空</code></p>
<p><code>逻辑表达式</code></p>
<p>任何 <code>涉及空值的逻辑表达式</code> 的 <code>输出为未知 (unknown)</code><br>n.b. <code>unknown</code> 并不是 <code>null</code>或 <code>not null</code>，也不是 <code>true</code> 和 <code>false</code>。<br><code>unknown</code> 是 <code>区别于true和false的第三种逻辑值</code>  </p>
<p><code>基本逻辑运算</code> 对于 <code>unknown</code> 定义了 <code>特殊规则</code><br><code>fasle AND unknown = false</code>，<code>true OR unknown = true</code>，<code>NOT unkown = unknown</code></p>
<blockquote>
<p>n.b. <code>SQL标准</code> 定义的 <code>逻辑值</code> 有3种：<code>true</code>，<code>false</code>，<code>unknown</code>。</p>
<p>注意 <code>while子句</code> 的 <code>语义</code> 为：<code>过滤出</code> <code>使得谓词为true的哪些元组</code></p>
</blockquote>
<blockquote>
<p>n.b. <code>未知 (unknown)</code> 也不是 <code>空 (null)</code>。</p>
<p><code>unknown</code>不可以用 <code>is null</code> 或 <code>is not null</code> 来测试。</p>
<p>某些 <code>具体实现</code> 提供了 <code>is unknown</code> 来进行测试。</p>
</blockquote>
<h3 id="Equality-Test"><a href="#Equality-Test" class="headerlink" title="Equality Test"></a>Equality Test</h3><p>Equality Test</p>
<p>Rule</p>
<p><code>元组的相等性测试</code></p>
<p>在测试 <code>两个元组的属性值</code> 是否相等时，如果 <code>属性值</code> 均为 <code>null</code>，则 <code>属性值视为相同</code><br>n.b. 如果 <code>只想保留这样的相同元组的一份拷贝</code>，可以使用 <code>SELECT DISTINCT</code></p>
<p><code>谓词的相等性测试</code></p>
<p>在测试 <code>谓词 null = null</code> 时，将返回 <code>unknown</code>，而不是 <code>true</code></p>
<blockquote>
<p>n.b. 可以认为，<code>元组的相等性测试</code> 实际上执行的是 <code>另一套特殊规则</code>：它为 <code>null = null</code> 返回 <code>true</code></p>
<p>而 <code>谓词的相等性测试</code> 则：为 <code>null = null</code> 返回 <code>unknown</code></p>
</blockquote>
<h2 id="Aggregate-Function"><a href="#Aggregate-Function" class="headerlink" title="Aggregate Function"></a>Aggregate Function</h2><p><code>聚集函数 (Aggregate Function)</code>：以 <code>值的集合</code> 作为输入，返回 <code>单个值</code> 。</p>
<p>Intrinsic Aggregate Function</p>
<p>Node</p>
<p>avg()</p>
<p> </p>
<p>min()</p>
<p> </p>
<p>max()</p>
<p> </p>
<p>sum()</p>
<p>忽略 <code>null</code></p>
<p>count()</p>
<p>为 <code>null</code> 返回 <code>0</code></p>
<h3 id="Basic-Aggregate"><a href="#Basic-Aggregate" class="headerlink" title="Basic Aggregate"></a>Basic Aggregate</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp.Sci.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>计算 <code>某个关系中的元组个数</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> course;</span><br></pre></td></tr></table></figure>

<hr>
<p>若需要在 <code>聚集操作</code> <code>之前</code> 进行 <code>去重</code>，则可以使用 <code>distinct关键字</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> ID) </span><br><span class="line"><span class="keyword">FROM</span> teaches</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="string">&#x27;2010&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 可以认为，对于 <code>内置的5个聚集函数</code> 而言，默认的 <code>去重选项</code> 是 <code>all</code></p>
<p>n.b. <code>SQL标准</code> 并不允许为 <code>count(*)</code> 使用 <code>distinct</code>。但却可以为 <code>min</code> 和 <code>max</code> 使用 <code>distinct</code>。尽管这些 <code>distinct</code> 并不会改变 <code>运算结果</code> ！</p>
</blockquote>
<h3 id="Grouped-Aggregate"><a href="#Grouped-Aggregate" class="headerlink" title="Grouped Aggregate"></a>Grouped Aggregate</h3><p><code>分组聚集 (Grouped Aggregate)</code> ：可以先对 <code>某个关系中的元组</code> 进行 <code>分组</code>，然后再 <code>分别地</code> 对 <code>每个分组</code> 进行 <code>聚集操作</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以认为，默认情况下 <code>省略</code> <code>GROUP BY子句</code> 意味着：将 <code>整个关系的所有元组</code> 分为 <code>唯一的一组</code>。</p>
</blockquote>
<hr>
<p>考虑一个 <code>错误的查询例子</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This is a wrong query example</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, ID, <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name;</span><br></pre></td></tr></table></figure>

<p>该 <code>查询</code> 的问题在于，我们使用 <code>dept_name属性</code> 将 <code>instructor关系的元组</code> 按 <code>系</code> 进行 <code>分组</code>，之后的 <code>avg(salary)</code> 计算的是 <code>某个系的所有教师的平均工资</code>。</p>
<p>而 <code>ID属性</code> 的问题在于，对于 <code>某个系</code> 来说， <code>该系中有许多的教师</code>，如果确实需要 <code>输出ID</code>，那么究竟要输出 <code>该系的所有教师中的哪一个教师的ID</code>？</p>
<p>综上，我们对于 <code>GROUP BY</code> 有一个规则：出现在 <code>SELECT子句</code> 中，但没有被 <code>聚集</code> 的 <code>属性</code>。必须出现在 <code>GROUP BY</code> 中。</p>
<h3 id="Grouped-Aggregate-with-Having-Clause"><a href="#Grouped-Aggregate-with-Having-Clause" class="headerlink" title="Grouped Aggregate with Having Clause"></a>Grouped Aggregate with Having Clause</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">avg</span>(salary) <span class="operator">&gt;</span> <span class="number">42000</span>;</span><br></pre></td></tr></table></figure>

<p><code>HAVING 子句</code> 在 <code>Grouped Aggregate输出结果</code> <code>之后</code> 才进行 <code>过滤</code>。</p>
<blockquote>
<p>换句话说，<code>HAVING</code> 必须在 <code>GROUP BY</code> 的 <code>分组形成后</code> 才能 <code>执行</code></p>
</blockquote>
<p>同理，对 <code>HAVING</code> 也有类似 <code>GROUP BY</code> 的规则 ：出现在 <code>HAVING子句</code>中，但没有被 <code>聚集</code> 的 <code>属性</code>。必须出现在 <code>GROUP BY</code>中。</p>
<blockquote>
<p>可以将 <code>HAVING子句</code> 和 <code>WHERE子句</code> 作类比。</p>
<ul>
<li><p><code>WHERE</code> ：针对 <code>元组</code></p>
</li>
<li><p><code>HAVING</code>：针对 <code>分组</code></p>
</li>
</ul>
</blockquote>
<blockquote>
<p>现在，我们可以这样看待 <code>标准的SELECT-FROM-WHERE查询</code>为：将 <code>某个关系的分组</code> 分为 <code>唯一的一组</code>，且 <code>分组过滤条件</code> 为 <code>HAVING true</code></p>
</blockquote>
<h2 id="Nested-Subquery"><a href="#Nested-Subquery" class="headerlink" title="Nested Subquery"></a>Nested Subquery</h2><p>我们知道 <code>SELECT-FROM-WHERE</code> 返回类型为 <code>关系</code>，而 <code>FROM子句</code> 的输入类型也为 <code>关系</code>，那么 <code>嵌套子查询 (Nested Subquery)</code> 应当是合理的。</p>
<ul>
<li><code>in</code> 和 <code>not in</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span> </span><br><span class="line"><span class="keyword">AND</span> course_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> course_id</span><br><span class="line">                  <span class="keyword">FROM</span> section</span><br><span class="line">                  <span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span>;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>all</code> 和 <code>any/some</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> T.name</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">AS</span> T, instructor <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> T.salary <span class="operator">&gt;</span> S.salary <span class="keyword">AND</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 这种实现方式中，必须要加 <code>DISTINCT</code>：因为 <code>FROM子句</code> 输出的 <code>结果关系</code> 为 <code>2个关系的笛卡尔积</code>，此时 <code>结果关系</code> 中 <code>满足WHERE条件的元组</code> 会 <code>重复</code></p>
</blockquote>
<p>等价于</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 2</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span>(<span class="keyword">SELECT</span> salary</span><br><span class="line">                   <span class="keyword">FROM</span> instructor</span><br><span class="line">                   <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">                   );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 两条关于 <code>全称量词和特称量词</code> 的 <code>等价性规则</code>：</p>
<ul>
<li><code>= some</code> 等价于 <code>in</code>，但 <code>&lt;&gt; some</code> 不等价于 <code>not in</code></li>
<li><code>&lt;&gt;all</code> 等价于 <code>not in</code>，但 <code>= all</code> 不等价于 <code>in</code></li>
</ul>
</blockquote>
<ul>
<li><code>exists</code></li>
</ul>
<p><code>exists</code>：若 <code>作为exists参数的子查询</code> 产生的 <code>结果关系</code> 是 <code>非空的</code>时，则返回 <code>true</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> section <span class="keyword">AS</span> T</span><br><span class="line">           <span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">           <span class="keyword">AND</span> S.course_id <span class="operator">=</span> T.course_id;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 该例子中，还有一个需要注意的地方：我们在 <code>子查询</code> 中 <code>引用</code> 了 <code>子查询外部的标识符</code> <code>S.course_id</code>。</p>
<p>我们称 <code>这样的子查询</code> 为 <code>相关子查询 (Correlated Subquery)</code>：使用了 <code>来自外层查询的相关名称</code> 的 <code>子查询</code></p>
<blockquote>
<p>关于 <code>子查询</code> 中对 <code>标识符</code> 的 <code>引用规则</code>，可以类比于 <code>PL中的变量作用域规则</code></p>
</blockquote>
</blockquote>
<hr>
<p><code>not exists</code> 可以用于 <code>测试</code> <code>子查询的结果集</code> 中 <code>是否不存在元组</code>。</p>
<p>我们可以利用这个 <code>特性</code> 来模拟 <code>集合的包含关系</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- use not exists to represent subset relationship</span></span><br><span class="line"><span class="keyword">SELECT</span> S.ID, S.name</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    (<span class="keyword">SELECT</span> course_id</span><br><span class="line">     <span class="keyword">FROM</span> course</span><br><span class="line">     <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">    ) </span><br><span class="line">    <span class="keyword">EXCEPT</span></span><br><span class="line">    (<span class="keyword">SELECT</span> T.course_id</span><br><span class="line">     <span class="keyword">FROM</span> takes <span class="keyword">AS</span> T</span><br><span class="line">     <span class="keyword">WHERE</span> S.ID <span class="operator">=</span> T.ID</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unique</code></li>
</ul>
<p><code>unique</code>：若 <code>作为unique参数的子查询</code> 产生的 <code>结果关系</code> 中 <code>不存在重复元组</code>，则返回 <code>true</code>。它为 <code>空集</code> 返回 <code>true</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T.course_id</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">UNIQUE</span>(<span class="keyword">SELECT</span> R.course_id</span><br><span class="line">            <span class="keyword">FROM</span> section <span class="keyword">AS</span> R</span><br><span class="line">             <span class="keyword">WHERE</span> T.course_id <span class="operator">=</span> R.course_id</span><br><span class="line">             <span class="keyword">AND</span> R.year <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，可以利用 <code>count()</code> 将 <code>exists</code> ，<code>not exists</code> ，<code>unique</code> 和 <code>not unique</code> 进行 <code>宏展开</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T.course_id</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(R.course_id)</span><br><span class="line">            <span class="keyword">FROM</span> section <span class="keyword">AS</span> R</span><br><span class="line">            <span class="keyword">WHERE</span> T.course_id <span class="operator">=</span> R.course_id</span><br><span class="line">            <span class="keyword">AND</span> R.year <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">           )</span><br></pre></td></tr></table></figure>

<p>解释：<code>WHERE子句</code> 将对 <code>T关系中的每个元组</code> 进行 <code>测试</code>，判断 <code>嵌套子查询</code> 中 <code>与该元组相等的元组的个数</code> 是否 <code>小于等于1</code></p>
<blockquote>
<p>该例子中，通过 <code>course_id</code> 作为 <code>主键</code> 来判断 <code>两个元组是否相等</code>。</p>
<p>而 <code>AND R.year = 2009</code> 仅仅是 <code>附加的过滤条件</code></p>
</blockquote>
</blockquote>
<blockquote>
<p>n.b. <code>unique</code> 判断 <code>元组是否重复</code> 是基于 <code>元组的相等性测试</code> 的。故如果 <code>两个元组中的某个元组的某个属性</code> 为 <code>null</code>，则 <code>这两个元组</code> <code>不相等</code>。</p>
<p>换句话说，使用 <code>unique</code> 判断 <code>某些属性为空的元组</code> 是否 <code>重复</code> 是错误的：</p>
<p>在这种情况下，尽管 <code>某个元组确确实实有多个副本</code>，但 <code>该元组有一个属性为空</code>，则 <code>元组的相等性测试</code> 将永远为 <code>false</code>，进而使得 <code>unique</code> 永远返回 <code>true</code></p>
</blockquote>
<ul>
<li><code>FROM子查询</code></li>
</ul>
<p>可以利用 <code>FROM子查询</code> 来 <code>去除</code> <code>HAVING子句</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 1</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">avg</span>(salary) <span class="operator">&gt;</span> <span class="number">42000</span>;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Query 2</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> dept_name, <span class="built_in">avg</span>(salary)</span><br><span class="line">     <span class="keyword">FROM</span> instructor</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name) <span class="keyword">AS</span> dept_avg(dept_name, avg_salary)</span><br><span class="line"><span class="keyword">WHERE</span> avg_salary <span class="operator">&gt;</span> <span class="number">42000</span>; </span><br></pre></td></tr></table></figure>

<p>该 <code>转化</code> 的思想在于：<code>HAVING子句</code> 实际上的 <code>执行时机</code> 是在 <code>GROUP BY产生结果关系之后</code>，再对 <code>结果关系(也就是一些分组)</code> 进行 <code>过滤</code>。</p>
<p>因此，我们可以 <code>先获得作为结果关系的这些分组</code>，然后再 <code>对这些分组进行过滤</code>。</p>
<ul>
<li><code>WITH子句</code></li>
</ul>
<p><code>WITH子句</code>：用于定义 <code>仅对包含with子句的查询可见</code> 的 <code>临时关系</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> dept_total(dept_name, <span class="keyword">value</span>) <span class="keyword">AS</span> (<span class="keyword">SELECT</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line">                                     <span class="keyword">FROM</span> instructor</span><br><span class="line">                                     <span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name),</span><br><span class="line">dept_total_avg(<span class="keyword">value</span>) <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">                             <span class="keyword">FROM</span> dept_total)</span><br><span class="line"><span class="keyword">SELECT</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> dept_total, dept_total_avg</span><br><span class="line"><span class="keyword">WHERE</span> dept_total.value <span class="operator">&gt;=</span> dept_total_avg.value;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 使用 <code>WITH子句</code> 可以 <code>非常有效地</code> 去除 <code>嵌套子查询</code>。</p>
<p>如果可能，<code>应当尽量使用WITH子句来消除嵌套子查询</code></p>
</blockquote>
<ul>
<li><code>标量子查询 (Scalar Subquery)</code></li>
</ul>
<p><code>SQL</code> 会 <code>自动地</code> 将 <code>仅含有单属性单元组的关系</code> <code>解包</code>为 <code>单个值</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">               <span class="keyword">FROM</span> instructor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n.b. 从 <code>本质</code> 上来说， <code>标量子查询</code> 返回的 <code>数据类型</code> 是确确实实的 <code>关系</code>。</p>
<p>只不过，在 <code>SQL</code> 实现中可以自动地 <code>对这种类型的关系</code> 进行 <code>拆包</code>。这类似于 <code>Java</code> 中的 <code>Auto Boxed/Unboxed</code></p>
<p><code>SQL编译器</code> 并无法 <code>检测</code> <code>标量子查询</code> 是否真的符合要求。</p>
<p>如果在 <code>运行时</code> 发现 <code>需要输入单个值的地方</code> 所使用的 <code>标量子查询</code> 包含 <code>多个值</code>，则会导致 <code>运行时错误</code></p>
</blockquote>
<h3 id="Modifying-Operation"><a href="#Modifying-Operation" class="headerlink" title="Modifying Operation"></a>Modifying Operation</h3><h3 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h3><p>考虑该例子的 <code>语句执行顺序</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This is a wrong example</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">               <span class="keyword">FROM</span> instructor)</span><br></pre></td></tr></table></figure>

<p>请注意，<code>我们所编写的SQL语句</code> 应当 <code>满足</code> ：在该语句进行 <code>修改性操作</code> 之前，必须先 <code>测试所有的元组</code>，将 <code>符合测试条件的元组</code> 加入到 <code>待删除列表</code>，之后再 <code>一次性地</code> 执行 <code>修改性操作</code>。</p>
<p>注意：这里所说的 <code>修改性操作</code> 不仅仅是指 <code>Delete</code>，包括 <code>Insert</code> 和 <code>Alter</code> 都有 <code>类似的问题</code></p>
<blockquote>
<p>该问题类似于 <code>ArrayList的并发修改问题</code>，当我们对 <code>正在遍历中的列表</code> 进行 <code>修改性操作</code> 时，必须保证 <code>最终的效果</code> 不依赖于 <code>修改性操作所执行的顺序</code></p>
</blockquote>
<blockquote>
<p>给出 <code>MySQL 8.0</code> 以上版本将 <code>拒绝执行该语句</code> 并且 <code>返回错误</code></p>
<p>1093 - You can’t specify target table ‘instructor’ for update in FROM clause</p>
</blockquote>
<h3 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h3><p>常用的插入操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course(course_id, title, dept_name, credits)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;CS-437&#x27;</span>, <span class="string">&#x27;Database Systems&#x27;</span>, <span class="string">&#x27;Comp. SCi.&#x27;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> instructor</span><br><span class="line"><span class="keyword">SELECT</span> ID, name, dept_name, <span class="number">18000</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span> <span class="keyword">AND</span> total_cred <span class="operator">&gt;</span> <span class="number">144</span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This is a wrong example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>

<p>该语句 <code>可能会导致无限递归插入</code>，这取决于 <code>数据库的具体实现</code>。</p>
<blockquote>
<p>经过实际测试，<code>MySQL 8.0</code> 以上可以 <code>正常地执行该语句</code>，并且 <code>查询会终止</code>。</p>
<p>它的 <code>语义</code> 为：将 <code>表中的所有元组</code> 按照 <code>顺序</code> <code>克隆一份插入到表的末尾</code></p>
<p><img src="https://s2.loli.net/2022/04/28/UDCi95xnFNvL6GW.png" alt="image-20220428194552573"></p>
<p><img src="https://s2.loli.net/2022/04/28/rmL13RFyhHCZdbW.png" alt="image-20220428194617665"></p>
</blockquote>
<h3 id="Alter-1"><a href="#Alter-1" class="headerlink" title="Alter"></a>Alter</h3><p>当 <code>update语句</code> 之间 <code>受语句执行顺序</code> 所 <code>影响</code> 时，可以使用 <code>case结构</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL 2</span></span><br><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<p>为了 <code>正确地表达语义</code>，我们可以使用 <code>case</code> 结构来 <code>正确表述执行顺序之间相互影响的语句</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="keyword">CASE</span></span><br><span class="line">             <span class="keyword">WHEN</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line">             <span class="keyword">ELSE</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line">             <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/27/greedy-oiling-car-optimal-merge/" rel="prev" title="Greedy - Oiling Car & Optimal Merge">
      <i class="fa fa-chevron-left"></i> Greedy - Oiling Car & Optimal Merge
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/29/database-intermediate-sql/" rel="next" title="Database - Intermediate SQL">
      Database - Intermediate SQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Elementary-SQL"><span class="nav-number">1.</span> <span class="nav-text">Elementary SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Primitive-Type"><span class="nav-number">1.1.</span> <span class="nav-text">Primitive Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Define-a-Database-Pattern"><span class="nav-number">1.2.</span> <span class="nav-text">Define a Database Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#General-Form"><span class="nav-number">1.2.1.</span> <span class="nav-text">General Form</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example"><span class="nav-number">1.2.2.</span> <span class="nav-text">Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-DML"><span class="nav-number">1.3.</span> <span class="nav-text">Basic DML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert"><span class="nav-number">1.3.1.</span> <span class="nav-text">Insert</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Delete"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Alter"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Alter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Structure"><span class="nav-number">1.4.</span> <span class="nav-text">Basic Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-Relation-query"><span class="nav-number">1.4.1.</span> <span class="nav-text">Single-Relation query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-Relation-query"><span class="nav-number">1.4.2.</span> <span class="nav-text">Multi-Relation query</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#General-Form-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">General Form</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Match-Condition-Specified-by-Where-Clause"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Match Condition Specified by Where Clause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Match-Condition-Specified-by-Natural-Join"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Match Condition Specified by Natural Join</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Natural-Join-Compare-all-the-common-attributes"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">Natural Join: Compare all the common attributes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Natural-Join-Specify-specific-common-attributes"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">Natural Join: Specify specific common attributes</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Operation"><span class="nav-number">1.5.</span> <span class="nav-text">Basic Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rename-Operation"><span class="nav-number">1.5.1.</span> <span class="nav-text">Rename Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-Operation"><span class="nav-number">1.5.2.</span> <span class="nav-text">String Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pattern-Matching"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Pattern Matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Escape-Character"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Escape Character</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Order-Operation"><span class="nav-number">1.5.3.</span> <span class="nav-text">Order Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Between-Operation"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">Between Operation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multi-Dimensional-Tuple"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">Multi-Dimensional Tuple</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-Operation"><span class="nav-number">1.5.4.</span> <span class="nav-text">Set Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Intersect-Operation"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">Intersect Operation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Union-Operation"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">Union Operation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Except-Operation"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">Except Operation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null"><span class="nav-number">1.6.</span> <span class="nav-text">Null</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-type-of-operation-involved"><span class="nav-number">1.6.1.</span> <span class="nav-text">The type of operation involved</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Equality-Test"><span class="nav-number">1.6.2.</span> <span class="nav-text">Equality Test</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Aggregate-Function"><span class="nav-number">1.7.</span> <span class="nav-text">Aggregate Function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Aggregate"><span class="nav-number">1.7.1.</span> <span class="nav-text">Basic Aggregate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Grouped-Aggregate"><span class="nav-number">1.7.2.</span> <span class="nav-text">Grouped Aggregate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Grouped-Aggregate-with-Having-Clause"><span class="nav-number">1.7.3.</span> <span class="nav-text">Grouped Aggregate with Having Clause</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nested-Subquery"><span class="nav-number">1.8.</span> <span class="nav-text">Nested Subquery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Modifying-Operation"><span class="nav-number">1.8.1.</span> <span class="nav-text">Modifying Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delete-1"><span class="nav-number">1.8.2.</span> <span class="nav-text">Delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert-1"><span class="nav-number">1.8.3.</span> <span class="nav-text">Insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alter-1"><span class="nav-number">1.8.4.</span> <span class="nav-text">Alter</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

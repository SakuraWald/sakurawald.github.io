<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sakurawald.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Graph BasicsGraphDefinitionConcepts图的阶 &#x3D;V  若存在边\alpha &#x3D; \{x, y\} &#x3D; \{y,x\} ，则：  \alpha连接 (join) 顶点x和顶点y 顶点x和顶点y是邻接 (adjacent)的。 顶点x和边\alpha是关联的。   顶点点x：我们给每一个顶点x取一个不同的点（用该顶点来标记顶点点） 边曲线\">
<meta property="og:type" content="article">
<meta property="og:title" content="Combinatorics - Graph Basics">
<meta property="og:url" content="https://sakurawald.github.io/2022/04/10/combinatorics-graph-basics/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:description" content="Graph BasicsGraphDefinitionConcepts图的阶 &#x3D;V  若存在边\alpha &#x3D; \{x, y\} &#x3D; \{y,x\} ，则：  \alpha连接 (join) 顶点x和顶点y 顶点x和顶点y是邻接 (adjacent)的。 顶点x和边\alpha是关联的。   顶点点x：我们给每一个顶点x取一个不同的点（用该顶点来标记顶点点） 边曲线\">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-10T18:40:20.000Z">
<meta property="article:modified_time" content="2023-01-01T23:38:44.215Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sakurawald.github.io/2022/04/10/combinatorics-graph-basics/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Combinatorics - Graph Basics | SakuraWald</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SakuraWald</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sakurawald.github.io/2022/04/10/combinatorics-graph-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SakuraWald">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Combinatorics - Graph Basics
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-10 18:40:20" itemprop="dateCreated datePublished" datetime="2022-04-10T18:40:20+00:00">2022-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:38:44" itemprop="dateModified" datetime="2023-01-01T23:38:44+00:00">2023-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uncategorized/" itemprop="url" rel="index"><span itemprop="name">uncategorized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Graph-Basics"><a href="#Graph-Basics" class="headerlink" title="Graph Basics"></a>Graph Basics</h1><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p><code>图的阶</code> &#x3D;V</p>
<hr>
<p>若存在<code>边</code>\alpha &#x3D; \{x, y\} &#x3D; \{y,x\} ，则：</p>
<ul>
<li>\alpha<code>连接 (join)</code> <code>顶点</code>x和<code>顶点</code>y</li>
<li><code>顶点</code>x和<code>顶点</code>y是<code>邻接 (adjacent)</code>的。</li>
<li><code>顶点</code>x和<code>边</code>\alpha是<code>关联的</code>。</li>
</ul>
<hr>
<p><code>顶点点</code>x：我们给<code>每一个顶点x</code>取一个<code>不同的点</code>（用该<code>顶点</code>来标记<code>顶点点</code>）</p>
<p><code>边曲线</code>\alpha：两个<code>顶点点</code>之间能通过<code>一条简单曲线</code>连接起来，当且仅当，<code>所对应的顶点对</code>确定<code>G的一条边</code>\alpha</p>
<blockquote>
<p>一条<code>边曲线</code>\alpha通过一个<code>顶点点</code>x，当且仅当，<code>顶点</code>x是<code>边</code>\alpha的一个<code>顶点</code></p>
</blockquote>
<hr>
<p><code>多重图</code>：允许<code>顶点</code>之间形成<code>多条边</code></p>
<blockquote>
<p>换句话说，图的<code>边集</code>E是<code>多重集合</code></p>
</blockquote>
<p><code>一般图</code>：允许<code>图</code>中存在<code>环</code></p>
<blockquote>
<p>我们说的<code>图</code>通常就是指<code>一般图</code></p>
</blockquote>
<blockquote>
<p>可以将<code>环</code>视为<code>一个顶点重复两次而构成的多重集合</code></p>
</blockquote>
<p><code>简单图</code>：所有<code>边</code>的<code>重数</code>均为<code>1</code>的图</p>
<p><code>完全图</code>K_n：<code>每一对不同的顶点之间</code>都有<code>边</code></p>
<blockquote>
<p>一个<code>n阶完全图</code>存在\frac{n(n-1)}{2}条<code>边</code></p>
</blockquote>
<p><code>平面图</code>：如果<code>一般图</code>可以在<code>平面</code>上画出它的图形，使得<code>任意两条边</code>仅在<code>顶点点</code>处<code>相交</code>，则称为<code>平面图</code></p>
<p><code>同构图</code>：给定<code>图</code>G &#x3D; (V, E)和<code>图</code>G’ &#x3D; (V’, E’)，如果\theta: V \rightarrow V’和\delta: E \rightarrow E’是<code>双射</code>，则称这两个图是<code>同构的</code></p>
<p><code>连通图</code>：如果<code>一般图</code>中的<code>任何一对顶点</code>x<code>和</code>y，都存在<code>连接x和y的路径</code>，则称该图是<code>连通的 (Connected)</code>，否则该图即为<code>非连通的 (Disconnected)</code></p>
<p><code>二分图</code>：可以将<code>图</code>G的<code>顶点集</code>V<code>划分</code>为<code>X和Y两个部分</code>，且<code>图</code>G的<code>边集</code>E中的任何一条边满足：<code>一个端点在X部分</code>，<code>另一个端点在Y部分</code></p>
<hr>
<p><code>顶点的度数 (次数)</code>deg(x)：与<code>顶点</code>相<code>关联</code>的<code>边</code>的数目。</p>
<blockquote>
<p>一个<code>环</code>对度数的贡献为<code>2</code></p>
</blockquote>
<p><code>图的度序列</code>：以<code>递减顺序给出的图G的所有顶点的度数的数列</code> (d_1,d_2,\cdots,d_n), \quad d_1 \ge d_2 \ge \cdots d_n \ge 0</p>
<hr>
<p><code>途径 (Walk)</code>：形如\s{x_0, x_1},\s{x_1,x_2}, \cdots, \s{x_{m-1}, x_{m}}的m条<code>边的序列</code></p>
<blockquote>
<p>上述是一种<code>以边表示法</code>，也可以用<code>以顶点表示法</code>：x_0 - x_1 - x_2 - \cdots - x_m</p>
</blockquote>
<blockquote>
<p><code>途径</code>中可以有<code>重复边</code>：</p>
<blockquote>
<p><code>重复边</code>：如果<code>一条边</code>在<code>一条途径</code>中<code>出现的次数</code>不超过<code>边的重数</code>，则<code>该边</code>不能算作<code>重复边</code></p>
<blockquote>
<p>一种观点：可以考虑<code>图的图形</code>，如果我们<code>没有用尽顶点对之间的所有边曲线</code>，则不能称为<code>重复边</code></p>
</blockquote>
<blockquote>
<p>推而广之：如果<code>图中所有的边都只出现1次</code>，那么我们认为<code>当图中任何一条边达到2次</code>就可以算作<code>重复边</code>，否则不算重复边。</p>
</blockquote>
<blockquote>
<p>注意：在某些情况下，我们说<code>图有重边</code>指的含义是<code>只要图中任何两个顶点对之间</code>存在<code>1条以上的边</code>。</p>
<p>这和我们此处所说的概念不同。这里的<code>重复边</code>是对<code>途径</code>而言的，而不是对<code>图</code>而言的。</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>迹 (Trail)</code>：不含<code>重复边</code>的<code>途径</code></p>
<blockquote>
<p>另一种说法：边的<code>出现次数</code>不超过<code>重数</code>的<code>途径</code></p>
</blockquote>
<p><code>路径 (Path)</code>：除了<code>起点</code>和<code>终点</code>外的<code>所有的顶点</code>都不相同的<code>途径</code></p>
<p><code>圈 (Cycle)</code>：<code>封闭的路径</code></p>
<hr>
<p><code>距离 (Distance)</code>d(x,y)：在<code>连通图</code>中，表示<code>连接</code> <code>顶点</code>x和<code>顶点</code>y的<code>途径</code>的<code>最短长度</code></p>
<blockquote>
<p>容易知道d(x,x) &#x3D; 0 ，而且显然<code>距离为</code>d(x,y)<code>的途径</code>必定是<code>一条路径</code></p>
<blockquote>
<p>不要考虑<code>零权重</code>边！</p>
</blockquote>
</blockquote>
<hr>
<p>若有<code>图</code>G &#x3D; (V, E)</p>
<p><code>子图</code>：若V’ \subseteq V, E’ \subseteq E，则<code>图</code>G’ &#x3D; (V’, E’)称为<code>图G的子图</code></p>
<p><code>导出子图 (Induced Subgraph)</code>：若\b{V’ \subseteq V}, E’ &#x3D; \s{(x,y) x, y \in V’ , (x, y) \in E}，则<code>图</code>G’ &#x3D; (V’, E’)称为<code>图G的导出子图</code></p>
<p><code>生成子图 (Spanning Subgraph)</code>：若\b{V’ &#x3D; V}, E’ &#x3D; \s{(x,y)x,y\in V’, (x,y) \in E}，则<code>图</code>G’ &#x3D; (V’, E’)称为<code>图G的生成子图</code></p>
<hr>
<p><code>连通分量 (Connected Component)</code>：<code>最大的连通的导出子图</code></p>
<hr>
<p><code>悬挂顶点 (Pendent Vertex)</code>：图G中<code>度数为1</code>的<code>顶点</code></p>
<p><code>悬挂边 (Pendent Edge)</code>：与<code>悬挂顶点</code>相<code>邻接</code>的<code>边</code></p>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-1-Handshake-Theorem"><a href="#Theory-1-Handshake-Theorem" class="headerlink" title="Theory 1: Handshake Theorem"></a>Theory 1: Handshake Theorem</h4><blockquote>
<p>这个结论隐含着推论：所有的<code>奇度数顶点</code>的个数必定是<code>偶数</code></p>
</blockquote>
<hr>
<p>1条<code>边</code>必定<code>连接</code> <code>2个顶点</code>，而1个<code>环</code>对<code>度数</code>的贡献为<code>2</code>。</p>
<p>Q.E.D</p>
<h4 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory 2"></a>Theory 2</h4><p>两个<code>同构的一般图</code>具有相同的<code>度序列</code>，但具有<code>相同的度序列</code>的<code>图</code>不一定是<code>同构</code>的。</p>
<h4 id="Theory-3"><a href="#Theory-3" class="headerlink" title="Theory 3"></a>Theory 3</h4><p>若<code>图</code>G &#x3D; (V,E)是<code>一般图</code>，则<code>顶点集</code>V可以被<code>唯一地划分</code>为<code>非空子集</code>V_1, V_2, \cdots V_k满足：</p>
<ol>
<li>分别<code>由</code>V_1, V_2, \cdots, V_k<code>所给的导出子图</code>G_1&#x3D;(V_1, E_1), G_2 &#x3D; (V_2, E_2), \cdots, G_k&#x3D;(V_k, E_k)都是<code>连通的</code></li>
</ol>
<hr>
<h4 id="Theory-4"><a href="#Theory-4" class="headerlink" title="Theory 4"></a>Theory 4</h4><p><code>同构图</code>本质上是<code>相同的图</code></p>
<h2 id="Euler-Trails-Bridges-of-Koenigsberg"><a href="#Euler-Trails-Bridges-of-Koenigsberg" class="headerlink" title="Euler Trails: Bridges of Koenigsberg"></a>Euler Trails: Bridges of Koenigsberg</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>如果<code>图</code>G中的一条<code>闭迹 (Closed Trail)</code> 包含了<code>G中所有的边</code> <code>有且仅有1次</code>，则称之为<code>欧拉迹 (Euler Trail)</code></p>
<blockquote>
<p>注意我们之前对<code>重复边</code>的定义。</p>
</blockquote>
<h3 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory 1"></a>Theory 1</h4><p>设<code>图</code>G &#x3D; (V,E)是<code>一般图</code>，如果它的<code>每个顶点的度数</code>都是<code>偶数</code>，则<code>G的每条边</code>都属于<code>一条欧拉闭迹</code>，因而也属于一个<code>圈</code></p>
<hr>
<ul>
<li>必要条件：每个顶点的度数均为偶数</li>
</ul>
<p>我们考虑<code>欧拉迹</code>中的<code>某个顶点</code>，我们需要<code>进入这个顶点</code>，然后<code>离开这个顶点</code>。</p>
<blockquote>
<p>如果是<code>欧拉圈</code>，则<code>刚开始离开起点</code>，<code>最终进入起点</code>。</p>
<p>如果是<code>欧拉迹</code>，则<code>刚开始离开起点</code>，<code>最终进入终点但不再离开终点</code></p>
</blockquote>
<p>则意味着，我们需要<code>一条进入该顶点的边</code>和<code>一条离开该顶点的边</code>。</p>
<p>换句话说，<code>每个顶点的度数</code>均为<code>偶数</code>。</p>
<ul>
<li>寻找包含初始边的一条<code>欧拉闭迹</code>的方法</li>
</ul>
<ol>
<li><p>令 i &#x3D; 1</p>
</li>
<li><p>令 W &#x3D; \s{x_0, x_1}</p>
</li>
<li><p>令 F &#x3D; \s{\alpha_1 &#x3D; \s{x_0, x_1}}</p>
</li>
<li><p>当x_i \ne x_0时，执行：</p>
<ol>
<li>找出一条<code>不在F中的边</code>\alpha_{i+1} &#x3D; \s{x_i, x_{i+1}}</li>
<li>将x_{i+1}放入W中（有可能x_{i+1}已经在W中）</li>
<li>将\alpha_{i+1}放入F中</li>
<li>令i &#x3D; i + 1</li>
</ol>
</li>
</ol>
<hr>
<ul>
<li><p>初始化：算法将<code>初始边</code>\alpha_1加入到F中，同时将<code>与该边关联的2个顶点</code>加入到W中</p>
</li>
<li><p>持续：如果x_i \ne x_0，则我们<code>必定</code>可以找到一条边\alpha_{i+1} &#x3D; \s{x_i, x_{i+1}}</p>
<blockquote>
<p>如果<code>i的最终值为k</code>，则<code>所产生的顶点集</code>W &#x3D; \s{x_0, x_1, \cdots, x_k}，<code>所产生的边集</code>F &#x3D; \s{\alpha_1, \cdots, \alpha_k}，则\alpha_1,\cdots,\alpha_k就是<code>包含初始边</code>\alpha_1<code>的一条闭迹</code>。</p>
<blockquote>
<p>\alpha_1 &#x3D; \alpha_ k</p>
</blockquote>
<hr>
<p>只需证明：若x_i \ne x_0，则必有<code>一条不在F中的边</code>与x_i<code>关联</code>。</p>
<blockquote>
<p>利用<code>握手定理</code>：在整个算法过程中，只有<code>顶点</code>x_0和<code>最新加入的顶点</code>x_i是<code>奇度数</code>。</p>
<p>如果x_0和x_i 是<code>偶度数</code>，则必定是x_0 &#x3D; x_i</p>
<p>如果x_0 \ne x_i，则x_i是<code>奇度数</code>，那么<code>必定</code> <code>还有另一个顶点与</code>x_i<code>相邻接</code></p>
</blockquote>
</blockquote>
</li>
<li><p>终止：所得到的F &#x3D; \s{\alpha_1, \cdots, \alpha_k}即为一条<code>包含初始边</code>的<code>闭迹</code></p>
</li>
</ul>
<h4 id="Theory-2-Euler’s-One-Stroke-Theorem"><a href="#Theory-2-Euler’s-One-Stroke-Theorem" class="headerlink" title="Theory 2: Euler’s One-Stroke Theorem"></a>Theory 2: Euler’s One-Stroke Theorem</h4><hr>
<ul>
<li><p>必要性：根据前面的分析。如果<code>图G</code>中存在<code>欧拉闭迹</code>，则<code>图G</code>的<code>每个顶点</code>的度数都是偶数。Q.E.D</p>
</li>
<li><p>充分性：</p>
<ol>
<li><p>设G_1 &#x3D; (V, E_1) &#x3D; G，选定G_1中的<code>任意一条边</code>\alpha_1作为<code>求包含初始边的欧拉闭迹的算法</code>的<code>初始边</code>，得到<code>包含边</code>\alpha_1<code>的闭迹</code>\gamma_1。</p>
</li>
<li><p>设G_2 &#x3D; (V, E_1 - \gamma_1)，则G_2<code>中的所有顶点</code>的度数<code>仍然是偶数！</code>，<code>由于</code>G<code>是连通的</code>，所以G_2如果存在边，则<code>至少有一条边</code>\alpha_2与<code>闭迹</code>\gamma_1<code>中的某个顶点</code>z_1<code>相邻接</code>，则我们可以对G_2<code>中的边</code>\alpha_2运行<code>求包含初始边的欧拉闭迹的算法</code>，得到<code>包含边</code>\alpha_2<code>的闭迹</code>\gamma_2。然后，我们可以将\gamma_1和\gamma_2在<code>顶点</code>z_1处进行<code>拼接</code>：得到<code>包含</code>\gamma_1和\gamma_2的<code>欧拉闭迹</code>\gamma_1 \overset{z_1}{*} \gamma_2</p>
<blockquote>
<ul>
<li>如果图G的所有顶点的度数都是偶数的话，去掉1个欧拉闭迹，则所有顶点的度数仍为偶数。</li>
<li>如果图G不是连通的，则根本不存在<code>欧拉闭迹</code>；如果图G是连通的，则我们可以找到<code>欧拉闭迹中的某个顶点</code>作为<code>拼接点</code>（如果找不到该顶点说明剩余的图的边集为空）</li>
</ul>
</blockquote>
</li>
<li><p>…</p>
</li>
<li><p>最终，我们可以得到<code>包含图G中所有边的欧拉闭迹</code>：\gamma_1 \overset{z_1}{*} \gamma_2 \overset{z_2}{*} \cdots \overset{k-1}{*} \gamma_k</p>
</li>
</ol>
</li>
</ul>
<p>Q.E.D</p>
<h4 id="Theory-3-1"><a href="#Theory-3-1" class="headerlink" title="Theory 3"></a>Theory 3</h4><hr>
<blockquote>
<p><code>欧拉闭迹</code>要求<code>起始顶点</code>和<code>终止顶点</code>相同，而<code>欧拉开迹</code>则没有这个限制。</p>
<p>如果<code>起始顶点</code>和<code>终止顶点</code>不相同，则<code>除了这两个顶点是奇度数</code>之外，<code>其他所有的顶点</code>都应该是<code>偶度数</code>。</p>
<p>因此，可以在<code>欧拉闭迹</code>的基础上，修改<code>起点</code>和<code>终点</code>得到<code>欧拉开迹</code></p>
</blockquote>
<p>已知定理：如果<code>图G中所有的顶点的度数都是偶数</code>，则我们可以得到<code>一条包含图G中所有边的欧拉闭迹</code></p>
<p>现在，如果<code>图G中除了顶点u和顶点v这两个顶点是奇度数外，其余顶点都是偶度数顶点</code>，则我们可以添加<code>辅助边</code>\s{u,v}来<code>连接</code>这两个<code>奇度数顶点</code>，使得他们成为<code>偶度数顶点</code>，我们称该图为G’，则我们可以得到G’中<code>包含所有边的欧拉闭迹</code>，但由于<code>欧拉开迹不要求起点和终点相同</code>，则我们在这条<code>欧拉闭迹</code>的基础上<code>去除</code>这条<code>辅助边</code>，即可得到<code>欧拉开迹</code></p>
<p>Q.E.D</p>
<h4 id="Theory-4-Euler’s-N-Stroke-Theorem"><a href="#Theory-4-Euler’s-N-Stroke-Theorem" class="headerlink" title="Theory 4: Euler’s N-Stroke Theorem"></a>Theory 4: Euler’s N-Stroke Theorem</h4><p>设<code>图G</code>是一般连通图，设<code>G中奇度数顶点的个数 &gt; 0</code>，则<code>G的边</code>可以被划分为<code>m/2个开迹</code>，但不能被划分为<code>少于m/2个开迹</code></p>
<hr>
<p>归纳法：</p>
<ul>
<li>如果<code>奇度数顶点 = 1</code>：则根本不满足<code>握手定理</code>，不存在这样的图。满足\lfloor \frac{1}{2} \rfloor &#x3D; 0</li>
<li>如果<code>奇度数顶点 = 2</code>：则\frac{2}{2} &#x3D; 1，可以通过<code>加入</code>一条<code>连接这两个奇度数顶点的边</code>来得到<code>欧拉闭迹</code>，然后<code>去除该边</code>即为<code>欧拉开迹</code></li>
<li>如果<code>奇度数顶点 = 3</code>：同<code>奇度数顶点 = 1</code></li>
<li>如果<code>奇度数顶点 = 4</code>：重复<code>奇度数顶点 = 2</code>的步骤，得到<code>2条欧拉开迹</code>。</li>
</ul>
<p>…</p>
<blockquote>
<p>能完成<code>n笔画</code>的<code>充要条件</code>是：存在<code>n条</code>的<code>欧拉闭迹</code>或<code>欧拉开迹</code></p>
<blockquote>
<p>注：某些表述方法把<code>欧拉开迹</code>称为<code>欧拉路径</code>，将<code>欧拉闭迹</code>称为<code>欧拉回路</code>。他们是一样的概念</p>
</blockquote>
</blockquote>
<h4 id="Theory-5"><a href="#Theory-5" class="headerlink" title="Theory 5"></a>Theory 5</h4><p>设<code>图G</code>是有<code>K条边</code>的一般<code>连通图</code>，则G中存在<code>一条长度为2K的闭途径</code>：该途径中，<code>每条边的使用次数</code>是<code>它的重数</code>的<code>2倍</code></p>
<hr>
<ul>
<li>Proof 1</li>
</ul>
<p>对<code>任何一个顶点</code>使用<code>dfs遍历方法</code>，则<code>连通图G</code>中的<code>每一条边</code>均会被<code>dfs访问1次</code>，以及<code>回溯1次</code>。</p>
<p>这等价于<code>先走过这条边</code>，然后再<code>走回这条边</code></p>
<ul>
<li>Proof 2</li>
</ul>
<p>构造G’为将G中的<code>每条边</code>的<code>重数</code>增加<code>1倍</code>所得的图。则G’是有2K条边的连通图，且G’中存在<code>欧拉闭迹</code>，该<code>欧拉闭迹</code>就是G中的<code>一条闭路径</code></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Example-1-Bridges-of-Koenigsberg"><a href="#Example-1-Bridges-of-Koenigsberg" class="headerlink" title="Example 1: Bridges of Koenigsberg"></a>Example 1: Bridges of Koenigsberg</h4><h4 id="Example-2-Chinese-Postman-Problem"><a href="#Example-2-Chinese-Postman-Problem" class="headerlink" title="Example 2: Chinese Postman Problem"></a>Example 2: Chinese Postman Problem</h4><p>若<code>图G</code>是一般连通图，求使用图G的<code>每一条边</code> <code>至少1次</code>的<code>一条最短路径</code>。</p>
<h2 id="Hamiltonian-Path-and-Hamiltonian-Circuit"><a href="#Hamiltonian-Path-and-Hamiltonian-Circuit" class="headerlink" title="Hamiltonian Path and Hamiltonian Circuit"></a>Hamiltonian Path and Hamiltonian Circuit</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><p>若<code>图G</code>是简单图，能否<code>沿着G的边</code>确定一条路线：使得它从<code>G的某一顶点</code>出发，在访问<code>其他每一个顶点</code> <code>正好1次</code>之后，又<code>返回起点</code>？</p>
<blockquote>
<p><code>边的重复</code>并不会影响<code>哈密顿路径</code>或<code>哈密顿圈</code>的存在性，因为他们是针对<code>顶点</code>而定义的。</p>
</blockquote>
<blockquote>
<p><code>欧拉闭迹</code>：包含图G的每一条边恰好1次的<code>闭迹</code></p>
<p><code>哈密顿圈</code>：包含图G的每一条边恰好1次的<code>闭路径</code></p>
</blockquote>
<h3 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-1-1"><a href="#Theory-1-1" class="headerlink" title="Theory 1"></a>Theory 1</h4><p>K_n中存在n!条<code>哈密顿路径</code>，也存在n!个<code>哈密顿圈</code></p>
<hr>
<p>因为n个顶点中，可以从任何一个顶点到达任何一个其他顶点：<code>n个顶点的排列</code>一一对应于n!个<code>哈密顿路径</code>和<code>哈密顿圈</code></p>
<h4 id="Theory-2-1"><a href="#Theory-2-1" class="headerlink" title="Theory 2"></a>Theory 2</h4><p>带有<code>桥</code>的<code>阶</code>n \ge 3的<code>连通图</code>不存在<code>哈密顿圈</code></p>
<hr>
<p>归纳法：</p>
<p>设该<code>桥</code>\alpha &#x3D; \s{x, y}，则如果将<code>桥</code>删除，可以得到<code>2个连通分量</code>:G_1, G_2</p>
<p>不妨假设，我们的<code>哈密顿回路</code>的<code>起始顶点</code>在G_1，则我们需要通过<code>桥</code>\alpha到达G_2。</p>
<p>然后，我们<code>还必须重新返回位于</code>G_1<code>的起始顶点</code>，而这意味着，我们<code>必须再次经过桥</code>（因为<code>桥</code>\alpha是G_1和G_2之间穿越的唯一方法）</p>
<p>而这将不满足<code>哈密顿圈</code>的定义。</p>
<blockquote>
<p>实际上，它甚至也没有<code>欧拉闭迹</code></p>
</blockquote>
<p>Q.E.D</p>
<h4 id="Theory-3-Ore-Property"><a href="#Theory-3-Ore-Property" class="headerlink" title="Theory 3: Ore Property"></a>Theory 3: Ore Property</h4><p><code>Ore Propetry</code>：<code>图</code>G对所有<code>不邻接的不同顶点x，y的对</code>，有：deg(x) + deg(y) \ge n</p>
<p>若<code>图</code>G是满足<code>Ore Property</code>且<code>阶数</code>n \ge 3的简单图，则<code>图</code>G中存在<code>哈密顿圈</code></p>
<hr>
<ul>
<li>满足<code>Ore Property</code>的<code>图</code>G是<code>连通的</code></li>
</ul>
<p>假设<code>图G</code>是不连通的，则图G不可能满足<code>Ore Property</code>。</p>
<p>若将图G的<code>所有顶点</code>划分为两个子集U和W，使得图G中不存在<code>任何一条连接U中一个顶点和W中一个顶点的边</code>，</p>
<p>设U &#x3D; r, W &#x3D;s \implies r + s &#x3D; n</p>
<p>则deg(U) &#x3D; r - 1, deg(W) &#x3D; s - 1 \implies deg(G) &#x3D; r + s - 2 &#x3D; n - 2</p>
<p>与假设前提矛盾，故图G是连通的。</p>
<p>Q.E.D</p>
<hr>
<ul>
<li><p>寻找<code>哈密顿圈</code>的算法</p>
<ul>
<li><p>Step 1: 从<code>任意一个顶点</code>出发，在它的任意一端<code>邻接一个顶点</code>，构造一条越来越长的路径，直到该路径无法再加长为止：\gamma: y_1-y_2-\cdots-y_m</p>
</li>
<li><p>Step 2: 检查y_1和y_m是否<code>邻接</code></p>
<ul>
<li>Step 2-1 如果不邻接，跳转到Step3；否则，跳转到Step 2-2</li>
<li>Step 2-2 如果m&#x3D;n，则停止构造并输出<code>哈密顿圈</code>\b{y_1-y_2-\cdots-y_m-y_1}，否则，y_1和y_m是邻接的且m \lt n，转到Step 2-3</li>
<li>Step 2-3 找出一个<code>不在</code>\gamma<code>上的顶点</code>z和<code>在</code>\gamma<code>上的顶点</code>y_k，使得z和y_k邻接。将\gamma用下面的<code>长度为m+1的路径</code>来代替：\r{z}-\b{y_k}-\cdots-y_m-y_1-\cdots-\b{y_{k-1}} 并转回到Step 2-2</li>
</ul>
</li>
<li><p>Step 3: 找出一个<code>顶点</code>y_k (1 \lt k \lt m)，使得y_1和y_k邻接，且y_{k-1}和y_m邻接，将\gamma用下面的<code>路径</code>代替：\b{y_1} - \cdots - \b{y_{k-1} - b{y_m}} - \cdots -\b{y_k}</p>
<p>这条路径的两个端点y_1和y_k是邻接的，转回到Step 2-2</p>
</li>
</ul>
</li>
<li><p>证明：Step 2-3 必定能找到一个特定的顶点z</p>
</li>
</ul>
<p>因为有m \lt n且图是连通的，所以必定存在一个<code>不在路径</code>\gamma<code>上的顶点</code>z，它与y_1,\cdots,y_m中的某个顶点邻接。</p>
<ul>
<li>证明：Step3 必定能找到特定的顶点y_k</li>
</ul>
<p>已知y_1和y_m不邻接，设deg(y_1) &#x3D; r,deg(y_m) &#x3D; s \implies r + s \ge n</p>
<p>因为\gamma是<code>一条最长的路径</code>，所以y_1只能与\gamma<code>上的顶点</code>相邻接，即与\b{y_2,\cdots,y_{m-1}}中的r个顶点相邻接。</p>
<p>同理，y_m与\b{y_2,\cdots,y_{m-1}}中的s个顶点相邻接。</p>
<p><code>与</code>y_1<code>邻接的r个顶点中的每个顶点</code>都位于<code>路径</code>\gamma<code>上某个顶点的前面</code>，且在<code>这些顶点</code>中，<code>必定有一个</code>与y_m邻接。否则，y_m最多与(m-1)-r个顶点邻接，则s \le m - 1- r \implies \b{r + s \le m - 1 \le n - 1} 与Ore性质矛盾。</p>
<p>因此，<code>存在一个顶点</code>y_k：使得y_1与y_k邻接，且y_m与y_{m-1}邻接。</p>
<p>因此，算法在G中构造出一条哈密顿圈会后会停止。</p>
<h4 id="Theory-4-1"><a href="#Theory-4-1" class="headerlink" title="Theory 4"></a>Theory 4</h4><p>在<code>阶数</code>n \ge 3的简单图中，如果<code>每个顶点的度数</code>至少为n&#x2F;2，则图中必定存在<code>哈密顿圈</code></p>
<h4 id="Theory-5-1"><a href="#Theory-5-1" class="headerlink" title="Theory 5"></a>Theory 5</h4><p>在一个n阶简单图中，如果<code>每对不邻接的顶点</code>的<code>度数之和</code>至少为<code>n-1</code>，则图中存在<code>哈密顿路径</code></p>
<h2 id="Bipartite-Graph"><a href="#Bipartite-Graph" class="headerlink" title="Bipartite Graph"></a>Bipartite Graph</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><p>若G&#x3D;(V,E)是一个<code>多重图</code>，如果<code>顶点集V</code>可以被<code>划分</code>为两个子集<code>X</code>和<code>Y</code>，使得<code>G中的每一条边</code>都有<code>一个顶点在X</code>，<code>另一个顶点在Y</code>，</p>
<p>则我们称<code>图G</code>是<code>二分图</code>。</p>
<p><code>完全二分图</code>K_{m,n}：<code>二分图</code>的<code>X中的每个顶点</code>都与<code>Y中的每个顶点</code>相连。</p>
<h3 id="Theory-3"><a href="#Theory-3" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-1-2"><a href="#Theory-1-2" class="headerlink" title="Theory 1"></a>Theory 1</h4><p>一个<code>多重图</code>是<code>二分的</code>，当且仅当，<code>多重图的每一个圈的长度</code>均为<code>偶数</code></p>
<hr>
<p>若图G是有2划分X，Y的二分图，则<code>G中的一条途径上的顶点</code> 必<code>交替地</code>取自<code>X</code>和<code>Y</code>。</p>
<p>我们<code>假设</code>：<code>G中的每一个圈的长度均为偶数</code>，<code>G是连通的</code>，<code>x是G的任意一个顶点，X是由那些到x的距离为偶数的顶点构成的集合，Y是由那些到x的距离为奇数的顶点构成的集合</code></p>
<ul>
<li>假设：<code>图G是连通的</code>。则我们有<code>X + Y = V</code></li>
</ul>
<p>现在<code>证明：X，Y是一个2划分（即X中的任意两个顶点不邻接，Y中的任意两个顶点不邻接）</code></p>
<p>我们<code>反证假设：存在一条边&#123;a, b&#125;使得</code>a \in X, b \in X</p>
<p>我们设<code>从x到a的最短路径</code>\alpha: x-\cdots-a和<code>从x到b的最短路径</code>\beta:x-\cdots-b</p>
<p>由于\alpha和\beta拥有相同的起始顶点x，则我们不妨设<code>这两条途径中最后一个相同的顶点</code>z</p>
<p>从而，我们得到：\alpha: \b{x-\cdots-z}-\cdots-a和\beta:\b{x-\cdots-z}-\cdots-b</p>
<p><code>分解途径</code>得到：\alpha_1 &#x3D; \beta_1:x-\cdots-z</p>
<p>\alpha_2: z - \cdots-a和\beta_2: z- \cdots-b</p>
<p>所以，我们得到：\alpha_2和\beta_2的长度<code>要么都是奇数</code>，<code>要么都是偶数</code>。</p>
<p>而<code>边&#123;a, b&#125;的存在</code>意味着：图G中有<code>一个长度为奇数的圈</code>z-\cdots-\b{a-b}-\cdots-z</p>
<p>与假设矛盾。故：图G中不可能存在<code>连接X中顶点a和b的边&#123;a, b&#125;</code>。</p>
<p>同理，可证图G中不可能存在<code>连接Y中顶点a和b的边&#123;a, b&#125;</code></p>
<ul>
<li>假设：图G是不连通的。则只需用上述方式证明图G的每一个<code>连通分量</code>都是<code>二分的</code>，即可证明<code>图G</code>是<code>二分的</code></li>
</ul>
<h4 id="Theory-2-2"><a href="#Theory-2-2" class="headerlink" title="Theory 2"></a>Theory 2</h4><p>设G是有二划分的X，Y的二分图：</p>
<ul>
<li>若X \ne Y，则G中不存在<code>哈密顿圈</code>。</li>
<li>若X&#x3D;Y，则G中不存在<code>起始于X中的顶点 又 终止于X中的顶点的哈密顿路径</code></li>
<li>若\BigX - Y\Big \ge 2，则G中不存在<code>哈密顿路径</code></li>
<li>若X &#x3D; Y + 1，则G中不存在<code>起始于X又终止于Y的哈密顿路径</code></li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><h4 id="Example-1-Reflective-Gray-Code"><a href="#Example-1-Reflective-Gray-Code" class="headerlink" title="Example 1: Reflective Gray Code"></a>Example 1: Reflective Gray Code</h4><p><code>格雷码</code> \implies <code>哈密顿路径</code></p>
<p><code>反射格雷码</code> \implies <code>哈密顿圈</code></p>
<h4 id="Example-2-Board-Coloring-Problem"><a href="#Example-2-Board-Coloring-Problem" class="headerlink" title="Example 2: Board Coloring Problem"></a>Example 2: Board Coloring Problem</h4><h4 id="Example-3-The-vaulting-horse-problem"><a href="#Example-3-The-vaulting-horse-problem" class="headerlink" title="Example 3: The vaulting horse problem"></a>Example 3: The vaulting horse problem</h4><p><code>跳马路线</code>：能够让<code>马</code>落在<code>棋盘上的所有格子</code>恰好1次的路线。\implies <code>哈密顿路径</code></p>
<p><code>重复路线 (Reentrant)</code>：可以<code>循环的</code> <code>跳马路线</code> \implies <code>哈密顿圈</code></p>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition 1"></a>Definition 1</h4><p>n阶连通图<code>至少有n-1条边</code>。此外，对于每一个正整数n，存在<code>恰好n-1条边的连通图</code>。</p>
<p>从<code>恰好有n-1条边的n阶连通图</code>中去掉<code>任意一条边</code>，都会得到一个<code>非连通图</code>。</p>
<p>连通图G是树\iff所有边都是<code>桥</code></p>
<h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h4><p>连通图G是树\iff恰好有n-1 \quad(n \ge 1)条<code>边</code></p>
<hr>
<p>首先，我们先<code>去除连通图中的所有边，得到n个孤立的顶点，每个顶点对应着1个连同分量</code>。</p>
<p>于是，我们得到<code>n个连通分量</code>，接下来，我们<code>每加入1条边，就可以连接2个连同分量，使得图的连同分量数-1</code></p>
<p>因此，我们只需要加入<code>n-1条边</code>即可使得<code>图的连同分量数量减少至1</code>。Q.E.D</p>
<h4 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h4><blockquote>
<ul>
<li>Background</li>
</ul>
<p>设G是连通图，\alpha &#x3D; \s{x, y}是G的<code>桥</code>，当且仅当，<code>图G的任何圈</code>都不包含\alpha</p>
<hr>
<ul>
<li>充分性：若\alpha是桥，则图G被划分为两个连通分量，故图G的任何圈都不包含alpha</li>
<li>必要性：若\alpha不是桥，则图G中存在<code>包含</code>\alpha<code>的圈</code></li>
</ul>
</blockquote>
<p>连通图G是树\iffG中不包含<code>圈</code>。</p>
<h4 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition 4"></a>Definition 4</h4><p>连通图G是树\iff<code>每一对不同的顶点</code>x和y之间都有<code>唯一的一条路径</code></p>
<h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Theory-4"><a href="#Theory-4" class="headerlink" title="Theory"></a>Theory</h3><h4 id="Theory-1-3"><a href="#Theory-1-3" class="headerlink" title="Theory 1"></a>Theory 1</h4><p>设G是阶n \ge 2的树，则G中<code>至少有2个悬挂顶点</code></p>
<hr>
<p>设图G中的<code>度序列</code>为：d_1, d_2, \cdots, d_n</p>
<p>则：d_1 + d_2 + \cdots + d_n &#x3D; 2(n-1)</p>
<p>如果其中<code>最多有一个</code>d_i<code>等于1</code>，则：d_1 + d_2 + \cdots + d_n &#x3D; 1 + 2(n-1)</p>
<p>矛盾，故<code>树中至少有2个悬挂顶点</code></p>
<h4 id="Theory-2-3"><a href="#Theory-2-3" class="headerlink" title="Theory 2"></a>Theory 2</h4><p>每个<code>连通图</code>都有<code>生成树</code></p>
<hr>
<ul>
<li>求连通图的生成树的算法</li>
</ul>
<p>去除<code>连通图</code>中的所有<code>非桥边</code></p>
<h4 id="Theory-3-2"><a href="#Theory-3-2" class="headerlink" title="Theory 3"></a>Theory 3</h4><p>设<code>图T</code>是<code>连通图G</code>的一颗生成树。设\alpha &#x3D; \s{a,b}是G的一条边，但不是T的边，则T中存在一条边\beta，满足：</p>
<p>通过向T中加入<code>边</code>\alpha，并去掉<code>边</code>\beta，得到的<code>图T</code>仍然是<code>图G的生成树</code>。</p>
<hr>
<p>如果<code>边</code>\alpha &#x3D; \s{a,b}是<code>悬挂边</code>，则<code>图G的生成树</code>中必须要<code>加入</code>这条边，因为这是<code>唯一</code>连接<code>顶点a</code>和<code>顶点b</code>的边。</p>
<p>如果<code>图G的生成树</code>中没有<code>加入边</code>\alpha，说明<code>边</code>\alpha并不是<code>悬边</code>，我们有<code>其他的边</code>\beta来<code>连接</code> <code>顶点a</code>和<code>顶点b</code>，则我们可以用<code>其他的边</code>来<code>替代</code> <code>边</code>\alpha，反之亦然。</p>
<blockquote>
<p>实际上，<code>边</code>\alpha和<code>边</code>\beta应当属于 <code>同一个圈之中</code>，这意味着我们选择<code>边</code>\alpha或者<code>边</code>\beta都可以满足生成树的连通性。\square</p>
</blockquote>
<h4 id="Theory-4-2"><a href="#Theory-4-2" class="headerlink" title="Theory 4"></a>Theory 4</h4><p>设T_1和T_2是连通图G的两颗<code>生成树</code>，设\beta是T_1的一条边，则T_2中必有一条边\alpha，使得在T_1中加入\alpha而去掉\beta后，<code>得到的图</code>仍然是<code>图G的生成树</code>。</p>
<hr>
<ul>
<li><p>假设<code>极端情况</code>，如果<code>图G</code>本身就是<code>树</code>，那么<code>图G的所有生成树都相同 （实际上也就1种）</code>，即T_1 &#x3D; T_2，同时\alpha &#x3D; \beta</p>
</li>
<li><p>如果对于\beta &#x3D; \s{a,b}，T_1中存在\beta但T_2中不存在\beta，则说明\beta并不是<code>悬挂边</code>。</p>
</li>
</ul>
<p>对于T_2来说，它如果不选择加入\beta，则必须要选择<code>其他的边</code>\alpha来保证<code>顶点a</code>和<code>顶点b</code>之间的<code>连通性</code>。</p>
<p>而根据我们上面的推论，我们知道，<code>边</code>\alpha和<code>边</code>\beta实际上属于<code>同一个圈之中</code></p>
<blockquote>
<p>更直白的说法是：T_1和T_2同样都作为<code>生成树</code>，在T_1中加入\alpha而去除\beta的含义是：让<code>生成树</code>T_1 <code>照着模仿做 (do as others do)</code> <code>生成树</code>T_2是<code>如何满足顶点a和顶点b之间的连通性的</code>。</p>
</blockquote>
<h4 id="Theory-5-2"><a href="#Theory-5-2" class="headerlink" title="Theory 5"></a>Theory 5</h4><p><code>n阶图</code>的<code>生成树</code>数量为<code>该图的n-1阶拉普拉斯矩阵的任意子矩阵的行列式的绝对值</code></p>
<h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><h4 id="Model-1-Construct-Spanning-Tree"><a href="#Model-1-Construct-Spanning-Tree" class="headerlink" title="Model 1: Construct Spanning-Tree"></a>Model 1: Construct Spanning-Tree</h4><p>若G &#x3D; (V, E) 是<code>n阶图</code>，u \in V</p>
<ul>
<li><p>Step 1：U \dot{&#x3D;} \s{u}, F \dot{&#x3D;} \varnothing</p>
</li>
<li><p>Step 2：当\b{\exists x \in U \and y \notin U}, \alpha&#x3D;\s{x,y} \in E时</p>
<ul>
<li>\b{y \cup U}</li>
<li>\alpha \cup F</li>
<li>Goto Step 2</li>
</ul>
</li>
<li><p>Step 3：T \dot{&#x3D;} (\b{U &#x3D; V}, F)</p>
</li>
</ul>
<hr>
<ul>
<li>证明：<code>正在构建的生成树</code>T<code>永远不会存在环</code> （环的定义）</li>
</ul>
<p>该算法维护的<code>顶点集</code>U表示的是<code>正在构建的生成树的顶点集</code>。</p>
<p>我们是通过一个简单的<code>事实</code>来<code>避免正在构建的生成树</code>中<code>存在环</code>：在由顶点表示的途径中存在环，当且仅当，存在某个顶点出现重复。</p>
<p>所以，我们<code>的确可以始终保持正在构建的生成树</code>T中<code>不存在环</code>。</p>
<ul>
<li>证明：不断增加<code>顶点</code>，最终该算法会停止 （树的定义）</li>
</ul>
<p>我们注意到，我们每一次仅仅是<code>检查是否存在环的条件</code>，然后简单地<code>新增顶点，以及和该顶点相关联的边</code>。</p>
<p>由于<code>每次新增顶点时，必定新增1条边</code>，而当F &#x3D; E - 1时，T将是一颗<code>最终的生成树</code>。</p>
<blockquote>
<p>这取决于<code>树</code>的定义：<code>n个顶点的树</code>含有<code>n-1条边</code></p>
</blockquote>
<h4 id="Model-2-Construct-BFS-Spanning-Tree"><a href="#Model-2-Construct-BFS-Spanning-Tree" class="headerlink" title="Model 2: Construct BFS Spanning-Tree"></a>Model 2: Construct BFS Spanning-Tree</h4><blockquote>
<p><code>广度优先生成树 (BFS Spanning-Tree)</code>：该树以<code>初始顶点</code>u作为<code>根</code>，对于<code>每一个顶点</code>x来说：<code>x与u在G中的距离</code> &#x3D; <code>x与u在T中的距离</code></p>
<blockquote>
<p><code>bf(x)</code>：表示<code>顶点</code>x加入到<code>BFS树</code>中的<code>次序</code></p>
<p><code>D(x)</code>：表示<code>顶点x</code>和<code>顶点y</code>在<code>T</code>中的<code>距离</code></p>
</blockquote>
</blockquote>
<p>G \dot{&#x3D;} (V,E), V &#x3D; n, u \in V</p>
<ul>
<li><p>Step 1：\b{i \dot{&#x3D;}1, U \dot{&#x3D;} \s{u}, F \dot{&#x3D;} \varnothing, T \dot{&#x3D;} (U, F) }, \r{D(u) \dot{&#x3D;} 0, bf(u) \dot{&#x3D;} 1 }</p>
</li>
<li><p>Step 2：当\b{\exists x \in U \and y \notin U, \alpha&#x3D;\s{x,y} \in E} 时</p>
<ul>
<li>寻找\b{\alpha &#x3D; \s{x, y}}, \r{x \t{ has the min-imum } bf(x)}</li>
<li>\r{bf(y) &#x3D; i + 1}</li>
<li>\r{D(y) &#x3D; D(x) + 1}</li>
<li>y \cup U</li>
<li>\alpha &#x3D; \s{x,y} \cup F</li>
<li>\r{i &#x3D; i + 1}</li>
<li>Goto Step 2</li>
</ul>
</li>
<li><p>Step 3：T \dot{&#x3D;} (\b{U &#x3D; V}, F)</p>
</li>
</ul>
<blockquote>
<p>首先，我们这里所讨论的<code>BFS树的顶点之间的距离</code>指的是<code>两个顶点之间的边的条数</code>，而并没有额外地定义<code>边的权重</code></p>
</blockquote>
<blockquote>
<p>可以将<code>Construct BFS Spanning-Tree</code>看作是<code>一种不重复地搜索G的所有顶点的BFS方法</code></p>
</blockquote>
<h4 id="Model-3-Construct-DFS-Spanning-Tree"><a href="#Model-3-Construct-DFS-Spanning-Tree" class="headerlink" title="Model 3: Construct DFS Spanning-Tree"></a>Model 3: Construct DFS Spanning-Tree</h4><p>G \define \s{V, E}, V &#x3D; n, u \in V</p>
<ul>
<li><p>Step 1：\b{i \dot{&#x3D;}1, U \dot{&#x3D;} \s{u}, F \dot{&#x3D;} \varnothing, T \dot{&#x3D;} (U, F) }, \r{df(u) \dot{&#x3D;} 1 }</p>
</li>
<li><p>Step 2：当\b{\exists x \in U \and y \notin U, \alpha&#x3D;\s{x,y} \in E} 时</p>
<ul>
<li>寻找\b{\alpha &#x3D; \s{x, y}}, \r{x \t{ has the max-imum } df(x)}</li>
<li>\r{df(y) &#x3D; i + 1}</li>
<li>y \cup U</li>
<li>\alpha &#x3D; \s{x,y} \cup F</li>
<li>\r{i &#x3D; i + 1}</li>
<li>Goto Step 2</li>
</ul>
</li>
<li><p>Step 3：T \dot{&#x3D;} (\b{U &#x3D; V}, F)</p>
</li>
</ul>
<h4 id="Model-4-Construct-Distance-Spanning-Tree-Dijkstra"><a href="#Model-4-Construct-Distance-Spanning-Tree-Dijkstra" class="headerlink" title="Model 4: Construct Distance Spanning-Tree (Dijkstra)"></a>Model 4: Construct Distance Spanning-Tree (Dijkstra)</h4><blockquote>
<p><code>权重函数 (Weighted Function)</code>c：是定义在\alpha \rightarrow \real的函数。</p>
<blockquote>
<p>若<code>边</code>\alpha &#x3D; \s{x, y}，则<code>该边的权重</code>c(\alpha) &#x3D; c\s{x,y}</p>
<blockquote>
<p>平时我们将<code>两个顶点之间的距离</code>定义为<code>两个顶点之间的边的条数</code>，可以视为是<code>每条边的权重均为1的权重函数</code></p>
</blockquote>
<p>若<code>途径</code>\gamma: \s{x_0,x_1},\s{x_1,x_2},\cdots \s{x_{k-1},x_k}，则<code>该途径的权重</code>c(\gamma) &#x3D; c\s{x_0,x_1} + c\s{x_1,x_2} + \cdots + c\s{x_{k-1},x_k}</p>
</blockquote>
<p><code>距离 (Distance)</code>d_c\s{x,y}：指的是在<code>权重函数</code>c之上，<code>顶点x</code>和<code>顶点y</code>的<code>所有途径中的权重最小的途径的权重</code></p>
</blockquote>
<p>G \define (V, E), V &#x3D; n, u \in V</p>
<ul>
<li><p>Step 1：\b{U \define \s{u}, F \define \varnothing, T \define (U,F) },\r{D(u) \define 0}</p>
</li>
<li><p>Step 2：当\b{\exists x \in U \and y \notin U, \alpha &#x3D; \s{x, y} \in E}时</p>
<ul>
<li>寻找\b{\alpha &#x3D; \s{x,y},} \r{x,y \t{ has the min-imum } D(x) + c\s{x,y}}</li>
<li>y \cup U</li>
<li>\alpha &#x3D; \s{x,y}\ cup F</li>
<li>\r{D(y) &#x3D; D(x) + c\s{x,y}}</li>
<li>Goto Step 2</li>
</ul>
</li>
<li><p>Step 3：T \dot{&#x3D;} (\b{U &#x3D; V}, F)</p>
</li>
</ul>
<hr>
<p><code>反证假设: 结论不成立</code>\implies\b{\exists y \in V, D(y) \gt d\s{u,y}}</p>
<p>则<code>假设: y是第一个被放入U中的具有这样的性质的顶点</code>，则G中存在\gamma: \r{u &#x3D; x_0}-x_1-\cdots-\r{x_k &#x3D; y} 且D(y) \gt d\s{u,y}</p>
<p>设x_j是在y之前放入U中的<code>路径</code>\gamma<code>的最后一个顶点</code>，则D(x_j) &#x3D; d\s{u, x_j}</p>
<p>故\gamma’ \subset \gamma,\gamma’: \r{u &#x3D; x_0} - x_1 - \cdots - \r{x_{j}} - \c{hotpink}{x_{j+1}}</p>
<p>故<code>得出</code></p>
<p>但是，根据算法，x_{j+1}是在y<code>之前</code>被放入U中的，这与我们对x_j的选择矛盾。</p>
<p>而这意味着：\b{\forall y \in V, D(y) &#x3D; d\s{u, y}} 与<code>假设</code>发生<code>矛盾</code></p>
<h4 id="Model-5-Construct-Minimum-Spanning-Tree-Kruskal"><a href="#Model-5-Construct-Minimum-Spanning-Tree-Kruskal" class="headerlink" title="Model 5: Construct Minimum Spanning-Tree (Kruskal)"></a>Model 5: Construct Minimum Spanning-Tree (Kruskal)</h4><blockquote>
<p>图的权重函数\boxed{\t{图的权重函数}} \lb{ \a{ &amp;G \define (V, E) \\ &amp;c(G) &#x3D; \sum_{\alpha \in E}{c(\alpha)} } }</p>
</blockquote>
<p>G \define (V, E), V &#x3D; n, u \in V</p>
<ul>
<li><p>Step 1：\b{G \define (V, E), F \define \varnothing}</p>
</li>
<li><p>Step 2：当\b{\exists \alpha \in E \and \alpha \notin F, F \cup \s{\alpha} \t{ don’t have \r{cycles}}}时</p>
<ul>
<li>寻找\b{\alpha \t{ has the min-imum } c(\alpha)}</li>
<li>\alpha \cup F</li>
<li>Goto Step 2</li>
</ul>
</li>
<li><p>Step 3：T \dot{&#x3D;} (\b{V}, F)</p>
</li>
</ul>
<h4 id="Model-6-Construct-Minimum-Spanning-Tree-Prim"><a href="#Model-6-Construct-Minimum-Spanning-Tree-Prim" class="headerlink" title="Model 6: Construct Minimum Spanning-Tree (Prim)"></a>Model 6: Construct Minimum Spanning-Tree (Prim)</h4><p>G \define (V, E), u \in V</p>
<ul>
<li><p>Step 1：\b{i \dot{&#x3D;}1, U_\r{1} \dot{&#x3D;} \s{u}, F_\r{1} \dot{&#x3D;} \varnothing, T_\r{1} \dot{&#x3D;} (U_\r{1}, F_\r{1}) }</p>
</li>
<li><p>Step 2：当\r{i &#x3D; 1,2,\cdots, n-1}</p>
<ul>
<li>Step 2-1：寻找\r{\alpha_i &#x3D; \s{x,y} \t{ has the min-imum } c(\alpha_i)}, \r{x \in U_i \and y \notin U_i}</li>
<li>Step 2-2：\r{U_{i+1} \define U_i \cup \s{y}}, F_{i+1} \define F_i \cup \s{\alpha_{i}}, T_{i+1} \define (U_{i+1}, F_{i+1})</li>
<li>Step 2-3：i &#x3D; i + 1</li>
</ul>
</li>
<li><p>Step 3：T_{n - 1} &#x3D; (\b{U_{n-1} &#x3D; V}, F_{n-1})</p>
</li>
</ul>
<h3 id="Shannon-Switching-Games"><a href="#Shannon-Switching-Games" class="headerlink" title="Shannon Switching Games"></a>Shannon Switching Games</h3><h4 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h4><p>设<code>图</code>G &#x3D; (V,E)是一个多重图，<code>起始顶点u</code>和<code>终止顶点v</code>是两个指定的顶点。</p>
<p><code>Shannon Games</code>需要2名<code>选手 (Player)</code>参与，轮流进行<code>建造 (Build)</code>和<code>破环 (Destroy)</code>：</p>
<p><code>正方选手 (Positive Player -&gt; Build)</code></p>
<blockquote>
<p>获胜条件是，<code>建立</code>起<code>顶点u和顶点v之间的一条路径。</code></p>
<p><code>建造</code>：在两个顶点之间<code>连接</code>一条边，任何被<code>建造</code>的边将<code>无法被破坏</code></p>
</blockquote>
<p><code>反方选手 (Negative Player -&gt; Destroy)</code></p>
<blockquote>
<p>获胜条件是，<code>破坏</code>掉<code>顶点u和顶点v之间的所有路径</code>，一旦<code>所有的路径</code>都被破坏，则<code>反方选手</code>可以<code>立即取得胜利</code></p>
<blockquote>
<p><code>Shannon Switching Games</code>不存在<code>平局</code>的情况，如果游戏一开始时，<code>顶点u</code>和<code>顶点v</code>就不连通，则<code>反方选择</code> <code>立即取得胜利</code>！</p>
</blockquote>
<p><code>破坏</code>：破坏两个顶点之间的一条边。</p>
</blockquote>
<p>我们考虑是否存在下面几种策略：</p>
<ul>
<li>是否存在<code>先方游戏</code>：即<code>先手必胜</code></li>
<li>是否存在<code>后方游戏</code>：即<code>后手必胜</code></li>
<li>是否存在<code>正方游戏</code>：即无论<code>正方选手</code>是<code>先手</code>还是<code>后手</code>，都必定<code>获胜</code></li>
<li>是否存在<code>反方游戏</code>：即无论<code>反方选手</code>是<code>先手</code>还是<code>后手</code>，都必定<code>获胜</code></li>
</ul>
<blockquote>
<p>对于<code>Shannon Switching Games</code>：</p>
<p>如果<code>正方选手/反方选手</code>可以<code>后手必胜</code>，则它也可以<code>先手必胜</code>。</p>
<blockquote>
<p>因为它只需要在<code>第一手</code>做<code>自由运动</code>即可。</p>
</blockquote>
</blockquote>
<h4 id="Theory-5"><a href="#Theory-5" class="headerlink" title="Theory"></a>Theory</h4><h5 id="Theory-1-4"><a href="#Theory-1-4" class="headerlink" title="Theory 1"></a>Theory 1</h5><p>对于<code>Shannon Switching Games</code>，如果在<code>先方游戏</code>的<code>多重图</code>G中，加入<code>连接顶点u和顶点v的边</code>形成G’，则该游戏将变成<code>正方游戏</code></p>
<hr>
<ul>
<li><p>如果<code>正方选手</code>是<code>先手</code>，则它可以：</p>
<ul>
<li>不使用<code>边&#123;u, v&#125;</code>，而按照<code>图</code>G所定义的<code>先方游戏</code>的策略来<code>获胜</code></li>
<li>使用<code>边 &#123;u, v&#125;</code>，直接<code>获胜</code></li>
</ul>
</li>
<li><p>如果<code>正方选手</code>是<code>反手</code>，则我们为<code>反方选手</code>做考虑：</p>
<ul>
<li><code>反方选手</code>必须<code>首先破坏</code> <code>边 &#123;u, v&#125;</code>，否则<code>正方选手</code>可以利用该边立即<code>获胜</code>。但如果<code>反方选手</code> <code>第一步用来破坏 边&#123;u, v&#125;</code>，则它将边为图图G中的<code>后方</code>，使得<code>正方选手</code>可以遵循<code>先方游戏</code>的策略来<code>获胜</code>。</li>
</ul>
</li>
</ul>
<h5 id="Theory-2-4"><a href="#Theory-2-4" class="headerlink" title="Theory 2"></a>Theory 2</h5><p><code>Shannon Switching Games</code>是一个<code>正方游戏</code>，当且仅当，存在<code>包含u和v的顶点集</code>V的<code>子集</code>U，使得<code>导出子图</code>G_U中存在2个<code>没有共同边的生成树</code></p>
<hr>
<p>不妨假设这两颗生成树为T_1和T_2</p>
<p>而<code>生成树</code>T_1 &#x3D; (V_1, E_1)和T_2 &#x3D; (V_2, E_2)拥有<code>相同的顶点集</code>，却<code>不存在共同边</code>，则说明如果我们对于<code>图</code>G &#x3D; (V &#x3D; V_1 &#x3D; V_2, G &#x3D; \b{E_1 + E_2})来说，<code>所有的顶点</code>都属于<code>某个圈</code>之中。则根据我们前面讨论的<code>生成树</code>相关的结论，可以知道对于V_1 + V_2<code>之中的任何两个邻接的顶点 都属于 同一个圈中</code>，也就是说，<code>连接任何两个邻接顶点的边 都不是 悬挂边</code>，所以，<code>反方选手如果破坏 任何两个邻接顶点所属的圈中的1条边，并不会影响这两个邻接顶点之间的连通性</code>！</p>
<blockquote>
<p>必须要求<code>图G的生成树</code>中<code>任何两个邻接的顶点</code>都要<code>属于同一个圈</code>。</p>
<p>如果有<code>任何两个邻接的顶点 被 悬挂边 所连接</code>，则一旦<code>反方选手</code>破坏该条<code>悬挂边</code>，则<code>图G</code>将被<code>分割</code>为2个<code>连通分量</code></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/08/combinatorics-arrangement-and-combination/" rel="prev" title="Combinatorics -  Arrangement and Combination">
      <i class="fa fa-chevron-left"></i> Combinatorics -  Arrangement and Combination
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/12/search-back-tracking-iddfs/" rel="next" title="Search -  Back-Tracking & IDDFS">
      Search -  Back-Tracking & IDDFS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Graph-Basics"><span class="nav-number">1.</span> <span class="nav-text">Graph Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph"><span class="nav-number">1.1.</span> <span class="nav-text">Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition"><span class="nav-number">1.1.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concepts"><span class="nav-number">1.1.2.</span> <span class="nav-text">Concepts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory"><span class="nav-number">1.1.3.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-1-Handshake-Theorem"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Theory 1: Handshake Theorem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Theory 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-3"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Theory 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-4"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Theory 4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Euler-Trails-Bridges-of-Koenigsberg"><span class="nav-number">1.2.</span> <span class="nav-text">Euler Trails: Bridges of Koenigsberg</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Theory 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2-Euler%E2%80%99s-One-Stroke-Theorem"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Theory 2: Euler’s One-Stroke Theorem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-3-1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Theory 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-4-Euler%E2%80%99s-N-Stroke-Theorem"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Theory 4: Euler’s N-Stroke Theorem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-5"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Theory 5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example"><span class="nav-number">1.2.3.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1-Bridges-of-Koenigsberg"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Example 1: Bridges of Koenigsberg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2-Chinese-Postman-Problem"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Example 2: Chinese Postman Problem</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hamiltonian-Path-and-Hamiltonian-Circuit"><span class="nav-number">1.3.</span> <span class="nav-text">Hamiltonian Path and Hamiltonian Circuit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-1-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Theory 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2-1"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Theory 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-3-Ore-Property"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Theory 3: Ore Property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-4-1"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">Theory 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-5-1"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">Theory 5</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bipartite-Graph"><span class="nav-number">1.4.</span> <span class="nav-text">Bipartite Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definition-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-1-2"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Theory 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2-2"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Theory 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1-Reflective-Gray-Code"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Example 1: Reflective Gray Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2-Board-Coloring-Problem"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Example 2: Board Coloring Problem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-3-The-vaulting-horse-problem"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Example 3: The vaulting horse problem</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree"><span class="nav-number">1.5.</span> <span class="nav-text">Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definitions"><span class="nav-number">1.5.1.</span> <span class="nav-text">Definitions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-1"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Definition 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-2"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Definition 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-3"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Definition 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-4"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Definition 4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spanning-Tree"><span class="nav-number">1.6.</span> <span class="nav-text">Spanning Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-1-3"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">Theory 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-2-3"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">Theory 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-3-2"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">Theory 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-4-2"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">Theory 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-5-2"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">Theory 5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Models"><span class="nav-number">1.6.2.</span> <span class="nav-text">Models</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-1-Construct-Spanning-Tree"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Model 1: Construct Spanning-Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-2-Construct-BFS-Spanning-Tree"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Model 2: Construct BFS Spanning-Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-3-Construct-DFS-Spanning-Tree"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">Model 3: Construct DFS Spanning-Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-4-Construct-Distance-Spanning-Tree-Dijkstra"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">Model 4: Construct Distance Spanning-Tree (Dijkstra)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-5-Construct-Minimum-Spanning-Tree-Kruskal"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">Model 5: Construct Minimum Spanning-Tree (Kruskal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-6-Construct-Minimum-Spanning-Tree-Prim"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">Model 6: Construct Minimum Spanning-Tree (Prim)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shannon-Switching-Games"><span class="nav-number">1.6.3.</span> <span class="nav-text">Shannon Switching Games</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Definition-4"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Theory-5"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Theory-1-4"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">Theory 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Theory-2-4"><span class="nav-number">1.6.3.2.2.</span> <span class="nav-text">Theory 2</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JSP - Servlet &amp; JSP Short-Hand | SakuraWald</title><meta name="author" content="SakuraWald"><meta name="copyright" content="SakuraWald"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Servlets &amp; JSP Short-handServletRegister a servlet&lt;web-app ...&gt;     &lt;servlet&gt;         &lt;servlet-name&gt;This Is Your Custom Servet Name&lt;&#x2F;servlet-name&gt;         &lt;servlet-class">
<meta property="og:type" content="article">
<meta property="og:title" content="JSP - Servlet &amp; JSP Short-Hand">
<meta property="og:url" content="https://sakurawald.github.io/2022/06/13/jsp-servlet-jsp-short-hand/index.html">
<meta property="og:site_name" content="SakuraWald">
<meta property="og:description" content="Servlets &amp; JSP Short-handServletRegister a servlet&lt;web-app ...&gt;     &lt;servlet&gt;         &lt;servlet-name&gt;This Is Your Custom Servet Name&lt;&#x2F;servlet-name&gt;         &lt;servlet-class">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/10484271?v=4">
<meta property="article:published_time" content="2022-06-13T03:00:00.000Z">
<meta property="article:modified_time" content="2023-01-17T11:45:12.424Z">
<meta property="article:author" content="SakuraWald">
<meta property="article:tag" content="web">
<meta property="article:tag" content="jsp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/10484271?v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sakurawald.github.io/2022/06/13/jsp-servlet-jsp-short-hand/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JSP - Servlet & JSP Short-Hand',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-17 19:45:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/10484271?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/></div></div><div class="post" id="body-wrap"><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JSP - Servlet &amp; JSP Short-Hand</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-06-13T03:00:00.000Z" title="Created 2022-06-13 11:00:00">2022-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-17T11:45:12.424Z" title="Updated 2023-01-17 19:45:12">2023-01-17</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="Servlets-amp-JSP-Short-hand"><a href="#Servlets-amp-JSP-Short-hand" class="headerlink" title="Servlets &amp; JSP Short-hand"></a>Servlets &amp; JSP Short-hand</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Register-a-servlet"><a href="#Register-a-servlet" class="headerlink" title="Register a servlet"></a>Register a servlet</h3><pre><code class="lang-xml">&lt;web-app ...&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;This Is Your Custom Servet Name&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sakurawald.MyServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;   

    &lt;servlet-mapping&gt;
        &lt;serlvet-name&gt;This Is Your Custom Servet Name&lt;/serlvet-name&gt;
        &lt;url-pattern&gt;/some_url_you_want_to_map&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;    
&lt;/web-app&gt;
</code></pre>
<h3 id="Life-cycle"><a href="#Life-cycle" class="headerlink" title="Life-cycle"></a>Life-cycle</h3><p><code>Servlet生命周期</code></p>
<ul>
<li>servlet类加载</li>
<li>servlet实例化</li>
<li>servlet#init</li>
<li>servlet#service</li>
<li>servlet#destroy</li>
</ul>
<h3 id="A-simple-servlet-demo"><a href="#A-simple-servlet-demo" class="headerlink" title="A simple servlet demo"></a>A simple servlet demo</h3><pre><code class="lang-java">import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Ch2Servlet extends HttpServlet &#123;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        PrintWriter out = response.getWriter();
        out.println(&quot;&lt;a&gt;hello world&lt;/a&gt;&quot;);
    &#125;

&#125;
</code></pre>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote>
<p>Servlet只运行自己的业务代码，然后调用一个特定的JSP处理响应HTML，这就能把 <code>业务逻辑</code> 与 <code>表示</code> 相分离。</p>
<p>而采用MVC，不仅要求 <code>业务逻辑</code> 与 <code>表示</code> 相分离，实际上，<code>业务逻辑</code> 根本不知道有 <code>表示</code> 的 存在。</p>
</blockquote>
<p>MVC的组成部分：</p>
<ul>
<li>Model (模型)：包含具体的 <code>业务逻辑</code> 和 <code>状态</code>。</li>
<li>View (视图)：负责进行 <code>表示</code>。</li>
<li>Controller (控制器)：从 <code>请求</code> 获得 <code>用户输入</code>，并明确这些输入对 <code>模型</code> 有什么影响。</li>
</ul>
<p>Misc</p>
<ul>
<li>容器为 <code>Web应用</code> 提供了 <code>通信支持</code>，<code>生命周期管理</code>， <code>多线程支持</code>， <code>声明方式安全</code>， 以及 <code>JSP支持</code></li>
<li>容器根据 <code>URL</code> 查找 <code>正确的Servlet</code>，并把 <code>请求</code> 传递给该Servlet</li>
</ul>
<hr>
<pre><code class="lang-java">// src/com/example/web/BeerServlet.java
package com.example.web;

import com.example.model.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

public class BeerServlet extends HttpServlet &#123;

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;

        String c = request.getParameter(&quot;color&quot;);
        BeerExpert be = new BeerExpert();
        List result = be.getBrands(c);

        reqeust.setAttribute(&quot;styles&quot;, result);
        RequestDispatcher view = request.getRequestDispatcher(&quot;result.jsp&quot;);
        view.forward(request, response);
    &#125;

&#125;
</code></pre>
<pre><code class="lang-jsp">// result.jsp
&lt;%@ page import=&quot;java.util.*&quot; %&gt;

&lt;html&gt;
    &lt;body&gt;
        &lt;h1 align=&quot;center&quot;&gt;
            Beer Recommendations JSP
        &lt;/h1&gt;
        &lt;p&gt;

            &lt;%

                List styles = (List) request.getAttribute(&quot;styles&quot;);
                Iterator it = styles.iterator();
                while(it.hasNext()) &#123;
                    out.print(&quot;&lt;br&gt;try:&quot; + it.next);
                &#125;

            %&gt;

        &lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Servlet-Request-amp-Response"><a href="#Servlet-Request-amp-Response" class="headerlink" title="Servlet: Request &amp; Response"></a>Servlet: Request &amp; Response</h3><blockquote>
<p><code>Servet的每个实例...</code> 这种说法是错误的，<code>任何Servlet类</code> 都不会有多个 <code>实例</code>。（除非使用 <code>SingleThreadModel</code>）</p>
<p>否则 <code>容器</code> 运行 <code>多个线程</code> 来处理 <code>对1个Servlet</code> 的 <code>多个请求</code> （准确地说：<code>每个请求</code> 使用 <code>1个线程</code> 来请求 <code>指定的Servlet</code>）</p>
<p>对于 <code>每个Servlet</code>，请在 <code>init()</code> 中进行 <code>初始化操作</code> 而不是 <code>构造器函数</code> 当中。</p>
<p><code>构造器函数</code> 使得 <code>Servlet</code> 具备 <code>Servlet特性 (Servletness)</code>，并获得 <code>作为Servlet所应具有的特权</code>：如 <code>通过ServletContext引用从容器中获取信息</code> 。</p>
<p>所以，请不要在 <code>构造器函数</code> 中过早地进行 <code>初始化操作</code> （在 <code>构造器函数</code> 中我们无法 <code>获得关于Web应用的配置信息等</code>）</p>
<p><code>每个Servlet</code> 都有 <code>自己特有的1个 ServletConfig对象</code>，它可以用于访问 <code>整个App共享的1个ServletContext</code>。</p>
<blockquote>
<p>注意：<code>ServletContext</code> 更准确得叫法应该叫 <code>AppContext</code>，因为 <code>实际上</code>，<code>每个Web应用</code> <code>有且仅有</code> 1个 <code>ServletContext</code> ！！！</p>
<p>这 <code>并不是</code> 你所想的那样：<code>每个Servlet</code> 都有 <code>自己特有的1个 ServletContext</code></p>
<blockquote>
<p>但是：<code>每个Servlet</code> 确确实实有 <code>自己特有的1个 ServletConfig</code> ！！！！！</p>
</blockquote>
</blockquote>
<pre><code class="lang-mermaid">classDiagram

class ServletRequest&#123;
   +Object getAttribute(String)
   +String getParamterer(String)
   +Enumeration getParameterNames()

&#125;
class ServletResponse&#123;
+ServletOutputStream getOutputStream()
+PrintWriter getWriter()
&#125;
ServletRequest &lt;-- HttpServletRequest
class HttpServletRequest &#123;
+String getContextPath()
+Cookie[] getCookies()
+String getHeader(String)
+String getQueryString()
+HttpSession getSession()
+String getMethod()
&#125;

ServletResponse &lt;-- HttpServletResponse
class HttpServletResponse &#123;
+void addCookie(Cookie)
+void addHeader(String name, String value)
&#125;
</code></pre>
<blockquote>
<p>之所以需要有 <code>GenericServlet</code> 以及 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> ，是因为 <code>可能会有人</code> 将 <code>Servlet技术模型</code> 用于 <code>其他协议</code> （大概不会有人）。</p>
</blockquote>
<p>Servlet可以处理的 <code>HTTP Methods</code> 包括：<code>GET</code> ，<code>PUT</code>，<code>HEAD</code>，<code>TRACE</code>，<code>OPTIONS</code>，<code>PUT</code>，<code>DELETE</code> 和 <code>CONNECT</code></p>
<p>我们使用 <code>doGet()</code> 来处理 <code>简单请求</code>，而使用 <code>doPost()</code> 来 <code>接收和处理表单数据</code></p>
<p>HTTP Method</p>
<p>Description</p>
<p>GET</p>
<p>要求得到所请求URL上的一个东西 （资源/文件）</p>
<p>POST</p>
<p>要求服务器接受 <code>附加到请求体的体信息</code>，并提供 <code>所请求URL上的一个东西</code>。这类似于 <code>附带了额外信息的GET</code></p>
<p>HEAD</p>
<p>只要求得到 <code>GET返回结果的首部部分</code>。这类似于 <code>响应中没有体的GET</code></p>
<p>TRACE</p>
<p>要求请求消息 <code>回送</code>，这样客户端能够 <code>看到</code> 另一端接收了什么，以便进行调试。</p>
<p>PUT</p>
<p>指出要把 <code>所包含的体</code> 放在 <code>请求的URL</code> 上</p>
<p>DELETE</p>
<p>指出删除 <code>所请求的URL</code> 上的东西 （资源/文件）</p>
<p>OPTIONS</p>
<p>要求得到 <code>一个HTTP Method列表</code>，表明 <code>所请求的URL</code> 可以处理 这些方法</p>
<p>CONNECT</p>
<p>要求连接以 <code>建立隧道</code></p>
<blockquote>
<p>关于 <code>幂等性</code>：<code>GET</code> 是 <code>幂等的</code>，但 <code>POST</code> 不是。</p>
</blockquote>
<p><code>表单 FORM</code> 的默认 <code>HTTP METHOD</code> 为 <code>GET</code> ！！！</p>
<p>除非你 <code>手动地</code> 指定为 <code>POST</code></p>
<pre><code class="lang-html">&lt;form method=&quot;POST&quot; action=&quot;SelectBeer.do&quot;&gt;
 &lt;p&gt;
     Select beer characteristics
 &lt;/p&gt;
 &lt;select name=&quot;color&quot; size=&quot;1&quot;&gt;
     &lt;option&gt;light&lt;/option&gt;
     &lt;optoin&gt;amber&lt;/optoin&gt;
     &lt;option&gt;brown&lt;/option&gt;
     &lt;option&gt;dark&lt;/option&gt;
 &lt;/select&gt;

 &lt;center&gt;
 &lt;input type=&quot;SUBMIT&quot;&gt;
 &lt;/center&gt;

&lt;/form&gt;
</code></pre>
<p>同样的，这些 <code>参数</code> 会相应地 <code>通过</code> <code>POST请求中的体信息</code> 和 <code>HttpServetRequest#getParameter(String)</code></p>
<pre><code class="lang-javascript">color=dark&amp;body=heavy
</code></pre>
<pre><code class="lang-java">public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;
 String colorParam = request.getParameter(&quot;color&quot;);
 String bodyParam = request.getParameter(&quot;body&quot;);
&#125;
</code></pre>
<blockquote>
<p>如果试图对 <code>只实现了doPost()的servlet</code> 发送 <code>GET请求</code>，则导致 <code>运行时错误</code>。</p>
<p>如果你想让 <code>某个Servlet</code> 同时支持 <code>GET</code> 和 <code>POST</code> ，则这样做：</p>
<pre><code class="lang-java">public void doPost(...) throws ...&#123;
 doGet(request, response);   
&#125;
</code></pre>
</blockquote>
<p><code>单个参数</code> 可以有 <code>多个值</code> （比如 <code>Multi-CheckBox</code>），我们需要使用 <code>getParameterValues()</code> 来获取 <code>表示多值的数组</code></p>
<pre><code class="lang-java">String[] sizes = request.getParameterValues(&quot;sizes&quot;);
String first_value = request.getParameterValues(&quot;sizes&quot;)[0];
String second_value = request.getParameterValues(&quot;sizes&quot;)[1];
</code></pre>
<p><code>HttpServletRequest#getInputStream</code> 用于用于对 <code>POST请求</code> 中包含的 <code>巨大请求体</code> 进行细致处理。</p>
<pre><code class="lang-java">String forwardsNum = Integer.parseInt(request.getHeader(&quot;Max-Forwards&quot;));
// equals to
String fowwardsNum = request.getIntHeader(&quot;Max-Forwards&quot;);
</code></pre>
<p><code>ServletRequest</code> 的 <code>getLocalPort()</code> 和 <code>getRemotePort()</code> 是相对于 <code>Servlet</code> 的</p>
<p>可以 <code>覆盖 init()</code> ，且 <code>必须覆盖</code> 1个 <code>服务方法 (doGet(), doPost() ...)</code></p>
<pre><code class="lang-mermaid">classDiagram
class Servlet &#123;
+service(ServletRequest, ServletResponse)
+init(ServletConfig)
+destroy()
+getServletConfig()
&#125;

Servlet &lt;-- GenericServlet
class GenericServlet &#123;
+init()
+getInitParameterNames()
+getInitParameter(String)
+getServletContext()
&#125;

GenericServlet &lt;-- HttpServlet
class HttpServlet&#123;
+service(HttpServletRequest, HttpServiceResponse)
+doGet(HttpServletRequest, HttpServiceResponse)
+doPost(HttpServletRequest, HttpServiceResponse)
&#125;
</code></pre>
<p><code>ServletContext#getResourceAsStream(&quot;/bookCode.jar&quot;)</code> 中，<code>斜线</code> 代表 <code>Web Application的根目录</code></p>
<p>对于 <code>ServletResponse接口</code> 的 <code>输出流</code>，可以选择 <code>字节流</code> 或者 <code>字符流</code></p>
<pre><code class="lang-java">// Byte-Stream
ServletOutputStream out = response.getOutputStream();
out.write(aByteArray);
// Character-Stream
PrintWriter out = response.getWriter();
our.println(aString)
</code></pre>
<blockquote>
<p>你应当猜到，<code>PrintWriter</code> 内部包装了 <code>ServletOutputStream</code>。</p>
<p><code>获取对象的方法名</code> = <code>去掉对象的第一个词</code></p>
</blockquote>
<p><code>重定向 (Redirect)</code> 中 <code>相对路径</code> 和 <code>绝对路径</code>：</p>
<pre><code class="lang-java">// 用户原来键入: http://www.wickedlysmart.com/myApp/cool/bar.do
response.sendRedirect(&quot;foo/stuff.html&quot;) // --&gt; http://www.wickedlysmart.com/myApp/cool/foo/stuff.html
response.sendRedirect(&quot;/foo/stuff.html&quot;) // --&gt; httpL//www.wickedlysmart.com/foo/stuff.html
</code></pre>
<blockquote>
<p>不能在 <code>写到响应之后 （即响应已提交，也就是响应已经发送给客户端，即数据已刷新到输出流）</code> 再调用 <code>sendRedirect()</code>，否则将获得 <code>IllegalStateException</code></p>
<p><code>重定向 (Redirect)</code> 让 <code>客户端</code> 来完成工作，而 <code>请求分派 (Forward)</code> 让 <code>服务端</code> 来完成工作。</p>
<p>对于 <code>本来已经存在的header</code> 而言，<code>reponse#addHeader</code> 和 <code>response#setHeader</code> 的表现 <code>完全一样</code></p>
</blockquote>
</blockquote>
<h3 id="Application-Attribute-amp-Listener"><a href="#Application-Attribute-amp-Listener" class="headerlink" title="Application: Attribute &amp; Listener"></a>Application: Attribute &amp; Listener</h3><blockquote>
<p><code>Servlet属性的作用域</code>：<code>Request</code>，<code>Session</code>，<code>Context</code></p>
<ul>
<li><code>Servlet的初始化参数</code></li>
</ul>
<p><code>每个Servlet</code> 可以有 <code>自己特有的初始化参数 (Initialization-Parameter)</code></p>
<pre><code class="lang-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;A Stupid Name&lt;/servlet-name&gt;
    &lt;servlet-class&gt;here.you.should.fill.in.full.class.name&lt;/servlet-class&gt;

    &lt;init-param&gt;
        &lt;param-name&gt;adminEmail&lt;/param-name&gt;
        &lt;param-value&gt;sakurawald@gmail.com&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>
<pre><code class="lang-java">// Inside one specific servlet
getServletConfig().getInitParameter(&quot;adminEmail&quot;);
</code></pre>
<ul>
<li><code>Context的初始化参数</code></li>
</ul>
<pre><code class="lang-xml">&lt;web-app ...&gt;
    ...

&lt;context-param&gt;
    &lt;param-name&gt;adminEmail&lt;/param-name&gt;
        &lt;param-value&gt;sakurawald@gmail.com&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">// Inside every servelet
getServletContext().getInitParameter(&quot;adminEmail&quot;);
</code></pre>
<p>不管是 <code>Servlet的初始化参数</code> （对应 <code>ServletConfig</code>） 和 <code>Context的初始化参数</code> （对应 <code>ServletContext</code>），都不提供对 <code>相应的初始化参数的 setInitParameter()</code>。</p>
<p>换句话说，<code>初始化参数</code> 是 <code>部署时常量</code>， 在运行时不可以 <code>重新设置</code>。</p>
<p>默认规定，如果没有 <code>明确地指明</code> 是 <code>servlet的初始化参数</code> 还是 <code>context的初始化参数</code>，则我们 <code>默认</code> <code>初始化参数</code> 是指 <code>servlet的初始化参数</code></p>
<p>可以用 <code>两种方法</code> 获得 <code>ServletContext</code></p>
<pre><code class="lang-java">this.getServletConfig().getServletContext().getInitParameter();
// or
this.getServletContext().getInitParameter();
</code></pre>
<ul>
<li><code>ServletContextListener</code></li>
</ul>
<pre><code class="lang-xml">&lt;web-app ...&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;com.example.MyServletContextListener&lt;/listener-class&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">public class MyServletContextListener implements ServletContextListener &#123;

    public void contextInitialized(ServletContextEvent event) &#123;

        ServletContext sc = event.getServletContext();

        String dogBreed = sc.getInitParameter(&quot;breed&quot;);
        Dog dog = new Dog(dogBreed);
        sc.setAttribute(&quot;dog&quot;, dog);   
    &#125;

    public void contextDestroyed(ServletContextEvent event) &#123;
        // do some clean-up work.
    &#125;

&#125;
</code></pre>
<ul>
<li>Attribute versus Parameter</li>
</ul>
<p>Attribute</p>
<p>parameter</p>
<p>Type</p>
<p>Application/Context<br>Request<br>Session</p>
<p>Application/Context<br>Request<br>Servlet Initialization-Parameter</p>
<p>Getter</p>
<p>getAttribute(String name)</p>
<p>getInitParameter()</p>
<p>Setter</p>
<p>setAttribute(String name, Object value)</p>
<p>DD</p>
<p>Return Type</p>
<p>Object</p>
<p>String</p>
<p><code>对Context加锁</code> 而不是 <code>对Servlet加锁</code></p>
<pre><code class="lang-java">synchronized(getServetContext()) &#123;
 getServletContext().setAttribute(&quot;foo&quot;, 42);
 out.println(getServletContext().getAttribute(&quot;foo&quot;));
&#125;
</code></pre>
</blockquote>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p><code>request.getSession()</code> 会在 <code>之前没有存在会话</code> 时， <code>自动地</code> 创建 <code>新会话</code></p>
<pre><code class="lang-java">HttpSession session = request.getSession();
if (session.isNew()) &#123;
 ...
&#125;
</code></pre>
<blockquote>
<p>更准确地，可能 <code>getSession(false)</code> 才符合 <code>getter</code> 的 <code>语意</code>：在 <code>之前不存在会话</code> 时 应该返回 <code>null</code></p>
</blockquote>
<p>在 <code>request</code> 上调用 <code>getSession()</code> ，<code>容器</code> 会 <code>尝试使用cookie</code>，如果 <code>客户的浏览器没有启用cookie</code>，则说明 <code>客户不会加入会话</code>。</p>
<p>此时，<code>session#isNew</code> 总是返回 <code>true</code></p>
<p>对于 <code>客户禁用cookie</code> 的情况，<code>总是使用</code> <code>URL重写</code> 来 <code>追踪会话</code>。</p>
<p>可以通过 <code>response#encodeURL(String)</code> 在每个 <code>链接</code> 种添加 <code>会话ID (Session ID)</code></p>
<blockquote>
<p>如果需要在 <code>重定向</code> 的时候，仍然使用 <code>同一个会话</code> ，则调用：</p>
<pre><code class="lang-java">response.encodeRedirectURL(&quot;/BeerTest.do&quot;);
</code></pre>
<p><code>容器</code> <code>了解客户的cookie能否正常工作</code> 的 <code>唯一方式</code> 是：<code>检查客户发送的请求是否携带会话ID</code>。</p>
<p>一旦容器发现 <code>客户发送的请求</code> 没有 <code>携带会话ID</code>，则需要在 <code>返回的响应</code> 中 <code>同时尝试</code> <code>cookie</code> 和 <code>url重写</code> 这两种方法。</p>
</blockquote>
<p><code>JSESSIONID</code> 会出现在 <code>header的cookie中</code>，以及 <code>URL</code> 当中</p>
<pre><code class="lang-html">Cookie: JESSIONID=0AAB6C8DE415
// or
POST /select/selectBeerTaste.do;JESSIONID=0AAB6C8DE415
</code></pre>
<p><code>会话失效</code> 的原因： <code>会话超时</code>，<code>手动调用 session#invalidate()</code> 和 <code>应用结束 (崩溃或取消部署)</code></p>
<pre><code class="lang-xml">&lt;web-app&gt;

 &lt;session-config&gt;
     &lt;!-- 15minutes --&gt;
 &lt;session-timeout&gt;15&lt;/session-timeout&gt;
 &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="lang-java">// 此处的时间单位 = 秒
session.setMaxInactiveInterval(15 * 60)
// session.setMaxInactiveInterval(0) = session.invalidate()
</code></pre>
<p>将 <code>cookie</code> 用于 <code>其他用途</code> （不仅仅是用于 <code>会话 (Session)</code>）</p>
<pre><code class="lang-java">Cookie cookie = new Cookie(&quot;username&quot;, name);
cookie.setMaxAge(15 * 60); // 如果设置 -1，则在 浏览器退出是，cookie自动删除
response.addCookie(cookie);
</code></pre>
<blockquote>
<p>有 <code>getHeader()</code> 和 <code>setHeader()</code>。但只有 <code>addCookie()</code> 和 <code>getCookies()</code>，没有 <code>getCookie()</code> 和 <code>setCookie()</code></p>
</blockquote>
</blockquote>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><blockquote>
<p>当说到 <code>表达式</code> 时，默认指 <code>脚本表达式 (Java语言表达式)</code>，而不是 <code>EL表达式</code></p>
</blockquote>
<p>Element Type</p>
<p>Example</p>
<p>Scriptlet</p>
<p>&lt;% Float one = new Float(42.5); %&gt;</p>
<p>Script Expression</p>
<p>&lt;%= pageContext.getAttribute(“foo”) %&gt;</p>
<p>EL Expression</p>
<p>email: ${applicationScope.mail}</p>
<p>Declaration</p>
<p>&lt;%! int y = 3; %&gt;</p>
<p>Instruction</p>
<p>&lt;%@ page import=”java.util.*“ %&gt;</p>
<p>Action</p>
<jsp: include page="foo.html" />

<hr>
<p>编写的 <code>JSP</code> 最终被 <code>编译</code> 为 <code>Servlet</code></p>
<pre><code class="lang-jsp">&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%
    out.println(foo.Counter.getCount()); // 使用 scriptlet + 全限定类名
     %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ page import=&quot;foo.*&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%
    out.println(Counter.getCount()); // 使用 scriptlet + page import
     %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>进一步完善，使用 <code>JSEL</code></p>
<pre><code class="lang-jsp">&lt;%@ page import=&quot;foo.*&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        The page count is:
         &lt;%= Counter.getCount() //使用 Expression
    %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>当使用 <code>表达式</code> 时，<code>语句末尾</code> 不能有 <code>分号</code> ！！！</p>
<p>因为 <code>&lt;%= Counter.getCount() &gt;</code> 等价于 <code>out.print(Counter.getCount())</code></p>
<p>在 <code>Scriptlet</code> 中 <code>定义变量</code></p>
<pre><code class="lang-jsp">&lt;% int count = 0; // 局部变量 %&gt; 
&lt;%! int count = 0; // 实例变量 %&gt;
</code></pre>
<p><code>JSP的隐式对象</code></p>
<p>API (Servlet)</p>
<p>隐式对象 (JSP)</p>
<p>JspWriter</p>
<p>out</p>
<p>HttpServletRequest</p>
<p>request</p>
<p>HttpServletResponse</p>
<p>response</p>
<p>HttpSession</p>
<p>session</p>
<p>ServletContext</p>
<p>application</p>
<p>ServletConfig</p>
<p>config</p>
<p>Throwable</p>
<p>exception</p>
<p>PageContext</p>
<p>pageContext</p>
<p>Object</p>
<p>page</p>
<blockquote>
<p><code>JspWriter</code> 不在 <code>PrintWriter</code> 的 <code>类层次体系</code> 中，但它类似于 <code>带了缓冲的PrintWriter</code></p>
</blockquote>
<p><code>JSP注释</code></p>
<pre><code class="lang-jsp">&lt;%-- your comment --%&gt;
</code></pre>
<p><code>属性的作用域</code> <code>映射关系</code></p>
<p>Scope</p>
<p>Servlet</p>
<p>JSP</p>
<p>Application</p>
<p>getServletContext().setAttribute(“foo”, barObj);</p>
<p>application.setAttribute(“foo”, barObj);</p>
<p>Request</p>
<p>request.setAttribute(“foo”, barObj);</p>
<p>request.setAttribute(“foo”, barObj);</p>
<p>Session</p>
<p>request.getSession.setAttribute(“foo”, barObj);</p>
<p>session.setAttribute(“foo”, barObj);</p>
<p>Page</p>
<p>\</p>
<p>pageContext.setAttribute(“foo”, barObj);</p>
<p>使用 <code>PAGE_CONTEXT</code> 得到 <code>属性</code></p>
<pre><code class="lang-mermaid">classDiagram
class JspContext &#123;
+getAttribute(String name)
+getAttribute(String name, int scope)
+getAttributeNames()
+findAttribuite(String name)
&#125;

JspContext &lt;-- PageContext
class PageContext&#123;
+APPLICATION_SCOPE
+PAGE_SCOPE
+REQUEST_SCOPE
+SESSION_SCOPE
+getRequest()
+getServletConfig()
+getServletContext()
+getSession()
&#125;
</code></pre>
<blockquote>
<p><code>getAttribute(String name)</code> = <code>getAttribute(String name, PAGE_SCOPE)</code></p>
<p><code>findAttribute(String name)</code> 的查找范围为：<code>PAGE_SCOPE</code> -&gt; <code>REQUEST_SCOPE</code> -&gt; <code>SESSION_SCOPE</code> -&gt; <code>APPLICATION_SCOPE</code></p>
</blockquote>
<p><code>表达式语言 (Expression Language)</code> 的形式为 <code>$&#123;something&#125;</code></p>
<pre><code class="lang-jsp">&lt;!-- Use Expression Language --&gt;
Please contact: $&#123;applicationScope.mail&#125;

&lt;!-- Use Java Language --&gt;
Please contact: &lt;%= application.getAttribute(&quot;mail&quot;) %&gt;
</code></pre>
<p>在 <code>使用EL</code>时，别忘了顺便 <code>封杀JSP中的</code> <code>脚本元素 (Script)</code></p>
<pre><code class="lang-xml">&lt;web-app&gt;
&lt;jsp-config&gt;
   &lt;jsp-property-group&gt;
       &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&gt;
       &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt;
   &lt;/jsp-property-group&gt;
&lt;/jsp-config&gt;
&lt;/web-app&gt;
</code></pre>
<p><code>动作元素</code> 分为 <code>标准动作</code> 和 <code>定制动作</code></p>
<pre><code class="lang-jsp">// 标准动作
&lt;jsp:include page=&quot;wickedFooter.jsp&quot; /&gt;
// 定制动作
&lt;c:set var=&quot;rate&quot; value=&quot;32&quot; /&gt;
</code></pre>
<blockquote>
<p>有些 <code>非标准动作</code> 仍然位于 <code>标准库</code>。</p>
</blockquote>
</blockquote>
<h3 id="Scriptless-JSP"><a href="#Scriptless-JSP" class="headerlink" title="Scriptless-JSP"></a>Scriptless-JSP</h3><pre><code class="lang-jsp">&lt;html&gt;
    &lt;body&gt;
        &lt;% foo.Person p = (foo.Person) request.getAttribute(&quot;person&quot;); %&gt;
        Person is: &lt;%= p.getName() %&gt;
    &lt;/body&gt;
&lt;/html&gt;
&lt;!-- equals to --&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;request&quot; /&gt;
        Person created by servlet: &lt;jsp:getProperty name=&quot;person&quot; property=&quot;name&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">// &lt;jsp:useBean&gt; 在 创建新Bean 时 执行体中的内容
&lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;page&quot; &gt;
&lt;jsp:setProperty name=&quot;person&quot;property=&quot;name&quot; value=&quot;Fred&quot; /&gt;
&lt;/jsp:useBean&gt;
</code></pre>
<blockquote>
<p>JavaBean只有 <code>无参构造器</code>，<code>&lt;jsp:useBean&gt;</code> 在 <code>对象</code> 不存在时，会 <code>自动地</code> 通过无参构造器创建新对象</p>
<ul>
<li><code>useBean</code> 的 <code>type</code> 和 <code>class</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- 建立多态的bean引用 --&gt;
&lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; class=&quot;foo.Employee&quot; scope=&quot;page&quot; &gt;&lt;/jsp:useBean&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- 只使用type，而没有class --&gt;
&lt;jsp:useBean id=&quot;person&quot; type=&quot;foo.Person&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt;
</code></pre>
<p>规则是这样的：<code>type</code> 表示 <code>引用类型</code>，<code>class</code> 表示 <code>对象类型 （实际类型）</code>。即 <code>type x = new class()</code></p>
<p><code>scope</code> 默认为 “page”。</p>
<ul>
<li>如果 <code>只有type</code>，则要求 <code>bean</code> 必须要 <code>已经存在</code></li>
<li><p>如果 <code>使用class</code> （不管是否有type），则 <code>class不能是抽象类</code>，且 <code>必须有无参构造函数</code></p>
</li>
<li><p>设置 <code>JavaBean</code> 的 <code>属性</code> 为 <code>相应的请求参数</code></p>
</li>
</ul>
<pre><code class="lang-jsp">&lt;!-- 使用 Java-Language Expression --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;&lt;%= request.getParameter(&quot;username&quot;)%&gt;&quot; /&gt;
&lt;!-- 直接使用 param属性 (甚至当 表单的请求参数名 与 JavaBean的性质名 相等时，可以直接省略 param) --&gt;
&lt;!-- 更进一步的，如果 所有的参数名与性质名 都相等，可以使用 param=&quot;*&quot; --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; param=&quot;userName&quot; /&gt;
</code></pre>
<ul>
<li>setProperty 的 <code>自动类型转化</code>：<code>String -&gt; Primitive</code></li>
</ul>
<pre><code class="lang-xml">&lt;!-- 下列这些会自动转化 --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;*&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; value=&quot;343&quot; /&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; param=&quot;343&quot; /&gt;
&lt;!-- 如果使用脚本，则不会自动转化(此时保证类型正确是你的责任) --&gt;
&lt;jsp:setProperty name=&quot;person&quot; property=&quot;empID&quot; value=&quot;&lt;%= request.getParameter(&quot;empID&quot;) %&gt;&quot; /&gt;
</code></pre>
<ul>
<li>getProperty</li>
</ul>
<pre><code class="lang-jsp">&lt;html&gt;
    &lt;jsp:useBean id=&quot;person&quot; class=&quot;foo.Person&quot; scope=&quot;request&quot; /&gt;
    Dog&#39;s name is: &lt;%= ((foo.Person) request.getAttribute(&quot;person&quot;)).getDog().getName() %&gt;
&lt;!-- equals to--&gt;
    Dog&#39;s name is: $&#123;person.dog.name&#125;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>注意：<code>&lt;jsp:getProperty&gt;</code> 只能访问 <code>bean属性的性质</code>，它无法访问 <code>嵌套性质</code> （如 person.dog.name）</p>
</blockquote>
<ul>
<li><p><code>EL表达式的隐式对象</code>：映射对象 （<code>pageScope</code>，<code>requestScope</code>，<code>sessionScope</code>，<code>applicationScope</code>，<code>param</code> ，<code>paramValues</code>，<code>header</code>，<code>headerValues</code>，<code>cookie</code>，<code>initParam (上下文初始化参数，而不是Servlet初始化参数)</code>），非映射对象 （<code>pageContext</code>）。</p>
<blockquote>
<p>即 <code>pageContext隐式对象</code> 是 <code>JavaBean</code>，<code>其他隐式对象</code> 是 <code>Map</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><code>点号操作符</code> 与 <code>中括号操作符</code></li>
</ul>
<p>点号操作符</p>
<p>中括号操作符数组可被解析为数字的东西</p>
<pre><code class="lang-jsp">$&#123;musicMap.Ambient&#125; equals to $&#123;musicMap[&quot;Ambient&quot;]&#125;
$&#123;musicList[&quot;1&quot;]&#125; NOT equals to $&#123;musicList.1&#125; (后者是错误的,因为 点号操作符 严格要求 标识符的命名规范)
</code></pre>
<blockquote>
<p><code>EL保留字</code> 不能用于 <code>标识符</code>：<code>true</code>，<code>false</code>，<code>null</code>，<code>instanceof</code>，<code>empty</code></p>
</blockquote>
<p><code>requestScope</code> 不是 <code>请求对象 (Request)</code>。</p>
<p>应通过 <code>pageContext</code> 来获得 <code>request</code></p>
<pre><code class="lang-jsp">Method is: $&#123;pageContext.request.method&#125;
</code></pre>
<ul>
<li>使用 <code>作用域隐式对象</code> 来避免 <code>命名冲突</code></li>
</ul>
<pre><code class="lang-jsp">$&#123;foo.person.name&#125;
&lt;!-- and --&gt;
$&#123;requestScope[&quot;foo.person&quot;].name&#125;
</code></pre>
<p>通过 <code>明确地指定</code> <code>作用域</code>，以避免 <code>错误地将foo当作某个作用域中的属性</code></p>
<p>首先，我们知道如下事实：</p>
<ul>
<li><code>servlet的初始化参数</code> 使用 <code>&lt;init-param&gt;</code> 进行配置</li>
<li><code>context的初始化参数</code> 使用 <code>&lt;context-param&gt;</code> 进行配置</li>
</ul>
<p>但是，<code>EL的initParam隐式对象</code> 实际上对应的是 <code>上下文的参数</code> （即它使用 <code>&lt;contex-param&gt;</code> 来进行配置）</p>
<ul>
<li>TLD</li>
</ul>
<pre><code class="lang-java">package foo;
public class DiceRoller &#123;
    public static int rollDice() &#123;
        return (int) ((Math.random() * 6) + 1);
    &#125;
&#125;
</code></pre>
<pre><code class="lang-xml">&lt;taglib ...&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;uri&gt;DiceFunctions&lt;/uri&gt;
    &lt;function&gt;
    &lt;name&gt;rollIt&lt;/name&gt;
        &lt;function-class&gt;foo.DiceRoller&lt;/function-class&gt;
        &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt;
    &lt;/function&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;DiceFunctions&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
        $&#123;mine:rollIt()&#125;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>EL表达式中，<code>除0得到INFINITY</code>，但 <code>模0将得到错误</code></p>
<p><code>EL表达式</code> 对 <code>null</code> 是 <code>友好处理的</code> ：<code>什么也不做</code> 胜过于 <code>抛出错误</code></p>
<p>对于 <code>unknown</code> 和 <code>null</code>，即使 <code>找不到表达式中指定名的属性/性质/键</code>，也仍然会 <code>显示页面</code>。</p>
<ul>
<li>在 <code>算数表达式</code> 中，<code>null</code> 被视为 <code>0</code></li>
<li><p>在 <code>逻辑表达式</code> 中，<code>null</code> 被视为 <code>false</code></p>
</li>
<li><p>两种 <code>页面包含机制</code></p>
</li>
</ul>
<p>&lt;%@ include file=”…”&gt; 指令</p>
<p><jsp:include page="..."> 标准动作</p>
<p>在 <code>转换</code> 时将 <code>全部的源代码</code> 进行 <code>简单的文本粘贴</code>（取得”Header.jsp”文件中的内容，并在转义之前 <code>放入</code> 到 <code>Contact.jsp</code> 中）：<br>out.write(“the content of Header.jsp”);</p>
<p>在 <code>运行时</code> 进行 <code>调用</code>：<br>org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, “Header.jsp”, out, false)</p>
<blockquote>
<p><code>被包含的页面</code> 不能 <code>修改响应状态码</code> 或 <code>设置首部</code>。如果尝试这么做，不会 <code>得到错误</code>，而仅仅是 <code>结果达不到预期的目标</code></p>
<p>在 <code>可重用组件</code> 中不应该编写 <code>HTMl</code> 或 <code>BODY</code> 标签，以避免 <code>标签嵌套</code></p>
</blockquote>
<p><code>&lt;jsp:forward&gt;</code> 的 响应缓存区 会在 <code>转发</code> 之前 <code>被清空</code>：故 <code>不要先刷新输出</code> 然后再 <code>转发</code></p>
<blockquote>
<p>如果在 <code>转发</code> 之前 <code>已经刷新了响应缓冲区 （提交了响应）</code>，则会将 <code>刷新输出的内容</code> 发送给 <code>客户</code>，并且不会再 <code>发生转发</code>。</p>
<p>原页面的 <code>剩余部分</code> 不会得到处理。</p>
</blockquote>
<p><code>&lt;jsp:param&gt;</code> 只能用于 <code>&lt;jsp:include&gt;</code> 和 <code>&lt;jsp:forward&gt;</code> 当中。</p>
</blockquote>
<h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p><code>JSTL</code> = <code>JSP Standard Tag Library</code></p>
<blockquote>
<ul>
<li><code>&lt;c:out&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- escapeXml默认为false --&gt;
&lt;c:out value=&quot;pageContext.currentTip&quot; escapeXml=&quot;true&quot; /&gt;
&lt;!-- 设置 输出的默认值 --&gt;
&lt;c:out value=&quot;$&#123;user&#125;&quot; default=&quot;guest&quot;&gt;
</code></pre>
<ul>
<li><code>&lt;c:forEach&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:forEach var=&quot;movie&quot; items=&quot;movieList&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;$&#123;movie&#125;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre>
<blockquote>
<p>可选属性 <code>varStatus</code> 可以获得 <code>循环计次</code>：1..n</p>
</blockquote>
<ul>
<li><code>&lt;c:if&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:if test=&quot;$&#123;userType==&#39;member&#39;&quot;&gt;
    &lt;jsp:include page=&quot;inputComments.jsp&quot; /&gt;
&lt;/c:if&gt;
</code></pre>
<blockquote>
<p>虽然有 <code>if标签</code>，但没有 <code>else标签</code>。如果需要制定 <code>默认的分支</code>，请使用 <code>choose标签</code></p>
</blockquote>
<ul>
<li><code>&lt;c: choose&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:choose&gt;
    &lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
&lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
&lt;c:when test=&quot;...&quot;&gt;...&lt;/c:when&gt;
    &lt;c:otherwise&gt;...&lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre>
<ul>
<li><code>&lt;c:set&gt;</code></li>
</ul>
<p>属性变量的的值</p>
<pre><code class="lang-jsp">&lt;!-- 无体版本 --&gt;
&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot; value=&quot;Cowboy&quot; /&gt;

&lt;!-- 有体版本： 计算体的内容，并将结果作为 value的值（如果计算结果为null，则变量会被删除！） --&gt;
&lt;c:set var=&quot;userLevel&quot; scope=&quot;session&quot;&gt;
    Sheriff, Bartender, Cowgirl
&lt;/c:set&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- 注意：此处target必须传入 对象的引用本身，而不能传递 对象的ID String--&gt;
&lt;c:set target=&quot;$&#123;PetMap&#125;&quot; property=&quot;dogName&quot; value=&quot;Clover&quot; /&gt;
</code></pre>
<blockquote>
<p>对于 <code>&lt;c:out&gt;</code> ，如果没有指定 <code>scope</code>，则默认 <code>只会搜索 pageScope</code></p>
</blockquote>
<ul>
<li><code>&lt;c:remove&gt;</code></li>
</ul>
<pre><code class="lang-jsp">&lt;c:set var=&quot;userStatus&quot; scope=&quot;request&quot; value=&quot;Brilliant&quot; /&gt;
before userStatus: $&#123;userStatus&#125; &lt;br&gt;
&lt;!-- scope是可选的，默认会指定为 所有的作用域 --&gt;
&lt;c:remove var=&quot;userStatus&quot; scope=&quot;request&quot; /&gt;
&lt;!-- 此处会打印出 空字符串 （因为EL是null友好的） --&gt;
after userStatus: $&#123;userStatus&#125; &lt;br&gt;
</code></pre>
<ul>
<li><code>&lt;c:import&gt;</code></li>
</ul>
<p>在 <code>请求</code> 时，将 <code>URL指定的内容</code> 粘贴到 <code>当前页面</code>。（类似于 <code>&lt;jsp:include&gt; 标准动作</code>，只不过 <code>&lt;c:import&gt;</code> 可以 <code>通过URL来引用app外部的资源</code> ）</p>
<blockquote>
<p>可以搭配 <code>&lt;c:param&gt;</code> 来使用。</p>
<pre><code class="lang-jsp">&lt;c:import url=&quot;Header.jsp&quot;&gt;
 &lt;c:param name=&quot;subTitle&quot; value=&quot;We take the sting out of SOAP.&quot; /&gt;
&lt;/c:import&gt;
</code></pre>
</blockquote>
<ul>
<li><code>&lt;c:url&gt;</code></li>
</ul>
<pre><code class="lang-java">out.println(&quot;&lt;a href=\&quot;&quot; + response.encodeURL(&quot;/BeerTest.do&quot;) + &quot;\&quot;&gt;Click Here&lt;/a&gt;&quot;);
</code></pre>
<pre><code class="lang-jsp">&lt;a href=&quot;&lt;c:url value=&#39;/inputComments.jsp&#39; /&gt;&quot;&gt;Click Here&lt;/a&gt;
</code></pre>
<blockquote>
<p>注意，<code>&lt;c:url&gt;</code> 仅仅进行 <code>URL重写</code>，但不包含 <code>URL编码</code>。</p>
<p>若需要 <code>URL编码</code>，则使用 <code>&lt;c:param&gt;</code> 来 <code>显式地指出所有的参数列表</code></p>
<pre><code class="lang-jsp">&lt;c:url value=&quot;/inputComments.jsp&quot; var=&quot;inputURL&quot;&gt;
 &lt;c:param name=&quot;firstName&quot; value=&quot;$&#123;first&#125;&quot; /&gt;
 &lt;c:param name=&quot;lastName&quot; value=&quot;$&#123;last&#125;&quot; /&gt;
&lt;/c:url&gt;
</code></pre>
</blockquote>
<ul>
<li>建立 <code>错误页面</code></li>
</ul>
<pre><code class="lang-jsp">&lt;!-- errorPage.jsp --&gt;
&lt;%@ page isErrorPage=&quot;true&quot; %&gt;
&lt;html&gt;
You caused a $&#123;pageContext.exception&#125; on the server.
&lt;/html&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- badPage.jsp --&gt;
&lt;%@ page errorPage=&quot;errorPage.jsp&quot; %&gt;
&lt;html&gt;
    About to be bad...
    &lt;% int x = 10 / 0; %&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>此外，也可以通过 <code>DD文件</code> 来指定 <code>错误页面</code> 的 <code>匹配规则</code></p>
<pre><code class="lang-xml">&lt;error-page&gt;
 &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt;
 &lt;location&gt;/aritimeticErrorPage.jsp&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
</blockquote>
<ul>
<li><code>&lt;c:catch&gt;</code></li>
</ul>
<p>该标签会 <code>同时</code> 作为 <code>try</code> 和 <code>catch</code>，实际上，它的语义和 <code>catch</code> 不同。（它表现得更快 <code>try</code> 块）</p>
<p>一旦 <code>异常</code> 发生，<code>控制流</code> 会 <code>直接跳转</code> 到 <code>&lt;c:catch&gt;标记体的末尾</code>。即：一旦 <code>&lt;c:catch&gt;</code> 中出现异常，则 <code>体中的剩余部分</code> 不会继续运行。</p>
<ul>
<li>自定义 <code>Tag Library</code></li>
</ul>
<pre><code class="lang-xml">&lt;!-- 标记库描述文件 (Tag Library Descriptor, TLD) --&gt;
&lt;!-- 
容器在4个位置中查找TLD：
1. WEB-INF目录
2. WEB-INF的一个子目录
3. WEB-INF/lib的jar文件中的META-INF目录
4. WEB-INF/lib的jar文件中的META-INF目录的一个子目录
--&gt;
&lt;xml ...&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;short-name&gt;RandomTags&lt;/short-name&gt;

    &lt;!-- 自定义EL函数 --&gt;
    &lt;function&gt;
        &lt;name&gt;rollIt&lt;/name&gt;
        &lt;function-class&gt;foo.DiceRoller&lt;/function-class&gt;
        &lt;function-signature&gt;int rollDice()&lt;/function-signature&gt;
    &lt;/function&gt;

    &lt;!-- 自定义标签 --&gt;

    &lt;!-- uri只不过是一个名称，而不是一个必须存在的位置 --&gt;
    &lt;uri&gt;randomThings&lt;/uri&gt;
    &lt;tag&gt;
        &lt;description&gt;random advice&lt;/description&gt;
        &lt;name&gt;advice&lt;/name&gt;
        &lt;tag-class&gt;foo.AdvisorTagHandler&lt;/tag-class&gt;
        &lt;!-- 即使这里声明位empty，仍然可以通过 &lt;jsp:attribute&gt; 在标记的体中存放属性！ --&gt;
        &lt;!-- 对于声明为empty，仍然可以通过 开始标记 和 结束标记 之间没有内容 的方式来调用 --&gt;
        &lt;!-- body-content可以设置为：empty, scriptless, tagdependent, JSP --&gt;
&lt;body-content&gt;empty&lt;/body-content&gt;

        &lt;!-- 对于定制标记，并不在TLD中书写attribute，而是转移到 标记文件 中书写属性。--&gt;
        &lt;attribute&gt;
        &lt;name&gt;user&lt;/name&gt;
            &lt;!-- 必须? --&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;!-- 允许是运行时表达式量? 默认false --&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
    &lt;/tag&gt;

&lt;/xml&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;html&gt; 
    &lt;body&gt;
        &lt;!-- prefix只是一个方便引用的前缀，你可以任意取名。
但注意不要取保留的前缀名：jsp, jspx, java, javax, servlet, sun, sunw
--&gt;
        &lt;!-- 对于定制标记，使用tagdir而不是uri --&gt;
    &lt;%@ taglib prefix=&quot;mine&quot; uri=&quot;randomThings&quot; %&gt;
        Advisor Page&lt;br&gt; &lt;mine:advice user=&quot;$&#123;userName&#125;&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-java">public class AdvisorTagHandler extends SimpleTagSupport &#123;

    private String user;

    public void doTag() throws JspException, IOException &#123;
        getJspContext().getOut().write(&quot;hello &quot; + user + &quot;: &quot; + getAdvice() );
    &#125;

    public void setUser(String user) &#123;
        this.user = user;
    &#125;

    String getAdvice() &#123;
        return &quot;do nothing&quot;;
    &#125;

&#125;
</code></pre>
<p><code>标记文件 (*.tag)</code> 最后仍然需要作为 <code>JSP的一部分</code>，它可以使用 <code>JSP隐式对象</code> 和 <code>EL隐式对象</code>。</p>
<p>但不能使用 <code>ServletContext</code>，取而代之的是使用 <code>JspContext</code>。</p>
</blockquote>
<h3 id="My-Custom-Tag"><a href="#My-Custom-Tag" class="headerlink" title="My Custom Tag"></a>My Custom Tag</h3><h4 id="Custom-Tag-File"><a href="#Custom-Tag-File" class="headerlink" title="Custom Tag File"></a>Custom Tag File</h4><pre><code class="lang-xml">&lt;!-- TLD --&gt;
&lt;taglib&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;uri&gt;myTagLibrary&lt;/uri&gt;
    &lt;tag-file&gt;
    &lt;name&gt;Header&lt;/name&gt;
        &lt;path&gt;/META-INF/tags/Header.tag&lt;/path&gt;
    &lt;/tag-file&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- Custom Tag File (定制标记文件) --&gt;
&lt;%@ attribute name=&quot;subTitle&quot; required=&quot;true&quot; rtexprvalue=&quot;true&quot; %&gt;
&lt;!-- body-content可取值为 scriptless(默认值), empty, tagdependent(直接当作纯文本处理)--&gt;
&lt;%@ tag body-content=&quot;tagdepent&quot; %&gt;
&lt;strong&gt;$&#123;subTitle&#125;&lt;/strong&gt;
</code></pre>
<pre><code class="lang-jsp">&lt;!-- Usage --&gt;
&lt;%@ taglib prefix=&quot;myTags&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
    &lt;myTags:Header subTitle=&quot;We take the String out of SOAP&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="Custom-Tag-Handler"><a href="#Custom-Tag-Handler" class="headerlink" title="Custom Tag Handler"></a>Custom Tag Handler</h4><pre><code class="lang-xml">&lt;!-- TLD --&gt;
&lt;taglib ..&gt;
    &lt;tlib-version&gt;1.2&lt;/tlib-version&gt;
    &lt;uri&gt;simpleTags&lt;/uri&gt;

    &lt;tag&gt;
    &lt;description&gt;worst use of a custom tag&lt;/description&gt;
        &lt;name&gt;simple1&lt;/name&gt;
        &lt;tag-class&gt;foo.SimpleTagTest1&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>
<pre><code class="lang-java">/* Tag Handler */
// 每个SimpleTagHandler不会重用，每个实例只会被调用1次
public class SimpleTagTest1 extends SimpleTagSupport &#123;
 public void doTag() throws JspException, IOException &#123;
     // 使用 getJspBody().invoke(null) 来处理标记的体 (如果有)，并将结果打印到响应
 // 使用 throw new SkipPageException() 来停止处理后续的页面。（对于嵌套的页面，该异常只会影响 直接抛出该异常的页面，外围页面均不受异常的影响）      // setJspBody() 只会在 实际调用标记 时 确确实实 存在体 才会被执行。（不管标记的声明是否要求 有体）

     ...
 &#125;   
&#125;
</code></pre>
<pre><code class="lang-jsp">&lt;%@ taglib prefix=&quot;myTags&quot; uri=&quot;simpleTags&quot; %&gt;
&lt;html&gt;
    &lt;body&gt;
    &lt;myTags:simple1 /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>这里仅列出 <code>SimpleTagSupport</code>，不考虑 <code>TagSupport</code></p>
</blockquote>
<h3 id="Deploy-Application"><a href="#Deploy-Application" class="headerlink" title="Deploy Application"></a>Deploy Application</h3><blockquote>
<p>OUT-OF-DATE</p>
</blockquote>
<h3 id="Application-Security"><a href="#Application-Security" class="headerlink" title="Application Security"></a>Application Security</h3><p><code>Servlet安全</code> 可以划分为： <code>认证</code>，<code>授权</code>，<code>机密性</code>， <code>数据完整性</code></p>
<pre><code class="lang-jsp">&lt;web-app&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
            &lt;!-- 至少指定1个url-pattern --&gt;
        &lt;url-pattern&gt;/Beer/AddRecipe/*&lt;/url-pattern&gt;
            &lt;url-pattern&gt;/Beer/ReviewRecipe/*&lt;/url-pattern&gt;
            &lt;!-- 如果没有指定任何http方法，则所有的方法都是受约束的。（一旦指定任何http方法，则只有这部分方法受约束） --&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;

        &lt;auth-constraint&gt;
            &lt;!-- 通过role-name对用户进行许可 --&gt;
            &lt;!-- &lt;role-name&gt;*&lt;/role-name&gt; 表示所有用户都被许可--&gt;
            &lt;!-- 如果两个不同的非空&lt;auto-constraint&gt;元素应用于 同一个受限资源，则两个元素中的所有角色的并集 都可以访问该首先资源--&gt;
            &lt;role-name&gt;Admin&lt;/role-name&gt;
            &lt;role-name&gt;Member&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;
</code></pre>
<h3 id="Filter-amp-Wrapper"><a href="#Filter-amp-Wrapper" class="headerlink" title="Filter &amp; Wrapper"></a>Filter &amp; Wrapper</h3><p>只有1个 <code>过滤器接口：Filter</code>，当谈到 <code>请求过滤器</code> 和 <code>响应过滤器</code> 时，只是在说 <code>如何使用</code> 过滤器，对于容器来说，只有 <code>1种过滤器</code></p>
<pre><code class="lang-java">public class BeerRequestFilter implements Filter &#123;

    private FilterConfig fc;

    public void init(FilterConfig config) throws ServletException &#123;
this.fc=config;
    &#125;

    public void doFilter(ServletRequest req, ServletResponse, resp, FilterChain chain) throws ServletException, IOException &#123;
        // do something.
        chain.doFilter(req, resp);
    &#125;

    public void destroy() &#123;
        // do some clean-up
    &#125;

&#125;
</code></pre>
<pre><code class="lang-xml">&lt;filter&gt;
    &lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;filtet-class&gt;com.example.web.BeerRequestFilter&lt;/filtet-class&gt;
    &lt;init-param&gt;
    &lt;param-name&gt;LogFileName&lt;/param-name&gt;
        &lt;param-value&gt;UserLog.txt&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;!-- or --&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;BeerRequest&lt;/filter-name&gt;
    &lt;servlet-name&gt;AdviceServlet&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;
</code></pre>
<h3 id="Pattern-amp-struts"><a href="#Pattern-amp-struts" class="headerlink" title="Pattern &amp; struts"></a>Pattern &amp; struts</h3><blockquote>
<p>OUT-OF-DATE</p>
</blockquote>
<p>实际上，这篇文章几乎都是错误。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/jsp/">jsp</a></div><div class="post_share"></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/10484271?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SakuraWald</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a></div><a id="card-info-btn" href="https://github.com/SakuraWald"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlets-amp-JSP-Short-hand"><span class="toc-number">1.</span> <span class="toc-text">Servlets &amp; JSP Short-hand</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet"><span class="toc-number">1.1.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Register-a-servlet"><span class="toc-number">1.1.1.</span> <span class="toc-text">Register a servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Life-cycle"><span class="toc-number">1.1.2.</span> <span class="toc-text">Life-cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-simple-servlet-demo"><span class="toc-number">1.1.3.</span> <span class="toc-text">A simple servlet demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">1.2.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-Request-amp-Response"><span class="toc-number">1.2.1.</span> <span class="toc-text">Servlet: Request &amp; Response</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-Attribute-amp-Listener"><span class="toc-number">1.2.2.</span> <span class="toc-text">Application: Attribute &amp; Listener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">1.2.3.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP"><span class="toc-number">1.2.4.</span> <span class="toc-text">JSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scriptless-JSP"><span class="toc-number">1.2.5.</span> <span class="toc-text">Scriptless-JSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSTL"><span class="toc-number">1.2.6.</span> <span class="toc-text">JSTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#My-Custom-Tag"><span class="toc-number">1.2.7.</span> <span class="toc-text">My Custom Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Custom-Tag-File"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">Custom Tag File</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Custom-Tag-Handler"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">Custom Tag Handler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deploy-Application"><span class="toc-number">1.2.8.</span> <span class="toc-text">Deploy Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-Security"><span class="toc-number">1.2.9.</span> <span class="toc-text">Application Security</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter-amp-Wrapper"><span class="toc-number">1.2.10.</span> <span class="toc-text">Filter &amp; Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern-amp-struts"><span class="toc-number">1.2.11.</span> <span class="toc-text">Pattern &amp; struts</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script><script>const loadSvgPanZoom = () => {
    Array.from(document.getElementsByTagName('svg')).forEach((item, index) => {
        var saved_viewbox = item.getAttribute("viewBox");
        var controller = svgPanZoom(item);
        item.setAttribute("viewBox", saved_viewbox);
        controller.fit();
        controller.center();
    })
}

document.addEventListener('MermaidRendered', loadSvgPanZoom);</script><script>document.addEventListener("PrismjsRendered", () => {

  const $mermaidWrap = document.querySelectorAll('#article-container code.lang-mermaid')

  if ($mermaidWrap.length) {

    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'
      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode);
          mermaidSrc.remove();
        })
      })

      document.dispatchEvent(new Event("MermaidRendered"));
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }

});</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/show-language/prism-show-language.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script>document.dispatchEvent(new Event("PrismjsRendered"));</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'adb9e6af56214e6280fe',
      clientSecret: '4a4f71215d63de24a1b2fec88c231f6fb94c2069',
      repo: 'sakurawald.github.io',
      owner: 'SakuraWald',
      admin: ['SakuraWald'],
      id: '6d53aa6275c957695cc03b644ea2ed2c',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>